
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Domain
 * 
 */
export type Domain = $Result.DefaultSelection<Prisma.$DomainPayload>
/**
 * Model CrawlResult
 * 
 */
export type CrawlResult = $Result.DefaultSelection<Prisma.$CrawlResultPayload>
/**
 * Model Keyword
 * 
 */
export type Keyword = $Result.DefaultSelection<Prisma.$KeywordPayload>
/**
 * Model Phrase
 * 
 */
export type Phrase = $Result.DefaultSelection<Prisma.$PhrasePayload>
/**
 * Model AIQueryResult
 * 
 */
export type AIQueryResult = $Result.DefaultSelection<Prisma.$AIQueryResultPayload>
/**
 * Model DashboardAnalysis
 * 
 */
export type DashboardAnalysis = $Result.DefaultSelection<Prisma.$DashboardAnalysisPayload>
/**
 * Model CompetitorAnalysis
 * 
 */
export type CompetitorAnalysis = $Result.DefaultSelection<Prisma.$CompetitorAnalysisPayload>
/**
 * Model SuggestedCompetitor
 * 
 */
export type SuggestedCompetitor = $Result.DefaultSelection<Prisma.$SuggestedCompetitorPayload>
/**
 * Model AnalysisPhase
 * 
 */
export type AnalysisPhase = $Result.DefaultSelection<Prisma.$AnalysisPhasePayload>
/**
 * Model SemanticAnalysis
 * 
 */
export type SemanticAnalysis = $Result.DefaultSelection<Prisma.$SemanticAnalysisPayload>
/**
 * Model KeywordAnalysis
 * 
 */
export type KeywordAnalysis = $Result.DefaultSelection<Prisma.$KeywordAnalysisPayload>
/**
 * Model SearchVolumeClassification
 * 
 */
export type SearchVolumeClassification = $Result.DefaultSelection<Prisma.$SearchVolumeClassificationPayload>
/**
 * Model IntentClassification
 * 
 */
export type IntentClassification = $Result.DefaultSelection<Prisma.$IntentClassificationPayload>
/**
 * Model CommunityInsight
 * 
 */
export type CommunityInsight = $Result.DefaultSelection<Prisma.$CommunityInsightPayload>
/**
 * Model SearchPattern
 * 
 */
export type SearchPattern = $Result.DefaultSelection<Prisma.$SearchPatternPayload>
/**
 * Model PhraseIntentClassification
 * 
 */
export type PhraseIntentClassification = $Result.DefaultSelection<Prisma.$PhraseIntentClassificationPayload>
/**
 * Model PhraseScore
 * 
 */
export type PhraseScore = $Result.DefaultSelection<Prisma.$PhraseScorePayload>
/**
 * Model IntentPhraseGeneration
 * 
 */
export type IntentPhraseGeneration = $Result.DefaultSelection<Prisma.$IntentPhraseGenerationPayload>
/**
 * Model CommunityMiningResult
 * 
 */
export type CommunityMiningResult = $Result.DefaultSelection<Prisma.$CommunityMiningResultPayload>
/**
 * Model SearchPatternResult
 * 
 */
export type SearchPatternResult = $Result.DefaultSelection<Prisma.$SearchPatternResultPayload>
/**
 * Model IntentClassificationResult
 * 
 */
export type IntentClassificationResult = $Result.DefaultSelection<Prisma.$IntentClassificationResultPayload>
/**
 * Model GeneratedIntentPhrase
 * 
 */
export type GeneratedIntentPhrase = $Result.DefaultSelection<Prisma.$GeneratedIntentPhrasePayload>
/**
 * Model RelevanceScoreResult
 * 
 */
export type RelevanceScoreResult = $Result.DefaultSelection<Prisma.$RelevanceScoreResultPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.domain`: Exposes CRUD operations for the **Domain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Domains
    * const domains = await prisma.domain.findMany()
    * ```
    */
  get domain(): Prisma.DomainDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.crawlResult`: Exposes CRUD operations for the **CrawlResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrawlResults
    * const crawlResults = await prisma.crawlResult.findMany()
    * ```
    */
  get crawlResult(): Prisma.CrawlResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.keyword`: Exposes CRUD operations for the **Keyword** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Keywords
    * const keywords = await prisma.keyword.findMany()
    * ```
    */
  get keyword(): Prisma.KeywordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.phrase`: Exposes CRUD operations for the **Phrase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Phrases
    * const phrases = await prisma.phrase.findMany()
    * ```
    */
  get phrase(): Prisma.PhraseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIQueryResult`: Exposes CRUD operations for the **AIQueryResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIQueryResults
    * const aIQueryResults = await prisma.aIQueryResult.findMany()
    * ```
    */
  get aIQueryResult(): Prisma.AIQueryResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dashboardAnalysis`: Exposes CRUD operations for the **DashboardAnalysis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DashboardAnalyses
    * const dashboardAnalyses = await prisma.dashboardAnalysis.findMany()
    * ```
    */
  get dashboardAnalysis(): Prisma.DashboardAnalysisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.competitorAnalysis`: Exposes CRUD operations for the **CompetitorAnalysis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompetitorAnalyses
    * const competitorAnalyses = await prisma.competitorAnalysis.findMany()
    * ```
    */
  get competitorAnalysis(): Prisma.CompetitorAnalysisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.suggestedCompetitor`: Exposes CRUD operations for the **SuggestedCompetitor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SuggestedCompetitors
    * const suggestedCompetitors = await prisma.suggestedCompetitor.findMany()
    * ```
    */
  get suggestedCompetitor(): Prisma.SuggestedCompetitorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analysisPhase`: Exposes CRUD operations for the **AnalysisPhase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalysisPhases
    * const analysisPhases = await prisma.analysisPhase.findMany()
    * ```
    */
  get analysisPhase(): Prisma.AnalysisPhaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.semanticAnalysis`: Exposes CRUD operations for the **SemanticAnalysis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SemanticAnalyses
    * const semanticAnalyses = await prisma.semanticAnalysis.findMany()
    * ```
    */
  get semanticAnalysis(): Prisma.SemanticAnalysisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.keywordAnalysis`: Exposes CRUD operations for the **KeywordAnalysis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KeywordAnalyses
    * const keywordAnalyses = await prisma.keywordAnalysis.findMany()
    * ```
    */
  get keywordAnalysis(): Prisma.KeywordAnalysisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.searchVolumeClassification`: Exposes CRUD operations for the **SearchVolumeClassification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SearchVolumeClassifications
    * const searchVolumeClassifications = await prisma.searchVolumeClassification.findMany()
    * ```
    */
  get searchVolumeClassification(): Prisma.SearchVolumeClassificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.intentClassification`: Exposes CRUD operations for the **IntentClassification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntentClassifications
    * const intentClassifications = await prisma.intentClassification.findMany()
    * ```
    */
  get intentClassification(): Prisma.IntentClassificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.communityInsight`: Exposes CRUD operations for the **CommunityInsight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityInsights
    * const communityInsights = await prisma.communityInsight.findMany()
    * ```
    */
  get communityInsight(): Prisma.CommunityInsightDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.searchPattern`: Exposes CRUD operations for the **SearchPattern** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SearchPatterns
    * const searchPatterns = await prisma.searchPattern.findMany()
    * ```
    */
  get searchPattern(): Prisma.SearchPatternDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.phraseIntentClassification`: Exposes CRUD operations for the **PhraseIntentClassification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhraseIntentClassifications
    * const phraseIntentClassifications = await prisma.phraseIntentClassification.findMany()
    * ```
    */
  get phraseIntentClassification(): Prisma.PhraseIntentClassificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.phraseScore`: Exposes CRUD operations for the **PhraseScore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhraseScores
    * const phraseScores = await prisma.phraseScore.findMany()
    * ```
    */
  get phraseScore(): Prisma.PhraseScoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.intentPhraseGeneration`: Exposes CRUD operations for the **IntentPhraseGeneration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntentPhraseGenerations
    * const intentPhraseGenerations = await prisma.intentPhraseGeneration.findMany()
    * ```
    */
  get intentPhraseGeneration(): Prisma.IntentPhraseGenerationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.communityMiningResult`: Exposes CRUD operations for the **CommunityMiningResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityMiningResults
    * const communityMiningResults = await prisma.communityMiningResult.findMany()
    * ```
    */
  get communityMiningResult(): Prisma.CommunityMiningResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.searchPatternResult`: Exposes CRUD operations for the **SearchPatternResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SearchPatternResults
    * const searchPatternResults = await prisma.searchPatternResult.findMany()
    * ```
    */
  get searchPatternResult(): Prisma.SearchPatternResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.intentClassificationResult`: Exposes CRUD operations for the **IntentClassificationResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntentClassificationResults
    * const intentClassificationResults = await prisma.intentClassificationResult.findMany()
    * ```
    */
  get intentClassificationResult(): Prisma.IntentClassificationResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.generatedIntentPhrase`: Exposes CRUD operations for the **GeneratedIntentPhrase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GeneratedIntentPhrases
    * const generatedIntentPhrases = await prisma.generatedIntentPhrase.findMany()
    * ```
    */
  get generatedIntentPhrase(): Prisma.GeneratedIntentPhraseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.relevanceScoreResult`: Exposes CRUD operations for the **RelevanceScoreResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RelevanceScoreResults
    * const relevanceScoreResults = await prisma.relevanceScoreResult.findMany()
    * ```
    */
  get relevanceScoreResult(): Prisma.RelevanceScoreResultDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.1
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Domain: 'Domain',
    CrawlResult: 'CrawlResult',
    Keyword: 'Keyword',
    Phrase: 'Phrase',
    AIQueryResult: 'AIQueryResult',
    DashboardAnalysis: 'DashboardAnalysis',
    CompetitorAnalysis: 'CompetitorAnalysis',
    SuggestedCompetitor: 'SuggestedCompetitor',
    AnalysisPhase: 'AnalysisPhase',
    SemanticAnalysis: 'SemanticAnalysis',
    KeywordAnalysis: 'KeywordAnalysis',
    SearchVolumeClassification: 'SearchVolumeClassification',
    IntentClassification: 'IntentClassification',
    CommunityInsight: 'CommunityInsight',
    SearchPattern: 'SearchPattern',
    PhraseIntentClassification: 'PhraseIntentClassification',
    PhraseScore: 'PhraseScore',
    IntentPhraseGeneration: 'IntentPhraseGeneration',
    CommunityMiningResult: 'CommunityMiningResult',
    SearchPatternResult: 'SearchPatternResult',
    IntentClassificationResult: 'IntentClassificationResult',
    GeneratedIntentPhrase: 'GeneratedIntentPhrase',
    RelevanceScoreResult: 'RelevanceScoreResult'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "domain" | "crawlResult" | "keyword" | "phrase" | "aIQueryResult" | "dashboardAnalysis" | "competitorAnalysis" | "suggestedCompetitor" | "analysisPhase" | "semanticAnalysis" | "keywordAnalysis" | "searchVolumeClassification" | "intentClassification" | "communityInsight" | "searchPattern" | "phraseIntentClassification" | "phraseScore" | "intentPhraseGeneration" | "communityMiningResult" | "searchPatternResult" | "intentClassificationResult" | "generatedIntentPhrase" | "relevanceScoreResult"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Domain: {
        payload: Prisma.$DomainPayload<ExtArgs>
        fields: Prisma.DomainFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DomainFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DomainFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>
          }
          findFirst: {
            args: Prisma.DomainFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DomainFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>
          }
          findMany: {
            args: Prisma.DomainFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>[]
          }
          create: {
            args: Prisma.DomainCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>
          }
          createMany: {
            args: Prisma.DomainCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DomainCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>[]
          }
          delete: {
            args: Prisma.DomainDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>
          }
          update: {
            args: Prisma.DomainUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>
          }
          deleteMany: {
            args: Prisma.DomainDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DomainUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DomainUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>
          }
          aggregate: {
            args: Prisma.DomainAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDomain>
          }
          groupBy: {
            args: Prisma.DomainGroupByArgs<ExtArgs>
            result: $Utils.Optional<DomainGroupByOutputType>[]
          }
          count: {
            args: Prisma.DomainCountArgs<ExtArgs>
            result: $Utils.Optional<DomainCountAggregateOutputType> | number
          }
        }
      }
      CrawlResult: {
        payload: Prisma.$CrawlResultPayload<ExtArgs>
        fields: Prisma.CrawlResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrawlResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrawlResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrawlResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrawlResultPayload>
          }
          findFirst: {
            args: Prisma.CrawlResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrawlResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrawlResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrawlResultPayload>
          }
          findMany: {
            args: Prisma.CrawlResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrawlResultPayload>[]
          }
          create: {
            args: Prisma.CrawlResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrawlResultPayload>
          }
          createMany: {
            args: Prisma.CrawlResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CrawlResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrawlResultPayload>[]
          }
          delete: {
            args: Prisma.CrawlResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrawlResultPayload>
          }
          update: {
            args: Prisma.CrawlResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrawlResultPayload>
          }
          deleteMany: {
            args: Prisma.CrawlResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CrawlResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CrawlResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrawlResultPayload>
          }
          aggregate: {
            args: Prisma.CrawlResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrawlResult>
          }
          groupBy: {
            args: Prisma.CrawlResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<CrawlResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrawlResultCountArgs<ExtArgs>
            result: $Utils.Optional<CrawlResultCountAggregateOutputType> | number
          }
        }
      }
      Keyword: {
        payload: Prisma.$KeywordPayload<ExtArgs>
        fields: Prisma.KeywordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KeywordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KeywordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>
          }
          findFirst: {
            args: Prisma.KeywordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KeywordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>
          }
          findMany: {
            args: Prisma.KeywordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>[]
          }
          create: {
            args: Prisma.KeywordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>
          }
          createMany: {
            args: Prisma.KeywordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KeywordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>[]
          }
          delete: {
            args: Prisma.KeywordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>
          }
          update: {
            args: Prisma.KeywordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>
          }
          deleteMany: {
            args: Prisma.KeywordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KeywordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KeywordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>
          }
          aggregate: {
            args: Prisma.KeywordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKeyword>
          }
          groupBy: {
            args: Prisma.KeywordGroupByArgs<ExtArgs>
            result: $Utils.Optional<KeywordGroupByOutputType>[]
          }
          count: {
            args: Prisma.KeywordCountArgs<ExtArgs>
            result: $Utils.Optional<KeywordCountAggregateOutputType> | number
          }
        }
      }
      Phrase: {
        payload: Prisma.$PhrasePayload<ExtArgs>
        fields: Prisma.PhraseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhraseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhrasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhraseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhrasePayload>
          }
          findFirst: {
            args: Prisma.PhraseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhrasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhraseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhrasePayload>
          }
          findMany: {
            args: Prisma.PhraseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhrasePayload>[]
          }
          create: {
            args: Prisma.PhraseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhrasePayload>
          }
          createMany: {
            args: Prisma.PhraseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PhraseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhrasePayload>[]
          }
          delete: {
            args: Prisma.PhraseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhrasePayload>
          }
          update: {
            args: Prisma.PhraseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhrasePayload>
          }
          deleteMany: {
            args: Prisma.PhraseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhraseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PhraseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhrasePayload>
          }
          aggregate: {
            args: Prisma.PhraseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhrase>
          }
          groupBy: {
            args: Prisma.PhraseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhraseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhraseCountArgs<ExtArgs>
            result: $Utils.Optional<PhraseCountAggregateOutputType> | number
          }
        }
      }
      AIQueryResult: {
        payload: Prisma.$AIQueryResultPayload<ExtArgs>
        fields: Prisma.AIQueryResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIQueryResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIQueryResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIQueryResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIQueryResultPayload>
          }
          findFirst: {
            args: Prisma.AIQueryResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIQueryResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIQueryResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIQueryResultPayload>
          }
          findMany: {
            args: Prisma.AIQueryResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIQueryResultPayload>[]
          }
          create: {
            args: Prisma.AIQueryResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIQueryResultPayload>
          }
          createMany: {
            args: Prisma.AIQueryResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIQueryResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIQueryResultPayload>[]
          }
          delete: {
            args: Prisma.AIQueryResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIQueryResultPayload>
          }
          update: {
            args: Prisma.AIQueryResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIQueryResultPayload>
          }
          deleteMany: {
            args: Prisma.AIQueryResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIQueryResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AIQueryResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIQueryResultPayload>
          }
          aggregate: {
            args: Prisma.AIQueryResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIQueryResult>
          }
          groupBy: {
            args: Prisma.AIQueryResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIQueryResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIQueryResultCountArgs<ExtArgs>
            result: $Utils.Optional<AIQueryResultCountAggregateOutputType> | number
          }
        }
      }
      DashboardAnalysis: {
        payload: Prisma.$DashboardAnalysisPayload<ExtArgs>
        fields: Prisma.DashboardAnalysisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DashboardAnalysisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardAnalysisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DashboardAnalysisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardAnalysisPayload>
          }
          findFirst: {
            args: Prisma.DashboardAnalysisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardAnalysisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DashboardAnalysisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardAnalysisPayload>
          }
          findMany: {
            args: Prisma.DashboardAnalysisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardAnalysisPayload>[]
          }
          create: {
            args: Prisma.DashboardAnalysisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardAnalysisPayload>
          }
          createMany: {
            args: Prisma.DashboardAnalysisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DashboardAnalysisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardAnalysisPayload>[]
          }
          delete: {
            args: Prisma.DashboardAnalysisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardAnalysisPayload>
          }
          update: {
            args: Prisma.DashboardAnalysisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardAnalysisPayload>
          }
          deleteMany: {
            args: Prisma.DashboardAnalysisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DashboardAnalysisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DashboardAnalysisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardAnalysisPayload>
          }
          aggregate: {
            args: Prisma.DashboardAnalysisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDashboardAnalysis>
          }
          groupBy: {
            args: Prisma.DashboardAnalysisGroupByArgs<ExtArgs>
            result: $Utils.Optional<DashboardAnalysisGroupByOutputType>[]
          }
          count: {
            args: Prisma.DashboardAnalysisCountArgs<ExtArgs>
            result: $Utils.Optional<DashboardAnalysisCountAggregateOutputType> | number
          }
        }
      }
      CompetitorAnalysis: {
        payload: Prisma.$CompetitorAnalysisPayload<ExtArgs>
        fields: Prisma.CompetitorAnalysisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompetitorAnalysisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorAnalysisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompetitorAnalysisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorAnalysisPayload>
          }
          findFirst: {
            args: Prisma.CompetitorAnalysisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorAnalysisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompetitorAnalysisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorAnalysisPayload>
          }
          findMany: {
            args: Prisma.CompetitorAnalysisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorAnalysisPayload>[]
          }
          create: {
            args: Prisma.CompetitorAnalysisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorAnalysisPayload>
          }
          createMany: {
            args: Prisma.CompetitorAnalysisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompetitorAnalysisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorAnalysisPayload>[]
          }
          delete: {
            args: Prisma.CompetitorAnalysisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorAnalysisPayload>
          }
          update: {
            args: Prisma.CompetitorAnalysisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorAnalysisPayload>
          }
          deleteMany: {
            args: Prisma.CompetitorAnalysisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompetitorAnalysisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompetitorAnalysisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorAnalysisPayload>
          }
          aggregate: {
            args: Prisma.CompetitorAnalysisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompetitorAnalysis>
          }
          groupBy: {
            args: Prisma.CompetitorAnalysisGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompetitorAnalysisGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompetitorAnalysisCountArgs<ExtArgs>
            result: $Utils.Optional<CompetitorAnalysisCountAggregateOutputType> | number
          }
        }
      }
      SuggestedCompetitor: {
        payload: Prisma.$SuggestedCompetitorPayload<ExtArgs>
        fields: Prisma.SuggestedCompetitorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SuggestedCompetitorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestedCompetitorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SuggestedCompetitorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestedCompetitorPayload>
          }
          findFirst: {
            args: Prisma.SuggestedCompetitorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestedCompetitorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SuggestedCompetitorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestedCompetitorPayload>
          }
          findMany: {
            args: Prisma.SuggestedCompetitorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestedCompetitorPayload>[]
          }
          create: {
            args: Prisma.SuggestedCompetitorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestedCompetitorPayload>
          }
          createMany: {
            args: Prisma.SuggestedCompetitorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SuggestedCompetitorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestedCompetitorPayload>[]
          }
          delete: {
            args: Prisma.SuggestedCompetitorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestedCompetitorPayload>
          }
          update: {
            args: Prisma.SuggestedCompetitorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestedCompetitorPayload>
          }
          deleteMany: {
            args: Prisma.SuggestedCompetitorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SuggestedCompetitorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SuggestedCompetitorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestedCompetitorPayload>
          }
          aggregate: {
            args: Prisma.SuggestedCompetitorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuggestedCompetitor>
          }
          groupBy: {
            args: Prisma.SuggestedCompetitorGroupByArgs<ExtArgs>
            result: $Utils.Optional<SuggestedCompetitorGroupByOutputType>[]
          }
          count: {
            args: Prisma.SuggestedCompetitorCountArgs<ExtArgs>
            result: $Utils.Optional<SuggestedCompetitorCountAggregateOutputType> | number
          }
        }
      }
      AnalysisPhase: {
        payload: Prisma.$AnalysisPhasePayload<ExtArgs>
        fields: Prisma.AnalysisPhaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalysisPhaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPhasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalysisPhaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPhasePayload>
          }
          findFirst: {
            args: Prisma.AnalysisPhaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPhasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalysisPhaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPhasePayload>
          }
          findMany: {
            args: Prisma.AnalysisPhaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPhasePayload>[]
          }
          create: {
            args: Prisma.AnalysisPhaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPhasePayload>
          }
          createMany: {
            args: Prisma.AnalysisPhaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalysisPhaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPhasePayload>[]
          }
          delete: {
            args: Prisma.AnalysisPhaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPhasePayload>
          }
          update: {
            args: Prisma.AnalysisPhaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPhasePayload>
          }
          deleteMany: {
            args: Prisma.AnalysisPhaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalysisPhaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnalysisPhaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPhasePayload>
          }
          aggregate: {
            args: Prisma.AnalysisPhaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalysisPhase>
          }
          groupBy: {
            args: Prisma.AnalysisPhaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalysisPhaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalysisPhaseCountArgs<ExtArgs>
            result: $Utils.Optional<AnalysisPhaseCountAggregateOutputType> | number
          }
        }
      }
      SemanticAnalysis: {
        payload: Prisma.$SemanticAnalysisPayload<ExtArgs>
        fields: Prisma.SemanticAnalysisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SemanticAnalysisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemanticAnalysisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SemanticAnalysisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemanticAnalysisPayload>
          }
          findFirst: {
            args: Prisma.SemanticAnalysisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemanticAnalysisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SemanticAnalysisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemanticAnalysisPayload>
          }
          findMany: {
            args: Prisma.SemanticAnalysisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemanticAnalysisPayload>[]
          }
          create: {
            args: Prisma.SemanticAnalysisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemanticAnalysisPayload>
          }
          createMany: {
            args: Prisma.SemanticAnalysisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SemanticAnalysisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemanticAnalysisPayload>[]
          }
          delete: {
            args: Prisma.SemanticAnalysisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemanticAnalysisPayload>
          }
          update: {
            args: Prisma.SemanticAnalysisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemanticAnalysisPayload>
          }
          deleteMany: {
            args: Prisma.SemanticAnalysisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SemanticAnalysisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SemanticAnalysisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemanticAnalysisPayload>
          }
          aggregate: {
            args: Prisma.SemanticAnalysisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSemanticAnalysis>
          }
          groupBy: {
            args: Prisma.SemanticAnalysisGroupByArgs<ExtArgs>
            result: $Utils.Optional<SemanticAnalysisGroupByOutputType>[]
          }
          count: {
            args: Prisma.SemanticAnalysisCountArgs<ExtArgs>
            result: $Utils.Optional<SemanticAnalysisCountAggregateOutputType> | number
          }
        }
      }
      KeywordAnalysis: {
        payload: Prisma.$KeywordAnalysisPayload<ExtArgs>
        fields: Prisma.KeywordAnalysisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KeywordAnalysisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordAnalysisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KeywordAnalysisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordAnalysisPayload>
          }
          findFirst: {
            args: Prisma.KeywordAnalysisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordAnalysisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KeywordAnalysisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordAnalysisPayload>
          }
          findMany: {
            args: Prisma.KeywordAnalysisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordAnalysisPayload>[]
          }
          create: {
            args: Prisma.KeywordAnalysisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordAnalysisPayload>
          }
          createMany: {
            args: Prisma.KeywordAnalysisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KeywordAnalysisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordAnalysisPayload>[]
          }
          delete: {
            args: Prisma.KeywordAnalysisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordAnalysisPayload>
          }
          update: {
            args: Prisma.KeywordAnalysisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordAnalysisPayload>
          }
          deleteMany: {
            args: Prisma.KeywordAnalysisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KeywordAnalysisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KeywordAnalysisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordAnalysisPayload>
          }
          aggregate: {
            args: Prisma.KeywordAnalysisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKeywordAnalysis>
          }
          groupBy: {
            args: Prisma.KeywordAnalysisGroupByArgs<ExtArgs>
            result: $Utils.Optional<KeywordAnalysisGroupByOutputType>[]
          }
          count: {
            args: Prisma.KeywordAnalysisCountArgs<ExtArgs>
            result: $Utils.Optional<KeywordAnalysisCountAggregateOutputType> | number
          }
        }
      }
      SearchVolumeClassification: {
        payload: Prisma.$SearchVolumeClassificationPayload<ExtArgs>
        fields: Prisma.SearchVolumeClassificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SearchVolumeClassificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchVolumeClassificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SearchVolumeClassificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchVolumeClassificationPayload>
          }
          findFirst: {
            args: Prisma.SearchVolumeClassificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchVolumeClassificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SearchVolumeClassificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchVolumeClassificationPayload>
          }
          findMany: {
            args: Prisma.SearchVolumeClassificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchVolumeClassificationPayload>[]
          }
          create: {
            args: Prisma.SearchVolumeClassificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchVolumeClassificationPayload>
          }
          createMany: {
            args: Prisma.SearchVolumeClassificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SearchVolumeClassificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchVolumeClassificationPayload>[]
          }
          delete: {
            args: Prisma.SearchVolumeClassificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchVolumeClassificationPayload>
          }
          update: {
            args: Prisma.SearchVolumeClassificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchVolumeClassificationPayload>
          }
          deleteMany: {
            args: Prisma.SearchVolumeClassificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SearchVolumeClassificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SearchVolumeClassificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchVolumeClassificationPayload>
          }
          aggregate: {
            args: Prisma.SearchVolumeClassificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSearchVolumeClassification>
          }
          groupBy: {
            args: Prisma.SearchVolumeClassificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SearchVolumeClassificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SearchVolumeClassificationCountArgs<ExtArgs>
            result: $Utils.Optional<SearchVolumeClassificationCountAggregateOutputType> | number
          }
        }
      }
      IntentClassification: {
        payload: Prisma.$IntentClassificationPayload<ExtArgs>
        fields: Prisma.IntentClassificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntentClassificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentClassificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntentClassificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentClassificationPayload>
          }
          findFirst: {
            args: Prisma.IntentClassificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentClassificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntentClassificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentClassificationPayload>
          }
          findMany: {
            args: Prisma.IntentClassificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentClassificationPayload>[]
          }
          create: {
            args: Prisma.IntentClassificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentClassificationPayload>
          }
          createMany: {
            args: Prisma.IntentClassificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntentClassificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentClassificationPayload>[]
          }
          delete: {
            args: Prisma.IntentClassificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentClassificationPayload>
          }
          update: {
            args: Prisma.IntentClassificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentClassificationPayload>
          }
          deleteMany: {
            args: Prisma.IntentClassificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntentClassificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IntentClassificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentClassificationPayload>
          }
          aggregate: {
            args: Prisma.IntentClassificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntentClassification>
          }
          groupBy: {
            args: Prisma.IntentClassificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntentClassificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntentClassificationCountArgs<ExtArgs>
            result: $Utils.Optional<IntentClassificationCountAggregateOutputType> | number
          }
        }
      }
      CommunityInsight: {
        payload: Prisma.$CommunityInsightPayload<ExtArgs>
        fields: Prisma.CommunityInsightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityInsightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityInsightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityInsightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityInsightPayload>
          }
          findFirst: {
            args: Prisma.CommunityInsightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityInsightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityInsightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityInsightPayload>
          }
          findMany: {
            args: Prisma.CommunityInsightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityInsightPayload>[]
          }
          create: {
            args: Prisma.CommunityInsightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityInsightPayload>
          }
          createMany: {
            args: Prisma.CommunityInsightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommunityInsightCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityInsightPayload>[]
          }
          delete: {
            args: Prisma.CommunityInsightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityInsightPayload>
          }
          update: {
            args: Prisma.CommunityInsightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityInsightPayload>
          }
          deleteMany: {
            args: Prisma.CommunityInsightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityInsightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommunityInsightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityInsightPayload>
          }
          aggregate: {
            args: Prisma.CommunityInsightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunityInsight>
          }
          groupBy: {
            args: Prisma.CommunityInsightGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunityInsightGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityInsightCountArgs<ExtArgs>
            result: $Utils.Optional<CommunityInsightCountAggregateOutputType> | number
          }
        }
      }
      SearchPattern: {
        payload: Prisma.$SearchPatternPayload<ExtArgs>
        fields: Prisma.SearchPatternFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SearchPatternFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchPatternPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SearchPatternFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchPatternPayload>
          }
          findFirst: {
            args: Prisma.SearchPatternFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchPatternPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SearchPatternFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchPatternPayload>
          }
          findMany: {
            args: Prisma.SearchPatternFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchPatternPayload>[]
          }
          create: {
            args: Prisma.SearchPatternCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchPatternPayload>
          }
          createMany: {
            args: Prisma.SearchPatternCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SearchPatternCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchPatternPayload>[]
          }
          delete: {
            args: Prisma.SearchPatternDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchPatternPayload>
          }
          update: {
            args: Prisma.SearchPatternUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchPatternPayload>
          }
          deleteMany: {
            args: Prisma.SearchPatternDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SearchPatternUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SearchPatternUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchPatternPayload>
          }
          aggregate: {
            args: Prisma.SearchPatternAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSearchPattern>
          }
          groupBy: {
            args: Prisma.SearchPatternGroupByArgs<ExtArgs>
            result: $Utils.Optional<SearchPatternGroupByOutputType>[]
          }
          count: {
            args: Prisma.SearchPatternCountArgs<ExtArgs>
            result: $Utils.Optional<SearchPatternCountAggregateOutputType> | number
          }
        }
      }
      PhraseIntentClassification: {
        payload: Prisma.$PhraseIntentClassificationPayload<ExtArgs>
        fields: Prisma.PhraseIntentClassificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhraseIntentClassificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhraseIntentClassificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhraseIntentClassificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhraseIntentClassificationPayload>
          }
          findFirst: {
            args: Prisma.PhraseIntentClassificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhraseIntentClassificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhraseIntentClassificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhraseIntentClassificationPayload>
          }
          findMany: {
            args: Prisma.PhraseIntentClassificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhraseIntentClassificationPayload>[]
          }
          create: {
            args: Prisma.PhraseIntentClassificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhraseIntentClassificationPayload>
          }
          createMany: {
            args: Prisma.PhraseIntentClassificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PhraseIntentClassificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhraseIntentClassificationPayload>[]
          }
          delete: {
            args: Prisma.PhraseIntentClassificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhraseIntentClassificationPayload>
          }
          update: {
            args: Prisma.PhraseIntentClassificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhraseIntentClassificationPayload>
          }
          deleteMany: {
            args: Prisma.PhraseIntentClassificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhraseIntentClassificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PhraseIntentClassificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhraseIntentClassificationPayload>
          }
          aggregate: {
            args: Prisma.PhraseIntentClassificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhraseIntentClassification>
          }
          groupBy: {
            args: Prisma.PhraseIntentClassificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhraseIntentClassificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhraseIntentClassificationCountArgs<ExtArgs>
            result: $Utils.Optional<PhraseIntentClassificationCountAggregateOutputType> | number
          }
        }
      }
      PhraseScore: {
        payload: Prisma.$PhraseScorePayload<ExtArgs>
        fields: Prisma.PhraseScoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhraseScoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhraseScorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhraseScoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhraseScorePayload>
          }
          findFirst: {
            args: Prisma.PhraseScoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhraseScorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhraseScoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhraseScorePayload>
          }
          findMany: {
            args: Prisma.PhraseScoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhraseScorePayload>[]
          }
          create: {
            args: Prisma.PhraseScoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhraseScorePayload>
          }
          createMany: {
            args: Prisma.PhraseScoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PhraseScoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhraseScorePayload>[]
          }
          delete: {
            args: Prisma.PhraseScoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhraseScorePayload>
          }
          update: {
            args: Prisma.PhraseScoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhraseScorePayload>
          }
          deleteMany: {
            args: Prisma.PhraseScoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhraseScoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PhraseScoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhraseScorePayload>
          }
          aggregate: {
            args: Prisma.PhraseScoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhraseScore>
          }
          groupBy: {
            args: Prisma.PhraseScoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhraseScoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhraseScoreCountArgs<ExtArgs>
            result: $Utils.Optional<PhraseScoreCountAggregateOutputType> | number
          }
        }
      }
      IntentPhraseGeneration: {
        payload: Prisma.$IntentPhraseGenerationPayload<ExtArgs>
        fields: Prisma.IntentPhraseGenerationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntentPhraseGenerationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentPhraseGenerationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntentPhraseGenerationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentPhraseGenerationPayload>
          }
          findFirst: {
            args: Prisma.IntentPhraseGenerationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentPhraseGenerationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntentPhraseGenerationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentPhraseGenerationPayload>
          }
          findMany: {
            args: Prisma.IntentPhraseGenerationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentPhraseGenerationPayload>[]
          }
          create: {
            args: Prisma.IntentPhraseGenerationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentPhraseGenerationPayload>
          }
          createMany: {
            args: Prisma.IntentPhraseGenerationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntentPhraseGenerationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentPhraseGenerationPayload>[]
          }
          delete: {
            args: Prisma.IntentPhraseGenerationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentPhraseGenerationPayload>
          }
          update: {
            args: Prisma.IntentPhraseGenerationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentPhraseGenerationPayload>
          }
          deleteMany: {
            args: Prisma.IntentPhraseGenerationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntentPhraseGenerationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IntentPhraseGenerationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentPhraseGenerationPayload>
          }
          aggregate: {
            args: Prisma.IntentPhraseGenerationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntentPhraseGeneration>
          }
          groupBy: {
            args: Prisma.IntentPhraseGenerationGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntentPhraseGenerationGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntentPhraseGenerationCountArgs<ExtArgs>
            result: $Utils.Optional<IntentPhraseGenerationCountAggregateOutputType> | number
          }
        }
      }
      CommunityMiningResult: {
        payload: Prisma.$CommunityMiningResultPayload<ExtArgs>
        fields: Prisma.CommunityMiningResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityMiningResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMiningResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityMiningResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMiningResultPayload>
          }
          findFirst: {
            args: Prisma.CommunityMiningResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMiningResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityMiningResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMiningResultPayload>
          }
          findMany: {
            args: Prisma.CommunityMiningResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMiningResultPayload>[]
          }
          create: {
            args: Prisma.CommunityMiningResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMiningResultPayload>
          }
          createMany: {
            args: Prisma.CommunityMiningResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommunityMiningResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMiningResultPayload>[]
          }
          delete: {
            args: Prisma.CommunityMiningResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMiningResultPayload>
          }
          update: {
            args: Prisma.CommunityMiningResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMiningResultPayload>
          }
          deleteMany: {
            args: Prisma.CommunityMiningResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityMiningResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommunityMiningResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMiningResultPayload>
          }
          aggregate: {
            args: Prisma.CommunityMiningResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunityMiningResult>
          }
          groupBy: {
            args: Prisma.CommunityMiningResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunityMiningResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityMiningResultCountArgs<ExtArgs>
            result: $Utils.Optional<CommunityMiningResultCountAggregateOutputType> | number
          }
        }
      }
      SearchPatternResult: {
        payload: Prisma.$SearchPatternResultPayload<ExtArgs>
        fields: Prisma.SearchPatternResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SearchPatternResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchPatternResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SearchPatternResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchPatternResultPayload>
          }
          findFirst: {
            args: Prisma.SearchPatternResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchPatternResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SearchPatternResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchPatternResultPayload>
          }
          findMany: {
            args: Prisma.SearchPatternResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchPatternResultPayload>[]
          }
          create: {
            args: Prisma.SearchPatternResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchPatternResultPayload>
          }
          createMany: {
            args: Prisma.SearchPatternResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SearchPatternResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchPatternResultPayload>[]
          }
          delete: {
            args: Prisma.SearchPatternResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchPatternResultPayload>
          }
          update: {
            args: Prisma.SearchPatternResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchPatternResultPayload>
          }
          deleteMany: {
            args: Prisma.SearchPatternResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SearchPatternResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SearchPatternResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchPatternResultPayload>
          }
          aggregate: {
            args: Prisma.SearchPatternResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSearchPatternResult>
          }
          groupBy: {
            args: Prisma.SearchPatternResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<SearchPatternResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.SearchPatternResultCountArgs<ExtArgs>
            result: $Utils.Optional<SearchPatternResultCountAggregateOutputType> | number
          }
        }
      }
      IntentClassificationResult: {
        payload: Prisma.$IntentClassificationResultPayload<ExtArgs>
        fields: Prisma.IntentClassificationResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntentClassificationResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentClassificationResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntentClassificationResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentClassificationResultPayload>
          }
          findFirst: {
            args: Prisma.IntentClassificationResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentClassificationResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntentClassificationResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentClassificationResultPayload>
          }
          findMany: {
            args: Prisma.IntentClassificationResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentClassificationResultPayload>[]
          }
          create: {
            args: Prisma.IntentClassificationResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentClassificationResultPayload>
          }
          createMany: {
            args: Prisma.IntentClassificationResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntentClassificationResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentClassificationResultPayload>[]
          }
          delete: {
            args: Prisma.IntentClassificationResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentClassificationResultPayload>
          }
          update: {
            args: Prisma.IntentClassificationResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentClassificationResultPayload>
          }
          deleteMany: {
            args: Prisma.IntentClassificationResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntentClassificationResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IntentClassificationResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentClassificationResultPayload>
          }
          aggregate: {
            args: Prisma.IntentClassificationResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntentClassificationResult>
          }
          groupBy: {
            args: Prisma.IntentClassificationResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntentClassificationResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntentClassificationResultCountArgs<ExtArgs>
            result: $Utils.Optional<IntentClassificationResultCountAggregateOutputType> | number
          }
        }
      }
      GeneratedIntentPhrase: {
        payload: Prisma.$GeneratedIntentPhrasePayload<ExtArgs>
        fields: Prisma.GeneratedIntentPhraseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GeneratedIntentPhraseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedIntentPhrasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GeneratedIntentPhraseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedIntentPhrasePayload>
          }
          findFirst: {
            args: Prisma.GeneratedIntentPhraseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedIntentPhrasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GeneratedIntentPhraseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedIntentPhrasePayload>
          }
          findMany: {
            args: Prisma.GeneratedIntentPhraseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedIntentPhrasePayload>[]
          }
          create: {
            args: Prisma.GeneratedIntentPhraseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedIntentPhrasePayload>
          }
          createMany: {
            args: Prisma.GeneratedIntentPhraseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GeneratedIntentPhraseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedIntentPhrasePayload>[]
          }
          delete: {
            args: Prisma.GeneratedIntentPhraseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedIntentPhrasePayload>
          }
          update: {
            args: Prisma.GeneratedIntentPhraseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedIntentPhrasePayload>
          }
          deleteMany: {
            args: Prisma.GeneratedIntentPhraseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GeneratedIntentPhraseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GeneratedIntentPhraseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedIntentPhrasePayload>
          }
          aggregate: {
            args: Prisma.GeneratedIntentPhraseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGeneratedIntentPhrase>
          }
          groupBy: {
            args: Prisma.GeneratedIntentPhraseGroupByArgs<ExtArgs>
            result: $Utils.Optional<GeneratedIntentPhraseGroupByOutputType>[]
          }
          count: {
            args: Prisma.GeneratedIntentPhraseCountArgs<ExtArgs>
            result: $Utils.Optional<GeneratedIntentPhraseCountAggregateOutputType> | number
          }
        }
      }
      RelevanceScoreResult: {
        payload: Prisma.$RelevanceScoreResultPayload<ExtArgs>
        fields: Prisma.RelevanceScoreResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelevanceScoreResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelevanceScoreResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelevanceScoreResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelevanceScoreResultPayload>
          }
          findFirst: {
            args: Prisma.RelevanceScoreResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelevanceScoreResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelevanceScoreResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelevanceScoreResultPayload>
          }
          findMany: {
            args: Prisma.RelevanceScoreResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelevanceScoreResultPayload>[]
          }
          create: {
            args: Prisma.RelevanceScoreResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelevanceScoreResultPayload>
          }
          createMany: {
            args: Prisma.RelevanceScoreResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RelevanceScoreResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelevanceScoreResultPayload>[]
          }
          delete: {
            args: Prisma.RelevanceScoreResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelevanceScoreResultPayload>
          }
          update: {
            args: Prisma.RelevanceScoreResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelevanceScoreResultPayload>
          }
          deleteMany: {
            args: Prisma.RelevanceScoreResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RelevanceScoreResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RelevanceScoreResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelevanceScoreResultPayload>
          }
          aggregate: {
            args: Prisma.RelevanceScoreResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelevanceScoreResult>
          }
          groupBy: {
            args: Prisma.RelevanceScoreResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelevanceScoreResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelevanceScoreResultCountArgs<ExtArgs>
            result: $Utils.Optional<RelevanceScoreResultCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    domain?: DomainOmit
    crawlResult?: CrawlResultOmit
    keyword?: KeywordOmit
    phrase?: PhraseOmit
    aIQueryResult?: AIQueryResultOmit
    dashboardAnalysis?: DashboardAnalysisOmit
    competitorAnalysis?: CompetitorAnalysisOmit
    suggestedCompetitor?: SuggestedCompetitorOmit
    analysisPhase?: AnalysisPhaseOmit
    semanticAnalysis?: SemanticAnalysisOmit
    keywordAnalysis?: KeywordAnalysisOmit
    searchVolumeClassification?: SearchVolumeClassificationOmit
    intentClassification?: IntentClassificationOmit
    communityInsight?: CommunityInsightOmit
    searchPattern?: SearchPatternOmit
    phraseIntentClassification?: PhraseIntentClassificationOmit
    phraseScore?: PhraseScoreOmit
    intentPhraseGeneration?: IntentPhraseGenerationOmit
    communityMiningResult?: CommunityMiningResultOmit
    searchPatternResult?: SearchPatternResultOmit
    intentClassificationResult?: IntentClassificationResultOmit
    generatedIntentPhrase?: GeneratedIntentPhraseOmit
    relevanceScoreResult?: RelevanceScoreResultOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    domains: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domains?: boolean | UserCountOutputTypeCountDomainsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDomainsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainWhereInput
  }


  /**
   * Count Type DomainCountOutputType
   */

  export type DomainCountOutputType = {
    crawlResults: number
    keywords: number
    dashboardAnalyses: number
    competitorAnalyses: number
    suggestedCompetitors: number
    analysisPhases: number
    semanticAnalyses: number
    keywordAnalyses: number
    searchVolumeClassifications: number
    intentClassifications: number
    communityInsights: number
    searchPatterns: number
    intentPhraseGenerations: number
    communityMiningResults: number
    searchPatternResults: number
    intentClassificationResults: number
    generatedIntentPhrases: number
    relevanceScoreResults: number
  }

  export type DomainCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crawlResults?: boolean | DomainCountOutputTypeCountCrawlResultsArgs
    keywords?: boolean | DomainCountOutputTypeCountKeywordsArgs
    dashboardAnalyses?: boolean | DomainCountOutputTypeCountDashboardAnalysesArgs
    competitorAnalyses?: boolean | DomainCountOutputTypeCountCompetitorAnalysesArgs
    suggestedCompetitors?: boolean | DomainCountOutputTypeCountSuggestedCompetitorsArgs
    analysisPhases?: boolean | DomainCountOutputTypeCountAnalysisPhasesArgs
    semanticAnalyses?: boolean | DomainCountOutputTypeCountSemanticAnalysesArgs
    keywordAnalyses?: boolean | DomainCountOutputTypeCountKeywordAnalysesArgs
    searchVolumeClassifications?: boolean | DomainCountOutputTypeCountSearchVolumeClassificationsArgs
    intentClassifications?: boolean | DomainCountOutputTypeCountIntentClassificationsArgs
    communityInsights?: boolean | DomainCountOutputTypeCountCommunityInsightsArgs
    searchPatterns?: boolean | DomainCountOutputTypeCountSearchPatternsArgs
    intentPhraseGenerations?: boolean | DomainCountOutputTypeCountIntentPhraseGenerationsArgs
    communityMiningResults?: boolean | DomainCountOutputTypeCountCommunityMiningResultsArgs
    searchPatternResults?: boolean | DomainCountOutputTypeCountSearchPatternResultsArgs
    intentClassificationResults?: boolean | DomainCountOutputTypeCountIntentClassificationResultsArgs
    generatedIntentPhrases?: boolean | DomainCountOutputTypeCountGeneratedIntentPhrasesArgs
    relevanceScoreResults?: boolean | DomainCountOutputTypeCountRelevanceScoreResultsArgs
  }

  // Custom InputTypes
  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainCountOutputType
     */
    select?: DomainCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeCountCrawlResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrawlResultWhereInput
  }

  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeCountKeywordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeywordWhereInput
  }

  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeCountDashboardAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DashboardAnalysisWhereInput
  }

  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeCountCompetitorAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompetitorAnalysisWhereInput
  }

  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeCountSuggestedCompetitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuggestedCompetitorWhereInput
  }

  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeCountAnalysisPhasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalysisPhaseWhereInput
  }

  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeCountSemanticAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SemanticAnalysisWhereInput
  }

  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeCountKeywordAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeywordAnalysisWhereInput
  }

  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeCountSearchVolumeClassificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchVolumeClassificationWhereInput
  }

  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeCountIntentClassificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntentClassificationWhereInput
  }

  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeCountCommunityInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityInsightWhereInput
  }

  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeCountSearchPatternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchPatternWhereInput
  }

  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeCountIntentPhraseGenerationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntentPhraseGenerationWhereInput
  }

  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeCountCommunityMiningResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityMiningResultWhereInput
  }

  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeCountSearchPatternResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchPatternResultWhereInput
  }

  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeCountIntentClassificationResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntentClassificationResultWhereInput
  }

  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeCountGeneratedIntentPhrasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedIntentPhraseWhereInput
  }

  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeCountRelevanceScoreResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelevanceScoreResultWhereInput
  }


  /**
   * Count Type KeywordCountOutputType
   */

  export type KeywordCountOutputType = {
    phrases: number
    communityInsights: number
    searchPatterns: number
    communityMiningResults: number
    searchPatternResults: number
    intentClassificationResults: number
    generatedIntentPhrases: number
  }

  export type KeywordCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phrases?: boolean | KeywordCountOutputTypeCountPhrasesArgs
    communityInsights?: boolean | KeywordCountOutputTypeCountCommunityInsightsArgs
    searchPatterns?: boolean | KeywordCountOutputTypeCountSearchPatternsArgs
    communityMiningResults?: boolean | KeywordCountOutputTypeCountCommunityMiningResultsArgs
    searchPatternResults?: boolean | KeywordCountOutputTypeCountSearchPatternResultsArgs
    intentClassificationResults?: boolean | KeywordCountOutputTypeCountIntentClassificationResultsArgs
    generatedIntentPhrases?: boolean | KeywordCountOutputTypeCountGeneratedIntentPhrasesArgs
  }

  // Custom InputTypes
  /**
   * KeywordCountOutputType without action
   */
  export type KeywordCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordCountOutputType
     */
    select?: KeywordCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KeywordCountOutputType without action
   */
  export type KeywordCountOutputTypeCountPhrasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhraseWhereInput
  }

  /**
   * KeywordCountOutputType without action
   */
  export type KeywordCountOutputTypeCountCommunityInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityInsightWhereInput
  }

  /**
   * KeywordCountOutputType without action
   */
  export type KeywordCountOutputTypeCountSearchPatternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchPatternWhereInput
  }

  /**
   * KeywordCountOutputType without action
   */
  export type KeywordCountOutputTypeCountCommunityMiningResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityMiningResultWhereInput
  }

  /**
   * KeywordCountOutputType without action
   */
  export type KeywordCountOutputTypeCountSearchPatternResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchPatternResultWhereInput
  }

  /**
   * KeywordCountOutputType without action
   */
  export type KeywordCountOutputTypeCountIntentClassificationResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntentClassificationResultWhereInput
  }

  /**
   * KeywordCountOutputType without action
   */
  export type KeywordCountOutputTypeCountGeneratedIntentPhrasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedIntentPhraseWhereInput
  }


  /**
   * Count Type PhraseCountOutputType
   */

  export type PhraseCountOutputType = {
    phraseIntentClassifications: number
    phraseScores: number
  }

  export type PhraseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phraseIntentClassifications?: boolean | PhraseCountOutputTypeCountPhraseIntentClassificationsArgs
    phraseScores?: boolean | PhraseCountOutputTypeCountPhraseScoresArgs
  }

  // Custom InputTypes
  /**
   * PhraseCountOutputType without action
   */
  export type PhraseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseCountOutputType
     */
    select?: PhraseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PhraseCountOutputType without action
   */
  export type PhraseCountOutputTypeCountPhraseIntentClassificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhraseIntentClassificationWhereInput
  }

  /**
   * PhraseCountOutputType without action
   */
  export type PhraseCountOutputTypeCountPhraseScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhraseScoreWhereInput
  }


  /**
   * Count Type GeneratedIntentPhraseCountOutputType
   */

  export type GeneratedIntentPhraseCountOutputType = {
    relevanceScoreResults: number
    aiQueryResults: number
  }

  export type GeneratedIntentPhraseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relevanceScoreResults?: boolean | GeneratedIntentPhraseCountOutputTypeCountRelevanceScoreResultsArgs
    aiQueryResults?: boolean | GeneratedIntentPhraseCountOutputTypeCountAiQueryResultsArgs
  }

  // Custom InputTypes
  /**
   * GeneratedIntentPhraseCountOutputType without action
   */
  export type GeneratedIntentPhraseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedIntentPhraseCountOutputType
     */
    select?: GeneratedIntentPhraseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GeneratedIntentPhraseCountOutputType without action
   */
  export type GeneratedIntentPhraseCountOutputTypeCountRelevanceScoreResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelevanceScoreResultWhereInput
  }

  /**
   * GeneratedIntentPhraseCountOutputType without action
   */
  export type GeneratedIntentPhraseCountOutputTypeCountAiQueryResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIQueryResultWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    name: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domains?: boolean | User$domainsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domains?: boolean | User$domainsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      domains: Prisma.$DomainPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      name: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domains<T extends User$domainsArgs<ExtArgs> = {}>(args?: Subset<T, User$domainsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.domains
   */
  export type User$domainsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    where?: DomainWhereInput
    orderBy?: DomainOrderByWithRelationInput | DomainOrderByWithRelationInput[]
    cursor?: DomainWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DomainScalarFieldEnum | DomainScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Domain
   */

  export type AggregateDomain = {
    _count: DomainCountAggregateOutputType | null
    _avg: DomainAvgAggregateOutputType | null
    _sum: DomainSumAggregateOutputType | null
    _min: DomainMinAggregateOutputType | null
    _max: DomainMaxAggregateOutputType | null
  }

  export type DomainAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type DomainSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type DomainMinAggregateOutputType = {
    id: number | null
    url: string | null
    context: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    location: string | null
    customKeywords: string | null
    intentPhrases: string | null
    chatModel: string | null
    runAllModels: boolean | null
    locationContext: string | null
  }

  export type DomainMaxAggregateOutputType = {
    id: number | null
    url: string | null
    context: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    location: string | null
    customKeywords: string | null
    intentPhrases: string | null
    chatModel: string | null
    runAllModels: boolean | null
    locationContext: string | null
  }

  export type DomainCountAggregateOutputType = {
    id: number
    url: number
    context: number
    userId: number
    createdAt: number
    updatedAt: number
    location: number
    customKeywords: number
    intentPhrases: number
    chatModel: number
    runAllModels: number
    locationContext: number
    _all: number
  }


  export type DomainAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type DomainSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type DomainMinAggregateInputType = {
    id?: true
    url?: true
    context?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    location?: true
    customKeywords?: true
    intentPhrases?: true
    chatModel?: true
    runAllModels?: true
    locationContext?: true
  }

  export type DomainMaxAggregateInputType = {
    id?: true
    url?: true
    context?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    location?: true
    customKeywords?: true
    intentPhrases?: true
    chatModel?: true
    runAllModels?: true
    locationContext?: true
  }

  export type DomainCountAggregateInputType = {
    id?: true
    url?: true
    context?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    location?: true
    customKeywords?: true
    intentPhrases?: true
    chatModel?: true
    runAllModels?: true
    locationContext?: true
    _all?: true
  }

  export type DomainAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Domain to aggregate.
     */
    where?: DomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domains to fetch.
     */
    orderBy?: DomainOrderByWithRelationInput | DomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Domains
    **/
    _count?: true | DomainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DomainAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DomainSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomainMaxAggregateInputType
  }

  export type GetDomainAggregateType<T extends DomainAggregateArgs> = {
        [P in keyof T & keyof AggregateDomain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomain[P]>
      : GetScalarType<T[P], AggregateDomain[P]>
  }




  export type DomainGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainWhereInput
    orderBy?: DomainOrderByWithAggregationInput | DomainOrderByWithAggregationInput[]
    by: DomainScalarFieldEnum[] | DomainScalarFieldEnum
    having?: DomainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomainCountAggregateInputType | true
    _avg?: DomainAvgAggregateInputType
    _sum?: DomainSumAggregateInputType
    _min?: DomainMinAggregateInputType
    _max?: DomainMaxAggregateInputType
  }

  export type DomainGroupByOutputType = {
    id: number
    url: string
    context: string | null
    userId: number | null
    createdAt: Date
    updatedAt: Date
    location: string | null
    customKeywords: string | null
    intentPhrases: string | null
    chatModel: string | null
    runAllModels: boolean
    locationContext: string | null
    _count: DomainCountAggregateOutputType | null
    _avg: DomainAvgAggregateOutputType | null
    _sum: DomainSumAggregateOutputType | null
    _min: DomainMinAggregateOutputType | null
    _max: DomainMaxAggregateOutputType | null
  }

  type GetDomainGroupByPayload<T extends DomainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DomainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomainGroupByOutputType[P]>
            : GetScalarType<T[P], DomainGroupByOutputType[P]>
        }
      >
    >


  export type DomainSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    context?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean
    customKeywords?: boolean
    intentPhrases?: boolean
    chatModel?: boolean
    runAllModels?: boolean
    locationContext?: boolean
    user?: boolean | Domain$userArgs<ExtArgs>
    crawlResults?: boolean | Domain$crawlResultsArgs<ExtArgs>
    keywords?: boolean | Domain$keywordsArgs<ExtArgs>
    dashboardAnalyses?: boolean | Domain$dashboardAnalysesArgs<ExtArgs>
    competitorAnalyses?: boolean | Domain$competitorAnalysesArgs<ExtArgs>
    suggestedCompetitors?: boolean | Domain$suggestedCompetitorsArgs<ExtArgs>
    analysisPhases?: boolean | Domain$analysisPhasesArgs<ExtArgs>
    semanticAnalyses?: boolean | Domain$semanticAnalysesArgs<ExtArgs>
    keywordAnalyses?: boolean | Domain$keywordAnalysesArgs<ExtArgs>
    searchVolumeClassifications?: boolean | Domain$searchVolumeClassificationsArgs<ExtArgs>
    intentClassifications?: boolean | Domain$intentClassificationsArgs<ExtArgs>
    communityInsights?: boolean | Domain$communityInsightsArgs<ExtArgs>
    searchPatterns?: boolean | Domain$searchPatternsArgs<ExtArgs>
    intentPhraseGenerations?: boolean | Domain$intentPhraseGenerationsArgs<ExtArgs>
    communityMiningResults?: boolean | Domain$communityMiningResultsArgs<ExtArgs>
    searchPatternResults?: boolean | Domain$searchPatternResultsArgs<ExtArgs>
    intentClassificationResults?: boolean | Domain$intentClassificationResultsArgs<ExtArgs>
    generatedIntentPhrases?: boolean | Domain$generatedIntentPhrasesArgs<ExtArgs>
    relevanceScoreResults?: boolean | Domain$relevanceScoreResultsArgs<ExtArgs>
    _count?: boolean | DomainCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domain"]>

  export type DomainSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    context?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean
    customKeywords?: boolean
    intentPhrases?: boolean
    chatModel?: boolean
    runAllModels?: boolean
    locationContext?: boolean
    user?: boolean | Domain$userArgs<ExtArgs>
  }, ExtArgs["result"]["domain"]>


  export type DomainSelectScalar = {
    id?: boolean
    url?: boolean
    context?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean
    customKeywords?: boolean
    intentPhrases?: boolean
    chatModel?: boolean
    runAllModels?: boolean
    locationContext?: boolean
  }

  export type DomainOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "context" | "userId" | "createdAt" | "updatedAt" | "location" | "customKeywords" | "intentPhrases" | "chatModel" | "runAllModels" | "locationContext", ExtArgs["result"]["domain"]>
  export type DomainInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Domain$userArgs<ExtArgs>
    crawlResults?: boolean | Domain$crawlResultsArgs<ExtArgs>
    keywords?: boolean | Domain$keywordsArgs<ExtArgs>
    dashboardAnalyses?: boolean | Domain$dashboardAnalysesArgs<ExtArgs>
    competitorAnalyses?: boolean | Domain$competitorAnalysesArgs<ExtArgs>
    suggestedCompetitors?: boolean | Domain$suggestedCompetitorsArgs<ExtArgs>
    analysisPhases?: boolean | Domain$analysisPhasesArgs<ExtArgs>
    semanticAnalyses?: boolean | Domain$semanticAnalysesArgs<ExtArgs>
    keywordAnalyses?: boolean | Domain$keywordAnalysesArgs<ExtArgs>
    searchVolumeClassifications?: boolean | Domain$searchVolumeClassificationsArgs<ExtArgs>
    intentClassifications?: boolean | Domain$intentClassificationsArgs<ExtArgs>
    communityInsights?: boolean | Domain$communityInsightsArgs<ExtArgs>
    searchPatterns?: boolean | Domain$searchPatternsArgs<ExtArgs>
    intentPhraseGenerations?: boolean | Domain$intentPhraseGenerationsArgs<ExtArgs>
    communityMiningResults?: boolean | Domain$communityMiningResultsArgs<ExtArgs>
    searchPatternResults?: boolean | Domain$searchPatternResultsArgs<ExtArgs>
    intentClassificationResults?: boolean | Domain$intentClassificationResultsArgs<ExtArgs>
    generatedIntentPhrases?: boolean | Domain$generatedIntentPhrasesArgs<ExtArgs>
    relevanceScoreResults?: boolean | Domain$relevanceScoreResultsArgs<ExtArgs>
    _count?: boolean | DomainCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DomainIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Domain$userArgs<ExtArgs>
  }

  export type $DomainPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Domain"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      crawlResults: Prisma.$CrawlResultPayload<ExtArgs>[]
      keywords: Prisma.$KeywordPayload<ExtArgs>[]
      dashboardAnalyses: Prisma.$DashboardAnalysisPayload<ExtArgs>[]
      competitorAnalyses: Prisma.$CompetitorAnalysisPayload<ExtArgs>[]
      suggestedCompetitors: Prisma.$SuggestedCompetitorPayload<ExtArgs>[]
      analysisPhases: Prisma.$AnalysisPhasePayload<ExtArgs>[]
      semanticAnalyses: Prisma.$SemanticAnalysisPayload<ExtArgs>[]
      keywordAnalyses: Prisma.$KeywordAnalysisPayload<ExtArgs>[]
      searchVolumeClassifications: Prisma.$SearchVolumeClassificationPayload<ExtArgs>[]
      intentClassifications: Prisma.$IntentClassificationPayload<ExtArgs>[]
      communityInsights: Prisma.$CommunityInsightPayload<ExtArgs>[]
      searchPatterns: Prisma.$SearchPatternPayload<ExtArgs>[]
      intentPhraseGenerations: Prisma.$IntentPhraseGenerationPayload<ExtArgs>[]
      communityMiningResults: Prisma.$CommunityMiningResultPayload<ExtArgs>[]
      searchPatternResults: Prisma.$SearchPatternResultPayload<ExtArgs>[]
      intentClassificationResults: Prisma.$IntentClassificationResultPayload<ExtArgs>[]
      generatedIntentPhrases: Prisma.$GeneratedIntentPhrasePayload<ExtArgs>[]
      relevanceScoreResults: Prisma.$RelevanceScoreResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      url: string
      context: string | null
      userId: number | null
      createdAt: Date
      updatedAt: Date
      location: string | null
      customKeywords: string | null
      intentPhrases: string | null
      chatModel: string | null
      runAllModels: boolean
      locationContext: string | null
    }, ExtArgs["result"]["domain"]>
    composites: {}
  }

  type DomainGetPayload<S extends boolean | null | undefined | DomainDefaultArgs> = $Result.GetResult<Prisma.$DomainPayload, S>

  type DomainCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DomainFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DomainCountAggregateInputType | true
    }

  export interface DomainDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Domain'], meta: { name: 'Domain' } }
    /**
     * Find zero or one Domain that matches the filter.
     * @param {DomainFindUniqueArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DomainFindUniqueArgs>(args: SelectSubset<T, DomainFindUniqueArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Domain that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DomainFindUniqueOrThrowArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DomainFindUniqueOrThrowArgs>(args: SelectSubset<T, DomainFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Domain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainFindFirstArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DomainFindFirstArgs>(args?: SelectSubset<T, DomainFindFirstArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Domain that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainFindFirstOrThrowArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DomainFindFirstOrThrowArgs>(args?: SelectSubset<T, DomainFindFirstOrThrowArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Domains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Domains
     * const domains = await prisma.domain.findMany()
     * 
     * // Get first 10 Domains
     * const domains = await prisma.domain.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const domainWithIdOnly = await prisma.domain.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DomainFindManyArgs>(args?: SelectSubset<T, DomainFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Domain.
     * @param {DomainCreateArgs} args - Arguments to create a Domain.
     * @example
     * // Create one Domain
     * const Domain = await prisma.domain.create({
     *   data: {
     *     // ... data to create a Domain
     *   }
     * })
     * 
     */
    create<T extends DomainCreateArgs>(args: SelectSubset<T, DomainCreateArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Domains.
     * @param {DomainCreateManyArgs} args - Arguments to create many Domains.
     * @example
     * // Create many Domains
     * const domain = await prisma.domain.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DomainCreateManyArgs>(args?: SelectSubset<T, DomainCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Domains and returns the data saved in the database.
     * @param {DomainCreateManyAndReturnArgs} args - Arguments to create many Domains.
     * @example
     * // Create many Domains
     * const domain = await prisma.domain.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Domains and only return the `id`
     * const domainWithIdOnly = await prisma.domain.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DomainCreateManyAndReturnArgs>(args?: SelectSubset<T, DomainCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Domain.
     * @param {DomainDeleteArgs} args - Arguments to delete one Domain.
     * @example
     * // Delete one Domain
     * const Domain = await prisma.domain.delete({
     *   where: {
     *     // ... filter to delete one Domain
     *   }
     * })
     * 
     */
    delete<T extends DomainDeleteArgs>(args: SelectSubset<T, DomainDeleteArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Domain.
     * @param {DomainUpdateArgs} args - Arguments to update one Domain.
     * @example
     * // Update one Domain
     * const domain = await prisma.domain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DomainUpdateArgs>(args: SelectSubset<T, DomainUpdateArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Domains.
     * @param {DomainDeleteManyArgs} args - Arguments to filter Domains to delete.
     * @example
     * // Delete a few Domains
     * const { count } = await prisma.domain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DomainDeleteManyArgs>(args?: SelectSubset<T, DomainDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Domains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Domains
     * const domain = await prisma.domain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DomainUpdateManyArgs>(args: SelectSubset<T, DomainUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Domain.
     * @param {DomainUpsertArgs} args - Arguments to update or create a Domain.
     * @example
     * // Update or create a Domain
     * const domain = await prisma.domain.upsert({
     *   create: {
     *     // ... data to create a Domain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Domain we want to update
     *   }
     * })
     */
    upsert<T extends DomainUpsertArgs>(args: SelectSubset<T, DomainUpsertArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Domains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainCountArgs} args - Arguments to filter Domains to count.
     * @example
     * // Count the number of Domains
     * const count = await prisma.domain.count({
     *   where: {
     *     // ... the filter for the Domains we want to count
     *   }
     * })
    **/
    count<T extends DomainCountArgs>(
      args?: Subset<T, DomainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Domain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomainAggregateArgs>(args: Subset<T, DomainAggregateArgs>): Prisma.PrismaPromise<GetDomainAggregateType<T>>

    /**
     * Group by Domain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DomainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DomainGroupByArgs['orderBy'] }
        : { orderBy?: DomainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DomainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Domain model
   */
  readonly fields: DomainFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Domain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DomainClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Domain$userArgs<ExtArgs> = {}>(args?: Subset<T, Domain$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    crawlResults<T extends Domain$crawlResultsArgs<ExtArgs> = {}>(args?: Subset<T, Domain$crawlResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrawlResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    keywords<T extends Domain$keywordsArgs<ExtArgs> = {}>(args?: Subset<T, Domain$keywordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dashboardAnalyses<T extends Domain$dashboardAnalysesArgs<ExtArgs> = {}>(args?: Subset<T, Domain$dashboardAnalysesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    competitorAnalyses<T extends Domain$competitorAnalysesArgs<ExtArgs> = {}>(args?: Subset<T, Domain$competitorAnalysesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompetitorAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    suggestedCompetitors<T extends Domain$suggestedCompetitorsArgs<ExtArgs> = {}>(args?: Subset<T, Domain$suggestedCompetitorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuggestedCompetitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    analysisPhases<T extends Domain$analysisPhasesArgs<ExtArgs> = {}>(args?: Subset<T, Domain$analysisPhasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisPhasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    semanticAnalyses<T extends Domain$semanticAnalysesArgs<ExtArgs> = {}>(args?: Subset<T, Domain$semanticAnalysesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SemanticAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    keywordAnalyses<T extends Domain$keywordAnalysesArgs<ExtArgs> = {}>(args?: Subset<T, Domain$keywordAnalysesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeywordAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    searchVolumeClassifications<T extends Domain$searchVolumeClassificationsArgs<ExtArgs> = {}>(args?: Subset<T, Domain$searchVolumeClassificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchVolumeClassificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    intentClassifications<T extends Domain$intentClassificationsArgs<ExtArgs> = {}>(args?: Subset<T, Domain$intentClassificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntentClassificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    communityInsights<T extends Domain$communityInsightsArgs<ExtArgs> = {}>(args?: Subset<T, Domain$communityInsightsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityInsightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    searchPatterns<T extends Domain$searchPatternsArgs<ExtArgs> = {}>(args?: Subset<T, Domain$searchPatternsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchPatternPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    intentPhraseGenerations<T extends Domain$intentPhraseGenerationsArgs<ExtArgs> = {}>(args?: Subset<T, Domain$intentPhraseGenerationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntentPhraseGenerationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    communityMiningResults<T extends Domain$communityMiningResultsArgs<ExtArgs> = {}>(args?: Subset<T, Domain$communityMiningResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityMiningResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    searchPatternResults<T extends Domain$searchPatternResultsArgs<ExtArgs> = {}>(args?: Subset<T, Domain$searchPatternResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchPatternResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    intentClassificationResults<T extends Domain$intentClassificationResultsArgs<ExtArgs> = {}>(args?: Subset<T, Domain$intentClassificationResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntentClassificationResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generatedIntentPhrases<T extends Domain$generatedIntentPhrasesArgs<ExtArgs> = {}>(args?: Subset<T, Domain$generatedIntentPhrasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedIntentPhrasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    relevanceScoreResults<T extends Domain$relevanceScoreResultsArgs<ExtArgs> = {}>(args?: Subset<T, Domain$relevanceScoreResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelevanceScoreResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Domain model
   */
  interface DomainFieldRefs {
    readonly id: FieldRef<"Domain", 'Int'>
    readonly url: FieldRef<"Domain", 'String'>
    readonly context: FieldRef<"Domain", 'String'>
    readonly userId: FieldRef<"Domain", 'Int'>
    readonly createdAt: FieldRef<"Domain", 'DateTime'>
    readonly updatedAt: FieldRef<"Domain", 'DateTime'>
    readonly location: FieldRef<"Domain", 'String'>
    readonly customKeywords: FieldRef<"Domain", 'String'>
    readonly intentPhrases: FieldRef<"Domain", 'String'>
    readonly chatModel: FieldRef<"Domain", 'String'>
    readonly runAllModels: FieldRef<"Domain", 'Boolean'>
    readonly locationContext: FieldRef<"Domain", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Domain findUnique
   */
  export type DomainFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * Filter, which Domain to fetch.
     */
    where: DomainWhereUniqueInput
  }

  /**
   * Domain findUniqueOrThrow
   */
  export type DomainFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * Filter, which Domain to fetch.
     */
    where: DomainWhereUniqueInput
  }

  /**
   * Domain findFirst
   */
  export type DomainFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * Filter, which Domain to fetch.
     */
    where?: DomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domains to fetch.
     */
    orderBy?: DomainOrderByWithRelationInput | DomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Domains.
     */
    cursor?: DomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Domains.
     */
    distinct?: DomainScalarFieldEnum | DomainScalarFieldEnum[]
  }

  /**
   * Domain findFirstOrThrow
   */
  export type DomainFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * Filter, which Domain to fetch.
     */
    where?: DomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domains to fetch.
     */
    orderBy?: DomainOrderByWithRelationInput | DomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Domains.
     */
    cursor?: DomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Domains.
     */
    distinct?: DomainScalarFieldEnum | DomainScalarFieldEnum[]
  }

  /**
   * Domain findMany
   */
  export type DomainFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * Filter, which Domains to fetch.
     */
    where?: DomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domains to fetch.
     */
    orderBy?: DomainOrderByWithRelationInput | DomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Domains.
     */
    cursor?: DomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domains.
     */
    skip?: number
    distinct?: DomainScalarFieldEnum | DomainScalarFieldEnum[]
  }

  /**
   * Domain create
   */
  export type DomainCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * The data needed to create a Domain.
     */
    data: XOR<DomainCreateInput, DomainUncheckedCreateInput>
  }

  /**
   * Domain createMany
   */
  export type DomainCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Domains.
     */
    data: DomainCreateManyInput | DomainCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Domain createManyAndReturn
   */
  export type DomainCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * The data used to create many Domains.
     */
    data: DomainCreateManyInput | DomainCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Domain update
   */
  export type DomainUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * The data needed to update a Domain.
     */
    data: XOR<DomainUpdateInput, DomainUncheckedUpdateInput>
    /**
     * Choose, which Domain to update.
     */
    where: DomainWhereUniqueInput
  }

  /**
   * Domain updateMany
   */
  export type DomainUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Domains.
     */
    data: XOR<DomainUpdateManyMutationInput, DomainUncheckedUpdateManyInput>
    /**
     * Filter which Domains to update
     */
    where?: DomainWhereInput
  }

  /**
   * Domain upsert
   */
  export type DomainUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * The filter to search for the Domain to update in case it exists.
     */
    where: DomainWhereUniqueInput
    /**
     * In case the Domain found by the `where` argument doesn't exist, create a new Domain with this data.
     */
    create: XOR<DomainCreateInput, DomainUncheckedCreateInput>
    /**
     * In case the Domain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DomainUpdateInput, DomainUncheckedUpdateInput>
  }

  /**
   * Domain delete
   */
  export type DomainDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * Filter which Domain to delete.
     */
    where: DomainWhereUniqueInput
  }

  /**
   * Domain deleteMany
   */
  export type DomainDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Domains to delete
     */
    where?: DomainWhereInput
  }

  /**
   * Domain.user
   */
  export type Domain$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Domain.crawlResults
   */
  export type Domain$crawlResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrawlResult
     */
    select?: CrawlResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrawlResult
     */
    omit?: CrawlResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrawlResultInclude<ExtArgs> | null
    where?: CrawlResultWhereInput
    orderBy?: CrawlResultOrderByWithRelationInput | CrawlResultOrderByWithRelationInput[]
    cursor?: CrawlResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrawlResultScalarFieldEnum | CrawlResultScalarFieldEnum[]
  }

  /**
   * Domain.keywords
   */
  export type Domain$keywordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    where?: KeywordWhereInput
    orderBy?: KeywordOrderByWithRelationInput | KeywordOrderByWithRelationInput[]
    cursor?: KeywordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KeywordScalarFieldEnum | KeywordScalarFieldEnum[]
  }

  /**
   * Domain.dashboardAnalyses
   */
  export type Domain$dashboardAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardAnalysis
     */
    select?: DashboardAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardAnalysis
     */
    omit?: DashboardAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardAnalysisInclude<ExtArgs> | null
    where?: DashboardAnalysisWhereInput
    orderBy?: DashboardAnalysisOrderByWithRelationInput | DashboardAnalysisOrderByWithRelationInput[]
    cursor?: DashboardAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DashboardAnalysisScalarFieldEnum | DashboardAnalysisScalarFieldEnum[]
  }

  /**
   * Domain.competitorAnalyses
   */
  export type Domain$competitorAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorAnalysis
     */
    select?: CompetitorAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompetitorAnalysis
     */
    omit?: CompetitorAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitorAnalysisInclude<ExtArgs> | null
    where?: CompetitorAnalysisWhereInput
    orderBy?: CompetitorAnalysisOrderByWithRelationInput | CompetitorAnalysisOrderByWithRelationInput[]
    cursor?: CompetitorAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompetitorAnalysisScalarFieldEnum | CompetitorAnalysisScalarFieldEnum[]
  }

  /**
   * Domain.suggestedCompetitors
   */
  export type Domain$suggestedCompetitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestedCompetitor
     */
    select?: SuggestedCompetitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestedCompetitor
     */
    omit?: SuggestedCompetitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestedCompetitorInclude<ExtArgs> | null
    where?: SuggestedCompetitorWhereInput
    orderBy?: SuggestedCompetitorOrderByWithRelationInput | SuggestedCompetitorOrderByWithRelationInput[]
    cursor?: SuggestedCompetitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SuggestedCompetitorScalarFieldEnum | SuggestedCompetitorScalarFieldEnum[]
  }

  /**
   * Domain.analysisPhases
   */
  export type Domain$analysisPhasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisPhase
     */
    select?: AnalysisPhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisPhase
     */
    omit?: AnalysisPhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisPhaseInclude<ExtArgs> | null
    where?: AnalysisPhaseWhereInput
    orderBy?: AnalysisPhaseOrderByWithRelationInput | AnalysisPhaseOrderByWithRelationInput[]
    cursor?: AnalysisPhaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalysisPhaseScalarFieldEnum | AnalysisPhaseScalarFieldEnum[]
  }

  /**
   * Domain.semanticAnalyses
   */
  export type Domain$semanticAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticAnalysis
     */
    select?: SemanticAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemanticAnalysis
     */
    omit?: SemanticAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemanticAnalysisInclude<ExtArgs> | null
    where?: SemanticAnalysisWhereInput
    orderBy?: SemanticAnalysisOrderByWithRelationInput | SemanticAnalysisOrderByWithRelationInput[]
    cursor?: SemanticAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SemanticAnalysisScalarFieldEnum | SemanticAnalysisScalarFieldEnum[]
  }

  /**
   * Domain.keywordAnalyses
   */
  export type Domain$keywordAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordAnalysis
     */
    select?: KeywordAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordAnalysis
     */
    omit?: KeywordAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordAnalysisInclude<ExtArgs> | null
    where?: KeywordAnalysisWhereInput
    orderBy?: KeywordAnalysisOrderByWithRelationInput | KeywordAnalysisOrderByWithRelationInput[]
    cursor?: KeywordAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KeywordAnalysisScalarFieldEnum | KeywordAnalysisScalarFieldEnum[]
  }

  /**
   * Domain.searchVolumeClassifications
   */
  export type Domain$searchVolumeClassificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchVolumeClassification
     */
    select?: SearchVolumeClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchVolumeClassification
     */
    omit?: SearchVolumeClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchVolumeClassificationInclude<ExtArgs> | null
    where?: SearchVolumeClassificationWhereInput
    orderBy?: SearchVolumeClassificationOrderByWithRelationInput | SearchVolumeClassificationOrderByWithRelationInput[]
    cursor?: SearchVolumeClassificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SearchVolumeClassificationScalarFieldEnum | SearchVolumeClassificationScalarFieldEnum[]
  }

  /**
   * Domain.intentClassifications
   */
  export type Domain$intentClassificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentClassification
     */
    select?: IntentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentClassification
     */
    omit?: IntentClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentClassificationInclude<ExtArgs> | null
    where?: IntentClassificationWhereInput
    orderBy?: IntentClassificationOrderByWithRelationInput | IntentClassificationOrderByWithRelationInput[]
    cursor?: IntentClassificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntentClassificationScalarFieldEnum | IntentClassificationScalarFieldEnum[]
  }

  /**
   * Domain.communityInsights
   */
  export type Domain$communityInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityInsight
     */
    select?: CommunityInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityInsight
     */
    omit?: CommunityInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInsightInclude<ExtArgs> | null
    where?: CommunityInsightWhereInput
    orderBy?: CommunityInsightOrderByWithRelationInput | CommunityInsightOrderByWithRelationInput[]
    cursor?: CommunityInsightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityInsightScalarFieldEnum | CommunityInsightScalarFieldEnum[]
  }

  /**
   * Domain.searchPatterns
   */
  export type Domain$searchPatternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPattern
     */
    select?: SearchPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPattern
     */
    omit?: SearchPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternInclude<ExtArgs> | null
    where?: SearchPatternWhereInput
    orderBy?: SearchPatternOrderByWithRelationInput | SearchPatternOrderByWithRelationInput[]
    cursor?: SearchPatternWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SearchPatternScalarFieldEnum | SearchPatternScalarFieldEnum[]
  }

  /**
   * Domain.intentPhraseGenerations
   */
  export type Domain$intentPhraseGenerationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentPhraseGeneration
     */
    select?: IntentPhraseGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentPhraseGeneration
     */
    omit?: IntentPhraseGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentPhraseGenerationInclude<ExtArgs> | null
    where?: IntentPhraseGenerationWhereInput
    orderBy?: IntentPhraseGenerationOrderByWithRelationInput | IntentPhraseGenerationOrderByWithRelationInput[]
    cursor?: IntentPhraseGenerationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntentPhraseGenerationScalarFieldEnum | IntentPhraseGenerationScalarFieldEnum[]
  }

  /**
   * Domain.communityMiningResults
   */
  export type Domain$communityMiningResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMiningResult
     */
    select?: CommunityMiningResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMiningResult
     */
    omit?: CommunityMiningResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMiningResultInclude<ExtArgs> | null
    where?: CommunityMiningResultWhereInput
    orderBy?: CommunityMiningResultOrderByWithRelationInput | CommunityMiningResultOrderByWithRelationInput[]
    cursor?: CommunityMiningResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityMiningResultScalarFieldEnum | CommunityMiningResultScalarFieldEnum[]
  }

  /**
   * Domain.searchPatternResults
   */
  export type Domain$searchPatternResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPatternResult
     */
    select?: SearchPatternResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPatternResult
     */
    omit?: SearchPatternResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternResultInclude<ExtArgs> | null
    where?: SearchPatternResultWhereInput
    orderBy?: SearchPatternResultOrderByWithRelationInput | SearchPatternResultOrderByWithRelationInput[]
    cursor?: SearchPatternResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SearchPatternResultScalarFieldEnum | SearchPatternResultScalarFieldEnum[]
  }

  /**
   * Domain.intentClassificationResults
   */
  export type Domain$intentClassificationResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentClassificationResult
     */
    select?: IntentClassificationResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentClassificationResult
     */
    omit?: IntentClassificationResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentClassificationResultInclude<ExtArgs> | null
    where?: IntentClassificationResultWhereInput
    orderBy?: IntentClassificationResultOrderByWithRelationInput | IntentClassificationResultOrderByWithRelationInput[]
    cursor?: IntentClassificationResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntentClassificationResultScalarFieldEnum | IntentClassificationResultScalarFieldEnum[]
  }

  /**
   * Domain.generatedIntentPhrases
   */
  export type Domain$generatedIntentPhrasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedIntentPhrase
     */
    select?: GeneratedIntentPhraseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedIntentPhrase
     */
    omit?: GeneratedIntentPhraseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedIntentPhraseInclude<ExtArgs> | null
    where?: GeneratedIntentPhraseWhereInput
    orderBy?: GeneratedIntentPhraseOrderByWithRelationInput | GeneratedIntentPhraseOrderByWithRelationInput[]
    cursor?: GeneratedIntentPhraseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeneratedIntentPhraseScalarFieldEnum | GeneratedIntentPhraseScalarFieldEnum[]
  }

  /**
   * Domain.relevanceScoreResults
   */
  export type Domain$relevanceScoreResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelevanceScoreResult
     */
    select?: RelevanceScoreResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelevanceScoreResult
     */
    omit?: RelevanceScoreResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelevanceScoreResultInclude<ExtArgs> | null
    where?: RelevanceScoreResultWhereInput
    orderBy?: RelevanceScoreResultOrderByWithRelationInput | RelevanceScoreResultOrderByWithRelationInput[]
    cursor?: RelevanceScoreResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelevanceScoreResultScalarFieldEnum | RelevanceScoreResultScalarFieldEnum[]
  }

  /**
   * Domain without action
   */
  export type DomainDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
  }


  /**
   * Model CrawlResult
   */

  export type AggregateCrawlResult = {
    _count: CrawlResultCountAggregateOutputType | null
    _avg: CrawlResultAvgAggregateOutputType | null
    _sum: CrawlResultSumAggregateOutputType | null
    _min: CrawlResultMinAggregateOutputType | null
    _max: CrawlResultMaxAggregateOutputType | null
  }

  export type CrawlResultAvgAggregateOutputType = {
    id: number | null
    domainId: number | null
    pagesScanned: number | null
    tokenUsage: number | null
  }

  export type CrawlResultSumAggregateOutputType = {
    id: number | null
    domainId: number | null
    pagesScanned: number | null
    tokenUsage: number | null
  }

  export type CrawlResultMinAggregateOutputType = {
    id: number | null
    domainId: number | null
    pagesScanned: number | null
    analyzedUrls: string | null
    extractedContext: string | null
    tokenUsage: number | null
    createdAt: Date | null
  }

  export type CrawlResultMaxAggregateOutputType = {
    id: number | null
    domainId: number | null
    pagesScanned: number | null
    analyzedUrls: string | null
    extractedContext: string | null
    tokenUsage: number | null
    createdAt: Date | null
  }

  export type CrawlResultCountAggregateOutputType = {
    id: number
    domainId: number
    pagesScanned: number
    analyzedUrls: number
    extractedContext: number
    tokenUsage: number
    createdAt: number
    _all: number
  }


  export type CrawlResultAvgAggregateInputType = {
    id?: true
    domainId?: true
    pagesScanned?: true
    tokenUsage?: true
  }

  export type CrawlResultSumAggregateInputType = {
    id?: true
    domainId?: true
    pagesScanned?: true
    tokenUsage?: true
  }

  export type CrawlResultMinAggregateInputType = {
    id?: true
    domainId?: true
    pagesScanned?: true
    analyzedUrls?: true
    extractedContext?: true
    tokenUsage?: true
    createdAt?: true
  }

  export type CrawlResultMaxAggregateInputType = {
    id?: true
    domainId?: true
    pagesScanned?: true
    analyzedUrls?: true
    extractedContext?: true
    tokenUsage?: true
    createdAt?: true
  }

  export type CrawlResultCountAggregateInputType = {
    id?: true
    domainId?: true
    pagesScanned?: true
    analyzedUrls?: true
    extractedContext?: true
    tokenUsage?: true
    createdAt?: true
    _all?: true
  }

  export type CrawlResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrawlResult to aggregate.
     */
    where?: CrawlResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrawlResults to fetch.
     */
    orderBy?: CrawlResultOrderByWithRelationInput | CrawlResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrawlResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrawlResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrawlResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrawlResults
    **/
    _count?: true | CrawlResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrawlResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrawlResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrawlResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrawlResultMaxAggregateInputType
  }

  export type GetCrawlResultAggregateType<T extends CrawlResultAggregateArgs> = {
        [P in keyof T & keyof AggregateCrawlResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrawlResult[P]>
      : GetScalarType<T[P], AggregateCrawlResult[P]>
  }




  export type CrawlResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrawlResultWhereInput
    orderBy?: CrawlResultOrderByWithAggregationInput | CrawlResultOrderByWithAggregationInput[]
    by: CrawlResultScalarFieldEnum[] | CrawlResultScalarFieldEnum
    having?: CrawlResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrawlResultCountAggregateInputType | true
    _avg?: CrawlResultAvgAggregateInputType
    _sum?: CrawlResultSumAggregateInputType
    _min?: CrawlResultMinAggregateInputType
    _max?: CrawlResultMaxAggregateInputType
  }

  export type CrawlResultGroupByOutputType = {
    id: number
    domainId: number | null
    pagesScanned: number
    analyzedUrls: string
    extractedContext: string
    tokenUsage: number | null
    createdAt: Date
    _count: CrawlResultCountAggregateOutputType | null
    _avg: CrawlResultAvgAggregateOutputType | null
    _sum: CrawlResultSumAggregateOutputType | null
    _min: CrawlResultMinAggregateOutputType | null
    _max: CrawlResultMaxAggregateOutputType | null
  }

  type GetCrawlResultGroupByPayload<T extends CrawlResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrawlResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrawlResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrawlResultGroupByOutputType[P]>
            : GetScalarType<T[P], CrawlResultGroupByOutputType[P]>
        }
      >
    >


  export type CrawlResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    pagesScanned?: boolean
    analyzedUrls?: boolean
    extractedContext?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    domain?: boolean | CrawlResult$domainArgs<ExtArgs>
  }, ExtArgs["result"]["crawlResult"]>

  export type CrawlResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    pagesScanned?: boolean
    analyzedUrls?: boolean
    extractedContext?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    domain?: boolean | CrawlResult$domainArgs<ExtArgs>
  }, ExtArgs["result"]["crawlResult"]>


  export type CrawlResultSelectScalar = {
    id?: boolean
    domainId?: boolean
    pagesScanned?: boolean
    analyzedUrls?: boolean
    extractedContext?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
  }

  export type CrawlResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "domainId" | "pagesScanned" | "analyzedUrls" | "extractedContext" | "tokenUsage" | "createdAt", ExtArgs["result"]["crawlResult"]>
  export type CrawlResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | CrawlResult$domainArgs<ExtArgs>
  }
  export type CrawlResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | CrawlResult$domainArgs<ExtArgs>
  }

  export type $CrawlResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrawlResult"
    objects: {
      domain: Prisma.$DomainPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      domainId: number | null
      pagesScanned: number
      analyzedUrls: string
      extractedContext: string
      tokenUsage: number | null
      createdAt: Date
    }, ExtArgs["result"]["crawlResult"]>
    composites: {}
  }

  type CrawlResultGetPayload<S extends boolean | null | undefined | CrawlResultDefaultArgs> = $Result.GetResult<Prisma.$CrawlResultPayload, S>

  type CrawlResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CrawlResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CrawlResultCountAggregateInputType | true
    }

  export interface CrawlResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrawlResult'], meta: { name: 'CrawlResult' } }
    /**
     * Find zero or one CrawlResult that matches the filter.
     * @param {CrawlResultFindUniqueArgs} args - Arguments to find a CrawlResult
     * @example
     * // Get one CrawlResult
     * const crawlResult = await prisma.crawlResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CrawlResultFindUniqueArgs>(args: SelectSubset<T, CrawlResultFindUniqueArgs<ExtArgs>>): Prisma__CrawlResultClient<$Result.GetResult<Prisma.$CrawlResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CrawlResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CrawlResultFindUniqueOrThrowArgs} args - Arguments to find a CrawlResult
     * @example
     * // Get one CrawlResult
     * const crawlResult = await prisma.crawlResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CrawlResultFindUniqueOrThrowArgs>(args: SelectSubset<T, CrawlResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CrawlResultClient<$Result.GetResult<Prisma.$CrawlResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CrawlResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrawlResultFindFirstArgs} args - Arguments to find a CrawlResult
     * @example
     * // Get one CrawlResult
     * const crawlResult = await prisma.crawlResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CrawlResultFindFirstArgs>(args?: SelectSubset<T, CrawlResultFindFirstArgs<ExtArgs>>): Prisma__CrawlResultClient<$Result.GetResult<Prisma.$CrawlResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CrawlResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrawlResultFindFirstOrThrowArgs} args - Arguments to find a CrawlResult
     * @example
     * // Get one CrawlResult
     * const crawlResult = await prisma.crawlResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CrawlResultFindFirstOrThrowArgs>(args?: SelectSubset<T, CrawlResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__CrawlResultClient<$Result.GetResult<Prisma.$CrawlResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CrawlResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrawlResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrawlResults
     * const crawlResults = await prisma.crawlResult.findMany()
     * 
     * // Get first 10 CrawlResults
     * const crawlResults = await prisma.crawlResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crawlResultWithIdOnly = await prisma.crawlResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CrawlResultFindManyArgs>(args?: SelectSubset<T, CrawlResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrawlResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CrawlResult.
     * @param {CrawlResultCreateArgs} args - Arguments to create a CrawlResult.
     * @example
     * // Create one CrawlResult
     * const CrawlResult = await prisma.crawlResult.create({
     *   data: {
     *     // ... data to create a CrawlResult
     *   }
     * })
     * 
     */
    create<T extends CrawlResultCreateArgs>(args: SelectSubset<T, CrawlResultCreateArgs<ExtArgs>>): Prisma__CrawlResultClient<$Result.GetResult<Prisma.$CrawlResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CrawlResults.
     * @param {CrawlResultCreateManyArgs} args - Arguments to create many CrawlResults.
     * @example
     * // Create many CrawlResults
     * const crawlResult = await prisma.crawlResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CrawlResultCreateManyArgs>(args?: SelectSubset<T, CrawlResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CrawlResults and returns the data saved in the database.
     * @param {CrawlResultCreateManyAndReturnArgs} args - Arguments to create many CrawlResults.
     * @example
     * // Create many CrawlResults
     * const crawlResult = await prisma.crawlResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CrawlResults and only return the `id`
     * const crawlResultWithIdOnly = await prisma.crawlResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CrawlResultCreateManyAndReturnArgs>(args?: SelectSubset<T, CrawlResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrawlResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CrawlResult.
     * @param {CrawlResultDeleteArgs} args - Arguments to delete one CrawlResult.
     * @example
     * // Delete one CrawlResult
     * const CrawlResult = await prisma.crawlResult.delete({
     *   where: {
     *     // ... filter to delete one CrawlResult
     *   }
     * })
     * 
     */
    delete<T extends CrawlResultDeleteArgs>(args: SelectSubset<T, CrawlResultDeleteArgs<ExtArgs>>): Prisma__CrawlResultClient<$Result.GetResult<Prisma.$CrawlResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CrawlResult.
     * @param {CrawlResultUpdateArgs} args - Arguments to update one CrawlResult.
     * @example
     * // Update one CrawlResult
     * const crawlResult = await prisma.crawlResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CrawlResultUpdateArgs>(args: SelectSubset<T, CrawlResultUpdateArgs<ExtArgs>>): Prisma__CrawlResultClient<$Result.GetResult<Prisma.$CrawlResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CrawlResults.
     * @param {CrawlResultDeleteManyArgs} args - Arguments to filter CrawlResults to delete.
     * @example
     * // Delete a few CrawlResults
     * const { count } = await prisma.crawlResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CrawlResultDeleteManyArgs>(args?: SelectSubset<T, CrawlResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrawlResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrawlResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrawlResults
     * const crawlResult = await prisma.crawlResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CrawlResultUpdateManyArgs>(args: SelectSubset<T, CrawlResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CrawlResult.
     * @param {CrawlResultUpsertArgs} args - Arguments to update or create a CrawlResult.
     * @example
     * // Update or create a CrawlResult
     * const crawlResult = await prisma.crawlResult.upsert({
     *   create: {
     *     // ... data to create a CrawlResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrawlResult we want to update
     *   }
     * })
     */
    upsert<T extends CrawlResultUpsertArgs>(args: SelectSubset<T, CrawlResultUpsertArgs<ExtArgs>>): Prisma__CrawlResultClient<$Result.GetResult<Prisma.$CrawlResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CrawlResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrawlResultCountArgs} args - Arguments to filter CrawlResults to count.
     * @example
     * // Count the number of CrawlResults
     * const count = await prisma.crawlResult.count({
     *   where: {
     *     // ... the filter for the CrawlResults we want to count
     *   }
     * })
    **/
    count<T extends CrawlResultCountArgs>(
      args?: Subset<T, CrawlResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrawlResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrawlResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrawlResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrawlResultAggregateArgs>(args: Subset<T, CrawlResultAggregateArgs>): Prisma.PrismaPromise<GetCrawlResultAggregateType<T>>

    /**
     * Group by CrawlResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrawlResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrawlResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrawlResultGroupByArgs['orderBy'] }
        : { orderBy?: CrawlResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrawlResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrawlResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrawlResult model
   */
  readonly fields: CrawlResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrawlResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrawlResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domain<T extends CrawlResult$domainArgs<ExtArgs> = {}>(args?: Subset<T, CrawlResult$domainArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CrawlResult model
   */
  interface CrawlResultFieldRefs {
    readonly id: FieldRef<"CrawlResult", 'Int'>
    readonly domainId: FieldRef<"CrawlResult", 'Int'>
    readonly pagesScanned: FieldRef<"CrawlResult", 'Int'>
    readonly analyzedUrls: FieldRef<"CrawlResult", 'String'>
    readonly extractedContext: FieldRef<"CrawlResult", 'String'>
    readonly tokenUsage: FieldRef<"CrawlResult", 'Int'>
    readonly createdAt: FieldRef<"CrawlResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CrawlResult findUnique
   */
  export type CrawlResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrawlResult
     */
    select?: CrawlResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrawlResult
     */
    omit?: CrawlResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrawlResultInclude<ExtArgs> | null
    /**
     * Filter, which CrawlResult to fetch.
     */
    where: CrawlResultWhereUniqueInput
  }

  /**
   * CrawlResult findUniqueOrThrow
   */
  export type CrawlResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrawlResult
     */
    select?: CrawlResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrawlResult
     */
    omit?: CrawlResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrawlResultInclude<ExtArgs> | null
    /**
     * Filter, which CrawlResult to fetch.
     */
    where: CrawlResultWhereUniqueInput
  }

  /**
   * CrawlResult findFirst
   */
  export type CrawlResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrawlResult
     */
    select?: CrawlResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrawlResult
     */
    omit?: CrawlResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrawlResultInclude<ExtArgs> | null
    /**
     * Filter, which CrawlResult to fetch.
     */
    where?: CrawlResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrawlResults to fetch.
     */
    orderBy?: CrawlResultOrderByWithRelationInput | CrawlResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrawlResults.
     */
    cursor?: CrawlResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrawlResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrawlResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrawlResults.
     */
    distinct?: CrawlResultScalarFieldEnum | CrawlResultScalarFieldEnum[]
  }

  /**
   * CrawlResult findFirstOrThrow
   */
  export type CrawlResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrawlResult
     */
    select?: CrawlResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrawlResult
     */
    omit?: CrawlResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrawlResultInclude<ExtArgs> | null
    /**
     * Filter, which CrawlResult to fetch.
     */
    where?: CrawlResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrawlResults to fetch.
     */
    orderBy?: CrawlResultOrderByWithRelationInput | CrawlResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrawlResults.
     */
    cursor?: CrawlResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrawlResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrawlResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrawlResults.
     */
    distinct?: CrawlResultScalarFieldEnum | CrawlResultScalarFieldEnum[]
  }

  /**
   * CrawlResult findMany
   */
  export type CrawlResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrawlResult
     */
    select?: CrawlResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrawlResult
     */
    omit?: CrawlResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrawlResultInclude<ExtArgs> | null
    /**
     * Filter, which CrawlResults to fetch.
     */
    where?: CrawlResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrawlResults to fetch.
     */
    orderBy?: CrawlResultOrderByWithRelationInput | CrawlResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrawlResults.
     */
    cursor?: CrawlResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrawlResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrawlResults.
     */
    skip?: number
    distinct?: CrawlResultScalarFieldEnum | CrawlResultScalarFieldEnum[]
  }

  /**
   * CrawlResult create
   */
  export type CrawlResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrawlResult
     */
    select?: CrawlResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrawlResult
     */
    omit?: CrawlResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrawlResultInclude<ExtArgs> | null
    /**
     * The data needed to create a CrawlResult.
     */
    data: XOR<CrawlResultCreateInput, CrawlResultUncheckedCreateInput>
  }

  /**
   * CrawlResult createMany
   */
  export type CrawlResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrawlResults.
     */
    data: CrawlResultCreateManyInput | CrawlResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CrawlResult createManyAndReturn
   */
  export type CrawlResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrawlResult
     */
    select?: CrawlResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CrawlResult
     */
    omit?: CrawlResultOmit<ExtArgs> | null
    /**
     * The data used to create many CrawlResults.
     */
    data: CrawlResultCreateManyInput | CrawlResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrawlResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CrawlResult update
   */
  export type CrawlResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrawlResult
     */
    select?: CrawlResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrawlResult
     */
    omit?: CrawlResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrawlResultInclude<ExtArgs> | null
    /**
     * The data needed to update a CrawlResult.
     */
    data: XOR<CrawlResultUpdateInput, CrawlResultUncheckedUpdateInput>
    /**
     * Choose, which CrawlResult to update.
     */
    where: CrawlResultWhereUniqueInput
  }

  /**
   * CrawlResult updateMany
   */
  export type CrawlResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrawlResults.
     */
    data: XOR<CrawlResultUpdateManyMutationInput, CrawlResultUncheckedUpdateManyInput>
    /**
     * Filter which CrawlResults to update
     */
    where?: CrawlResultWhereInput
  }

  /**
   * CrawlResult upsert
   */
  export type CrawlResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrawlResult
     */
    select?: CrawlResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrawlResult
     */
    omit?: CrawlResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrawlResultInclude<ExtArgs> | null
    /**
     * The filter to search for the CrawlResult to update in case it exists.
     */
    where: CrawlResultWhereUniqueInput
    /**
     * In case the CrawlResult found by the `where` argument doesn't exist, create a new CrawlResult with this data.
     */
    create: XOR<CrawlResultCreateInput, CrawlResultUncheckedCreateInput>
    /**
     * In case the CrawlResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrawlResultUpdateInput, CrawlResultUncheckedUpdateInput>
  }

  /**
   * CrawlResult delete
   */
  export type CrawlResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrawlResult
     */
    select?: CrawlResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrawlResult
     */
    omit?: CrawlResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrawlResultInclude<ExtArgs> | null
    /**
     * Filter which CrawlResult to delete.
     */
    where: CrawlResultWhereUniqueInput
  }

  /**
   * CrawlResult deleteMany
   */
  export type CrawlResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrawlResults to delete
     */
    where?: CrawlResultWhereInput
  }

  /**
   * CrawlResult.domain
   */
  export type CrawlResult$domainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    where?: DomainWhereInput
  }

  /**
   * CrawlResult without action
   */
  export type CrawlResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrawlResult
     */
    select?: CrawlResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrawlResult
     */
    omit?: CrawlResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrawlResultInclude<ExtArgs> | null
  }


  /**
   * Model Keyword
   */

  export type AggregateKeyword = {
    _count: KeywordCountAggregateOutputType | null
    _avg: KeywordAvgAggregateOutputType | null
    _sum: KeywordSumAggregateOutputType | null
    _min: KeywordMinAggregateOutputType | null
    _max: KeywordMaxAggregateOutputType | null
  }

  export type KeywordAvgAggregateOutputType = {
    id: number | null
    volume: number | null
    cpc: number | null
    domainId: number | null
  }

  export type KeywordSumAggregateOutputType = {
    id: number | null
    volume: number | null
    cpc: number | null
    domainId: number | null
  }

  export type KeywordMinAggregateOutputType = {
    id: number | null
    term: string | null
    volume: number | null
    difficulty: string | null
    cpc: number | null
    intent: string | null
    domainId: number | null
    isSelected: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KeywordMaxAggregateOutputType = {
    id: number | null
    term: string | null
    volume: number | null
    difficulty: string | null
    cpc: number | null
    intent: string | null
    domainId: number | null
    isSelected: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KeywordCountAggregateOutputType = {
    id: number
    term: number
    volume: number
    difficulty: number
    cpc: number
    intent: number
    domainId: number
    isSelected: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KeywordAvgAggregateInputType = {
    id?: true
    volume?: true
    cpc?: true
    domainId?: true
  }

  export type KeywordSumAggregateInputType = {
    id?: true
    volume?: true
    cpc?: true
    domainId?: true
  }

  export type KeywordMinAggregateInputType = {
    id?: true
    term?: true
    volume?: true
    difficulty?: true
    cpc?: true
    intent?: true
    domainId?: true
    isSelected?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KeywordMaxAggregateInputType = {
    id?: true
    term?: true
    volume?: true
    difficulty?: true
    cpc?: true
    intent?: true
    domainId?: true
    isSelected?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KeywordCountAggregateInputType = {
    id?: true
    term?: true
    volume?: true
    difficulty?: true
    cpc?: true
    intent?: true
    domainId?: true
    isSelected?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KeywordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Keyword to aggregate.
     */
    where?: KeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Keywords to fetch.
     */
    orderBy?: KeywordOrderByWithRelationInput | KeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Keywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Keywords
    **/
    _count?: true | KeywordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KeywordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KeywordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KeywordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KeywordMaxAggregateInputType
  }

  export type GetKeywordAggregateType<T extends KeywordAggregateArgs> = {
        [P in keyof T & keyof AggregateKeyword]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKeyword[P]>
      : GetScalarType<T[P], AggregateKeyword[P]>
  }




  export type KeywordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeywordWhereInput
    orderBy?: KeywordOrderByWithAggregationInput | KeywordOrderByWithAggregationInput[]
    by: KeywordScalarFieldEnum[] | KeywordScalarFieldEnum
    having?: KeywordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KeywordCountAggregateInputType | true
    _avg?: KeywordAvgAggregateInputType
    _sum?: KeywordSumAggregateInputType
    _min?: KeywordMinAggregateInputType
    _max?: KeywordMaxAggregateInputType
  }

  export type KeywordGroupByOutputType = {
    id: number
    term: string
    volume: number
    difficulty: string
    cpc: number
    intent: string | null
    domainId: number | null
    isSelected: boolean
    createdAt: Date
    updatedAt: Date
    _count: KeywordCountAggregateOutputType | null
    _avg: KeywordAvgAggregateOutputType | null
    _sum: KeywordSumAggregateOutputType | null
    _min: KeywordMinAggregateOutputType | null
    _max: KeywordMaxAggregateOutputType | null
  }

  type GetKeywordGroupByPayload<T extends KeywordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KeywordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KeywordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KeywordGroupByOutputType[P]>
            : GetScalarType<T[P], KeywordGroupByOutputType[P]>
        }
      >
    >


  export type KeywordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    term?: boolean
    volume?: boolean
    difficulty?: boolean
    cpc?: boolean
    intent?: boolean
    domainId?: boolean
    isSelected?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domain?: boolean | Keyword$domainArgs<ExtArgs>
    phrases?: boolean | Keyword$phrasesArgs<ExtArgs>
    communityInsights?: boolean | Keyword$communityInsightsArgs<ExtArgs>
    searchPatterns?: boolean | Keyword$searchPatternsArgs<ExtArgs>
    communityMiningResults?: boolean | Keyword$communityMiningResultsArgs<ExtArgs>
    searchPatternResults?: boolean | Keyword$searchPatternResultsArgs<ExtArgs>
    intentClassificationResults?: boolean | Keyword$intentClassificationResultsArgs<ExtArgs>
    generatedIntentPhrases?: boolean | Keyword$generatedIntentPhrasesArgs<ExtArgs>
    _count?: boolean | KeywordCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keyword"]>

  export type KeywordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    term?: boolean
    volume?: boolean
    difficulty?: boolean
    cpc?: boolean
    intent?: boolean
    domainId?: boolean
    isSelected?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domain?: boolean | Keyword$domainArgs<ExtArgs>
  }, ExtArgs["result"]["keyword"]>


  export type KeywordSelectScalar = {
    id?: boolean
    term?: boolean
    volume?: boolean
    difficulty?: boolean
    cpc?: boolean
    intent?: boolean
    domainId?: boolean
    isSelected?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KeywordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "term" | "volume" | "difficulty" | "cpc" | "intent" | "domainId" | "isSelected" | "createdAt" | "updatedAt", ExtArgs["result"]["keyword"]>
  export type KeywordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | Keyword$domainArgs<ExtArgs>
    phrases?: boolean | Keyword$phrasesArgs<ExtArgs>
    communityInsights?: boolean | Keyword$communityInsightsArgs<ExtArgs>
    searchPatterns?: boolean | Keyword$searchPatternsArgs<ExtArgs>
    communityMiningResults?: boolean | Keyword$communityMiningResultsArgs<ExtArgs>
    searchPatternResults?: boolean | Keyword$searchPatternResultsArgs<ExtArgs>
    intentClassificationResults?: boolean | Keyword$intentClassificationResultsArgs<ExtArgs>
    generatedIntentPhrases?: boolean | Keyword$generatedIntentPhrasesArgs<ExtArgs>
    _count?: boolean | KeywordCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KeywordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | Keyword$domainArgs<ExtArgs>
  }

  export type $KeywordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Keyword"
    objects: {
      domain: Prisma.$DomainPayload<ExtArgs> | null
      phrases: Prisma.$PhrasePayload<ExtArgs>[]
      communityInsights: Prisma.$CommunityInsightPayload<ExtArgs>[]
      searchPatterns: Prisma.$SearchPatternPayload<ExtArgs>[]
      communityMiningResults: Prisma.$CommunityMiningResultPayload<ExtArgs>[]
      searchPatternResults: Prisma.$SearchPatternResultPayload<ExtArgs>[]
      intentClassificationResults: Prisma.$IntentClassificationResultPayload<ExtArgs>[]
      generatedIntentPhrases: Prisma.$GeneratedIntentPhrasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      term: string
      volume: number
      difficulty: string
      cpc: number
      intent: string | null
      domainId: number | null
      isSelected: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["keyword"]>
    composites: {}
  }

  type KeywordGetPayload<S extends boolean | null | undefined | KeywordDefaultArgs> = $Result.GetResult<Prisma.$KeywordPayload, S>

  type KeywordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KeywordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KeywordCountAggregateInputType | true
    }

  export interface KeywordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Keyword'], meta: { name: 'Keyword' } }
    /**
     * Find zero or one Keyword that matches the filter.
     * @param {KeywordFindUniqueArgs} args - Arguments to find a Keyword
     * @example
     * // Get one Keyword
     * const keyword = await prisma.keyword.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KeywordFindUniqueArgs>(args: SelectSubset<T, KeywordFindUniqueArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Keyword that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KeywordFindUniqueOrThrowArgs} args - Arguments to find a Keyword
     * @example
     * // Get one Keyword
     * const keyword = await prisma.keyword.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KeywordFindUniqueOrThrowArgs>(args: SelectSubset<T, KeywordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Keyword that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordFindFirstArgs} args - Arguments to find a Keyword
     * @example
     * // Get one Keyword
     * const keyword = await prisma.keyword.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KeywordFindFirstArgs>(args?: SelectSubset<T, KeywordFindFirstArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Keyword that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordFindFirstOrThrowArgs} args - Arguments to find a Keyword
     * @example
     * // Get one Keyword
     * const keyword = await prisma.keyword.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KeywordFindFirstOrThrowArgs>(args?: SelectSubset<T, KeywordFindFirstOrThrowArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Keywords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Keywords
     * const keywords = await prisma.keyword.findMany()
     * 
     * // Get first 10 Keywords
     * const keywords = await prisma.keyword.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const keywordWithIdOnly = await prisma.keyword.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KeywordFindManyArgs>(args?: SelectSubset<T, KeywordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Keyword.
     * @param {KeywordCreateArgs} args - Arguments to create a Keyword.
     * @example
     * // Create one Keyword
     * const Keyword = await prisma.keyword.create({
     *   data: {
     *     // ... data to create a Keyword
     *   }
     * })
     * 
     */
    create<T extends KeywordCreateArgs>(args: SelectSubset<T, KeywordCreateArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Keywords.
     * @param {KeywordCreateManyArgs} args - Arguments to create many Keywords.
     * @example
     * // Create many Keywords
     * const keyword = await prisma.keyword.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KeywordCreateManyArgs>(args?: SelectSubset<T, KeywordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Keywords and returns the data saved in the database.
     * @param {KeywordCreateManyAndReturnArgs} args - Arguments to create many Keywords.
     * @example
     * // Create many Keywords
     * const keyword = await prisma.keyword.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Keywords and only return the `id`
     * const keywordWithIdOnly = await prisma.keyword.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KeywordCreateManyAndReturnArgs>(args?: SelectSubset<T, KeywordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Keyword.
     * @param {KeywordDeleteArgs} args - Arguments to delete one Keyword.
     * @example
     * // Delete one Keyword
     * const Keyword = await prisma.keyword.delete({
     *   where: {
     *     // ... filter to delete one Keyword
     *   }
     * })
     * 
     */
    delete<T extends KeywordDeleteArgs>(args: SelectSubset<T, KeywordDeleteArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Keyword.
     * @param {KeywordUpdateArgs} args - Arguments to update one Keyword.
     * @example
     * // Update one Keyword
     * const keyword = await prisma.keyword.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KeywordUpdateArgs>(args: SelectSubset<T, KeywordUpdateArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Keywords.
     * @param {KeywordDeleteManyArgs} args - Arguments to filter Keywords to delete.
     * @example
     * // Delete a few Keywords
     * const { count } = await prisma.keyword.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KeywordDeleteManyArgs>(args?: SelectSubset<T, KeywordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Keywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Keywords
     * const keyword = await prisma.keyword.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KeywordUpdateManyArgs>(args: SelectSubset<T, KeywordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Keyword.
     * @param {KeywordUpsertArgs} args - Arguments to update or create a Keyword.
     * @example
     * // Update or create a Keyword
     * const keyword = await prisma.keyword.upsert({
     *   create: {
     *     // ... data to create a Keyword
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Keyword we want to update
     *   }
     * })
     */
    upsert<T extends KeywordUpsertArgs>(args: SelectSubset<T, KeywordUpsertArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Keywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordCountArgs} args - Arguments to filter Keywords to count.
     * @example
     * // Count the number of Keywords
     * const count = await prisma.keyword.count({
     *   where: {
     *     // ... the filter for the Keywords we want to count
     *   }
     * })
    **/
    count<T extends KeywordCountArgs>(
      args?: Subset<T, KeywordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KeywordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Keyword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KeywordAggregateArgs>(args: Subset<T, KeywordAggregateArgs>): Prisma.PrismaPromise<GetKeywordAggregateType<T>>

    /**
     * Group by Keyword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KeywordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KeywordGroupByArgs['orderBy'] }
        : { orderBy?: KeywordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KeywordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKeywordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Keyword model
   */
  readonly fields: KeywordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Keyword.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KeywordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domain<T extends Keyword$domainArgs<ExtArgs> = {}>(args?: Subset<T, Keyword$domainArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    phrases<T extends Keyword$phrasesArgs<ExtArgs> = {}>(args?: Subset<T, Keyword$phrasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    communityInsights<T extends Keyword$communityInsightsArgs<ExtArgs> = {}>(args?: Subset<T, Keyword$communityInsightsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityInsightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    searchPatterns<T extends Keyword$searchPatternsArgs<ExtArgs> = {}>(args?: Subset<T, Keyword$searchPatternsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchPatternPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    communityMiningResults<T extends Keyword$communityMiningResultsArgs<ExtArgs> = {}>(args?: Subset<T, Keyword$communityMiningResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityMiningResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    searchPatternResults<T extends Keyword$searchPatternResultsArgs<ExtArgs> = {}>(args?: Subset<T, Keyword$searchPatternResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchPatternResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    intentClassificationResults<T extends Keyword$intentClassificationResultsArgs<ExtArgs> = {}>(args?: Subset<T, Keyword$intentClassificationResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntentClassificationResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generatedIntentPhrases<T extends Keyword$generatedIntentPhrasesArgs<ExtArgs> = {}>(args?: Subset<T, Keyword$generatedIntentPhrasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedIntentPhrasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Keyword model
   */
  interface KeywordFieldRefs {
    readonly id: FieldRef<"Keyword", 'Int'>
    readonly term: FieldRef<"Keyword", 'String'>
    readonly volume: FieldRef<"Keyword", 'Int'>
    readonly difficulty: FieldRef<"Keyword", 'String'>
    readonly cpc: FieldRef<"Keyword", 'Float'>
    readonly intent: FieldRef<"Keyword", 'String'>
    readonly domainId: FieldRef<"Keyword", 'Int'>
    readonly isSelected: FieldRef<"Keyword", 'Boolean'>
    readonly createdAt: FieldRef<"Keyword", 'DateTime'>
    readonly updatedAt: FieldRef<"Keyword", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Keyword findUnique
   */
  export type KeywordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * Filter, which Keyword to fetch.
     */
    where: KeywordWhereUniqueInput
  }

  /**
   * Keyword findUniqueOrThrow
   */
  export type KeywordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * Filter, which Keyword to fetch.
     */
    where: KeywordWhereUniqueInput
  }

  /**
   * Keyword findFirst
   */
  export type KeywordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * Filter, which Keyword to fetch.
     */
    where?: KeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Keywords to fetch.
     */
    orderBy?: KeywordOrderByWithRelationInput | KeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Keywords.
     */
    cursor?: KeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Keywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Keywords.
     */
    distinct?: KeywordScalarFieldEnum | KeywordScalarFieldEnum[]
  }

  /**
   * Keyword findFirstOrThrow
   */
  export type KeywordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * Filter, which Keyword to fetch.
     */
    where?: KeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Keywords to fetch.
     */
    orderBy?: KeywordOrderByWithRelationInput | KeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Keywords.
     */
    cursor?: KeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Keywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Keywords.
     */
    distinct?: KeywordScalarFieldEnum | KeywordScalarFieldEnum[]
  }

  /**
   * Keyword findMany
   */
  export type KeywordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * Filter, which Keywords to fetch.
     */
    where?: KeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Keywords to fetch.
     */
    orderBy?: KeywordOrderByWithRelationInput | KeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Keywords.
     */
    cursor?: KeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Keywords.
     */
    skip?: number
    distinct?: KeywordScalarFieldEnum | KeywordScalarFieldEnum[]
  }

  /**
   * Keyword create
   */
  export type KeywordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * The data needed to create a Keyword.
     */
    data: XOR<KeywordCreateInput, KeywordUncheckedCreateInput>
  }

  /**
   * Keyword createMany
   */
  export type KeywordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Keywords.
     */
    data: KeywordCreateManyInput | KeywordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Keyword createManyAndReturn
   */
  export type KeywordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * The data used to create many Keywords.
     */
    data: KeywordCreateManyInput | KeywordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Keyword update
   */
  export type KeywordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * The data needed to update a Keyword.
     */
    data: XOR<KeywordUpdateInput, KeywordUncheckedUpdateInput>
    /**
     * Choose, which Keyword to update.
     */
    where: KeywordWhereUniqueInput
  }

  /**
   * Keyword updateMany
   */
  export type KeywordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Keywords.
     */
    data: XOR<KeywordUpdateManyMutationInput, KeywordUncheckedUpdateManyInput>
    /**
     * Filter which Keywords to update
     */
    where?: KeywordWhereInput
  }

  /**
   * Keyword upsert
   */
  export type KeywordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * The filter to search for the Keyword to update in case it exists.
     */
    where: KeywordWhereUniqueInput
    /**
     * In case the Keyword found by the `where` argument doesn't exist, create a new Keyword with this data.
     */
    create: XOR<KeywordCreateInput, KeywordUncheckedCreateInput>
    /**
     * In case the Keyword was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KeywordUpdateInput, KeywordUncheckedUpdateInput>
  }

  /**
   * Keyword delete
   */
  export type KeywordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * Filter which Keyword to delete.
     */
    where: KeywordWhereUniqueInput
  }

  /**
   * Keyword deleteMany
   */
  export type KeywordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Keywords to delete
     */
    where?: KeywordWhereInput
  }

  /**
   * Keyword.domain
   */
  export type Keyword$domainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    where?: DomainWhereInput
  }

  /**
   * Keyword.phrases
   */
  export type Keyword$phrasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phrase
     */
    select?: PhraseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phrase
     */
    omit?: PhraseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseInclude<ExtArgs> | null
    where?: PhraseWhereInput
    orderBy?: PhraseOrderByWithRelationInput | PhraseOrderByWithRelationInput[]
    cursor?: PhraseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhraseScalarFieldEnum | PhraseScalarFieldEnum[]
  }

  /**
   * Keyword.communityInsights
   */
  export type Keyword$communityInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityInsight
     */
    select?: CommunityInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityInsight
     */
    omit?: CommunityInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInsightInclude<ExtArgs> | null
    where?: CommunityInsightWhereInput
    orderBy?: CommunityInsightOrderByWithRelationInput | CommunityInsightOrderByWithRelationInput[]
    cursor?: CommunityInsightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityInsightScalarFieldEnum | CommunityInsightScalarFieldEnum[]
  }

  /**
   * Keyword.searchPatterns
   */
  export type Keyword$searchPatternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPattern
     */
    select?: SearchPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPattern
     */
    omit?: SearchPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternInclude<ExtArgs> | null
    where?: SearchPatternWhereInput
    orderBy?: SearchPatternOrderByWithRelationInput | SearchPatternOrderByWithRelationInput[]
    cursor?: SearchPatternWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SearchPatternScalarFieldEnum | SearchPatternScalarFieldEnum[]
  }

  /**
   * Keyword.communityMiningResults
   */
  export type Keyword$communityMiningResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMiningResult
     */
    select?: CommunityMiningResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMiningResult
     */
    omit?: CommunityMiningResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMiningResultInclude<ExtArgs> | null
    where?: CommunityMiningResultWhereInput
    orderBy?: CommunityMiningResultOrderByWithRelationInput | CommunityMiningResultOrderByWithRelationInput[]
    cursor?: CommunityMiningResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityMiningResultScalarFieldEnum | CommunityMiningResultScalarFieldEnum[]
  }

  /**
   * Keyword.searchPatternResults
   */
  export type Keyword$searchPatternResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPatternResult
     */
    select?: SearchPatternResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPatternResult
     */
    omit?: SearchPatternResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternResultInclude<ExtArgs> | null
    where?: SearchPatternResultWhereInput
    orderBy?: SearchPatternResultOrderByWithRelationInput | SearchPatternResultOrderByWithRelationInput[]
    cursor?: SearchPatternResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SearchPatternResultScalarFieldEnum | SearchPatternResultScalarFieldEnum[]
  }

  /**
   * Keyword.intentClassificationResults
   */
  export type Keyword$intentClassificationResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentClassificationResult
     */
    select?: IntentClassificationResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentClassificationResult
     */
    omit?: IntentClassificationResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentClassificationResultInclude<ExtArgs> | null
    where?: IntentClassificationResultWhereInput
    orderBy?: IntentClassificationResultOrderByWithRelationInput | IntentClassificationResultOrderByWithRelationInput[]
    cursor?: IntentClassificationResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntentClassificationResultScalarFieldEnum | IntentClassificationResultScalarFieldEnum[]
  }

  /**
   * Keyword.generatedIntentPhrases
   */
  export type Keyword$generatedIntentPhrasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedIntentPhrase
     */
    select?: GeneratedIntentPhraseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedIntentPhrase
     */
    omit?: GeneratedIntentPhraseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedIntentPhraseInclude<ExtArgs> | null
    where?: GeneratedIntentPhraseWhereInput
    orderBy?: GeneratedIntentPhraseOrderByWithRelationInput | GeneratedIntentPhraseOrderByWithRelationInput[]
    cursor?: GeneratedIntentPhraseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeneratedIntentPhraseScalarFieldEnum | GeneratedIntentPhraseScalarFieldEnum[]
  }

  /**
   * Keyword without action
   */
  export type KeywordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
  }


  /**
   * Model Phrase
   */

  export type AggregatePhrase = {
    _count: PhraseCountAggregateOutputType | null
    _avg: PhraseAvgAggregateOutputType | null
    _sum: PhraseSumAggregateOutputType | null
    _min: PhraseMinAggregateOutputType | null
    _max: PhraseMaxAggregateOutputType | null
  }

  export type PhraseAvgAggregateOutputType = {
    id: number | null
    keywordId: number | null
    relevanceScore: number | null
    confidence: number | null
  }

  export type PhraseSumAggregateOutputType = {
    id: number | null
    keywordId: number | null
    relevanceScore: number | null
    confidence: number | null
  }

  export type PhraseMinAggregateOutputType = {
    id: number | null
    text: string | null
    keywordId: number | null
    relevanceScore: number | null
    trend: string | null
    intent: string | null
    confidence: number | null
    isSelected: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PhraseMaxAggregateOutputType = {
    id: number | null
    text: string | null
    keywordId: number | null
    relevanceScore: number | null
    trend: string | null
    intent: string | null
    confidence: number | null
    isSelected: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PhraseCountAggregateOutputType = {
    id: number
    text: number
    keywordId: number
    relevanceScore: number
    sources: number
    trend: number
    intent: number
    confidence: number
    isSelected: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PhraseAvgAggregateInputType = {
    id?: true
    keywordId?: true
    relevanceScore?: true
    confidence?: true
  }

  export type PhraseSumAggregateInputType = {
    id?: true
    keywordId?: true
    relevanceScore?: true
    confidence?: true
  }

  export type PhraseMinAggregateInputType = {
    id?: true
    text?: true
    keywordId?: true
    relevanceScore?: true
    trend?: true
    intent?: true
    confidence?: true
    isSelected?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PhraseMaxAggregateInputType = {
    id?: true
    text?: true
    keywordId?: true
    relevanceScore?: true
    trend?: true
    intent?: true
    confidence?: true
    isSelected?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PhraseCountAggregateInputType = {
    id?: true
    text?: true
    keywordId?: true
    relevanceScore?: true
    sources?: true
    trend?: true
    intent?: true
    confidence?: true
    isSelected?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PhraseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Phrase to aggregate.
     */
    where?: PhraseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phrases to fetch.
     */
    orderBy?: PhraseOrderByWithRelationInput | PhraseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhraseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phrases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phrases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Phrases
    **/
    _count?: true | PhraseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PhraseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PhraseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhraseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhraseMaxAggregateInputType
  }

  export type GetPhraseAggregateType<T extends PhraseAggregateArgs> = {
        [P in keyof T & keyof AggregatePhrase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhrase[P]>
      : GetScalarType<T[P], AggregatePhrase[P]>
  }




  export type PhraseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhraseWhereInput
    orderBy?: PhraseOrderByWithAggregationInput | PhraseOrderByWithAggregationInput[]
    by: PhraseScalarFieldEnum[] | PhraseScalarFieldEnum
    having?: PhraseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhraseCountAggregateInputType | true
    _avg?: PhraseAvgAggregateInputType
    _sum?: PhraseSumAggregateInputType
    _min?: PhraseMinAggregateInputType
    _max?: PhraseMaxAggregateInputType
  }

  export type PhraseGroupByOutputType = {
    id: number
    text: string
    keywordId: number
    relevanceScore: number | null
    sources: JsonValue | null
    trend: string | null
    intent: string | null
    confidence: number | null
    isSelected: boolean
    createdAt: Date
    updatedAt: Date
    _count: PhraseCountAggregateOutputType | null
    _avg: PhraseAvgAggregateOutputType | null
    _sum: PhraseSumAggregateOutputType | null
    _min: PhraseMinAggregateOutputType | null
    _max: PhraseMaxAggregateOutputType | null
  }

  type GetPhraseGroupByPayload<T extends PhraseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhraseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhraseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhraseGroupByOutputType[P]>
            : GetScalarType<T[P], PhraseGroupByOutputType[P]>
        }
      >
    >


  export type PhraseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    keywordId?: boolean
    relevanceScore?: boolean
    sources?: boolean
    trend?: boolean
    intent?: boolean
    confidence?: boolean
    isSelected?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    keyword?: boolean | KeywordDefaultArgs<ExtArgs>
    phraseIntentClassifications?: boolean | Phrase$phraseIntentClassificationsArgs<ExtArgs>
    phraseScores?: boolean | Phrase$phraseScoresArgs<ExtArgs>
    _count?: boolean | PhraseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phrase"]>

  export type PhraseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    keywordId?: boolean
    relevanceScore?: boolean
    sources?: boolean
    trend?: boolean
    intent?: boolean
    confidence?: boolean
    isSelected?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    keyword?: boolean | KeywordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phrase"]>


  export type PhraseSelectScalar = {
    id?: boolean
    text?: boolean
    keywordId?: boolean
    relevanceScore?: boolean
    sources?: boolean
    trend?: boolean
    intent?: boolean
    confidence?: boolean
    isSelected?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PhraseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "text" | "keywordId" | "relevanceScore" | "sources" | "trend" | "intent" | "confidence" | "isSelected" | "createdAt" | "updatedAt", ExtArgs["result"]["phrase"]>
  export type PhraseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keyword?: boolean | KeywordDefaultArgs<ExtArgs>
    phraseIntentClassifications?: boolean | Phrase$phraseIntentClassificationsArgs<ExtArgs>
    phraseScores?: boolean | Phrase$phraseScoresArgs<ExtArgs>
    _count?: boolean | PhraseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PhraseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keyword?: boolean | KeywordDefaultArgs<ExtArgs>
  }

  export type $PhrasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Phrase"
    objects: {
      keyword: Prisma.$KeywordPayload<ExtArgs>
      phraseIntentClassifications: Prisma.$PhraseIntentClassificationPayload<ExtArgs>[]
      phraseScores: Prisma.$PhraseScorePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      text: string
      keywordId: number
      relevanceScore: number | null
      sources: Prisma.JsonValue | null
      trend: string | null
      intent: string | null
      confidence: number | null
      isSelected: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["phrase"]>
    composites: {}
  }

  type PhraseGetPayload<S extends boolean | null | undefined | PhraseDefaultArgs> = $Result.GetResult<Prisma.$PhrasePayload, S>

  type PhraseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PhraseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PhraseCountAggregateInputType | true
    }

  export interface PhraseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Phrase'], meta: { name: 'Phrase' } }
    /**
     * Find zero or one Phrase that matches the filter.
     * @param {PhraseFindUniqueArgs} args - Arguments to find a Phrase
     * @example
     * // Get one Phrase
     * const phrase = await prisma.phrase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhraseFindUniqueArgs>(args: SelectSubset<T, PhraseFindUniqueArgs<ExtArgs>>): Prisma__PhraseClient<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Phrase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PhraseFindUniqueOrThrowArgs} args - Arguments to find a Phrase
     * @example
     * // Get one Phrase
     * const phrase = await prisma.phrase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhraseFindUniqueOrThrowArgs>(args: SelectSubset<T, PhraseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhraseClient<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Phrase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseFindFirstArgs} args - Arguments to find a Phrase
     * @example
     * // Get one Phrase
     * const phrase = await prisma.phrase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhraseFindFirstArgs>(args?: SelectSubset<T, PhraseFindFirstArgs<ExtArgs>>): Prisma__PhraseClient<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Phrase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseFindFirstOrThrowArgs} args - Arguments to find a Phrase
     * @example
     * // Get one Phrase
     * const phrase = await prisma.phrase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhraseFindFirstOrThrowArgs>(args?: SelectSubset<T, PhraseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhraseClient<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Phrases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Phrases
     * const phrases = await prisma.phrase.findMany()
     * 
     * // Get first 10 Phrases
     * const phrases = await prisma.phrase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const phraseWithIdOnly = await prisma.phrase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhraseFindManyArgs>(args?: SelectSubset<T, PhraseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Phrase.
     * @param {PhraseCreateArgs} args - Arguments to create a Phrase.
     * @example
     * // Create one Phrase
     * const Phrase = await prisma.phrase.create({
     *   data: {
     *     // ... data to create a Phrase
     *   }
     * })
     * 
     */
    create<T extends PhraseCreateArgs>(args: SelectSubset<T, PhraseCreateArgs<ExtArgs>>): Prisma__PhraseClient<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Phrases.
     * @param {PhraseCreateManyArgs} args - Arguments to create many Phrases.
     * @example
     * // Create many Phrases
     * const phrase = await prisma.phrase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhraseCreateManyArgs>(args?: SelectSubset<T, PhraseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Phrases and returns the data saved in the database.
     * @param {PhraseCreateManyAndReturnArgs} args - Arguments to create many Phrases.
     * @example
     * // Create many Phrases
     * const phrase = await prisma.phrase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Phrases and only return the `id`
     * const phraseWithIdOnly = await prisma.phrase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PhraseCreateManyAndReturnArgs>(args?: SelectSubset<T, PhraseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Phrase.
     * @param {PhraseDeleteArgs} args - Arguments to delete one Phrase.
     * @example
     * // Delete one Phrase
     * const Phrase = await prisma.phrase.delete({
     *   where: {
     *     // ... filter to delete one Phrase
     *   }
     * })
     * 
     */
    delete<T extends PhraseDeleteArgs>(args: SelectSubset<T, PhraseDeleteArgs<ExtArgs>>): Prisma__PhraseClient<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Phrase.
     * @param {PhraseUpdateArgs} args - Arguments to update one Phrase.
     * @example
     * // Update one Phrase
     * const phrase = await prisma.phrase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhraseUpdateArgs>(args: SelectSubset<T, PhraseUpdateArgs<ExtArgs>>): Prisma__PhraseClient<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Phrases.
     * @param {PhraseDeleteManyArgs} args - Arguments to filter Phrases to delete.
     * @example
     * // Delete a few Phrases
     * const { count } = await prisma.phrase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhraseDeleteManyArgs>(args?: SelectSubset<T, PhraseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Phrases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Phrases
     * const phrase = await prisma.phrase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhraseUpdateManyArgs>(args: SelectSubset<T, PhraseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Phrase.
     * @param {PhraseUpsertArgs} args - Arguments to update or create a Phrase.
     * @example
     * // Update or create a Phrase
     * const phrase = await prisma.phrase.upsert({
     *   create: {
     *     // ... data to create a Phrase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Phrase we want to update
     *   }
     * })
     */
    upsert<T extends PhraseUpsertArgs>(args: SelectSubset<T, PhraseUpsertArgs<ExtArgs>>): Prisma__PhraseClient<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Phrases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseCountArgs} args - Arguments to filter Phrases to count.
     * @example
     * // Count the number of Phrases
     * const count = await prisma.phrase.count({
     *   where: {
     *     // ... the filter for the Phrases we want to count
     *   }
     * })
    **/
    count<T extends PhraseCountArgs>(
      args?: Subset<T, PhraseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhraseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Phrase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhraseAggregateArgs>(args: Subset<T, PhraseAggregateArgs>): Prisma.PrismaPromise<GetPhraseAggregateType<T>>

    /**
     * Group by Phrase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhraseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhraseGroupByArgs['orderBy'] }
        : { orderBy?: PhraseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhraseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhraseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Phrase model
   */
  readonly fields: PhraseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Phrase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhraseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    keyword<T extends KeywordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KeywordDefaultArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    phraseIntentClassifications<T extends Phrase$phraseIntentClassificationsArgs<ExtArgs> = {}>(args?: Subset<T, Phrase$phraseIntentClassificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhraseIntentClassificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    phraseScores<T extends Phrase$phraseScoresArgs<ExtArgs> = {}>(args?: Subset<T, Phrase$phraseScoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhraseScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Phrase model
   */
  interface PhraseFieldRefs {
    readonly id: FieldRef<"Phrase", 'Int'>
    readonly text: FieldRef<"Phrase", 'String'>
    readonly keywordId: FieldRef<"Phrase", 'Int'>
    readonly relevanceScore: FieldRef<"Phrase", 'Int'>
    readonly sources: FieldRef<"Phrase", 'Json'>
    readonly trend: FieldRef<"Phrase", 'String'>
    readonly intent: FieldRef<"Phrase", 'String'>
    readonly confidence: FieldRef<"Phrase", 'Int'>
    readonly isSelected: FieldRef<"Phrase", 'Boolean'>
    readonly createdAt: FieldRef<"Phrase", 'DateTime'>
    readonly updatedAt: FieldRef<"Phrase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Phrase findUnique
   */
  export type PhraseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phrase
     */
    select?: PhraseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phrase
     */
    omit?: PhraseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseInclude<ExtArgs> | null
    /**
     * Filter, which Phrase to fetch.
     */
    where: PhraseWhereUniqueInput
  }

  /**
   * Phrase findUniqueOrThrow
   */
  export type PhraseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phrase
     */
    select?: PhraseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phrase
     */
    omit?: PhraseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseInclude<ExtArgs> | null
    /**
     * Filter, which Phrase to fetch.
     */
    where: PhraseWhereUniqueInput
  }

  /**
   * Phrase findFirst
   */
  export type PhraseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phrase
     */
    select?: PhraseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phrase
     */
    omit?: PhraseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseInclude<ExtArgs> | null
    /**
     * Filter, which Phrase to fetch.
     */
    where?: PhraseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phrases to fetch.
     */
    orderBy?: PhraseOrderByWithRelationInput | PhraseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Phrases.
     */
    cursor?: PhraseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phrases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phrases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Phrases.
     */
    distinct?: PhraseScalarFieldEnum | PhraseScalarFieldEnum[]
  }

  /**
   * Phrase findFirstOrThrow
   */
  export type PhraseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phrase
     */
    select?: PhraseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phrase
     */
    omit?: PhraseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseInclude<ExtArgs> | null
    /**
     * Filter, which Phrase to fetch.
     */
    where?: PhraseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phrases to fetch.
     */
    orderBy?: PhraseOrderByWithRelationInput | PhraseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Phrases.
     */
    cursor?: PhraseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phrases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phrases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Phrases.
     */
    distinct?: PhraseScalarFieldEnum | PhraseScalarFieldEnum[]
  }

  /**
   * Phrase findMany
   */
  export type PhraseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phrase
     */
    select?: PhraseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phrase
     */
    omit?: PhraseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseInclude<ExtArgs> | null
    /**
     * Filter, which Phrases to fetch.
     */
    where?: PhraseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phrases to fetch.
     */
    orderBy?: PhraseOrderByWithRelationInput | PhraseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Phrases.
     */
    cursor?: PhraseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phrases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phrases.
     */
    skip?: number
    distinct?: PhraseScalarFieldEnum | PhraseScalarFieldEnum[]
  }

  /**
   * Phrase create
   */
  export type PhraseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phrase
     */
    select?: PhraseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phrase
     */
    omit?: PhraseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseInclude<ExtArgs> | null
    /**
     * The data needed to create a Phrase.
     */
    data: XOR<PhraseCreateInput, PhraseUncheckedCreateInput>
  }

  /**
   * Phrase createMany
   */
  export type PhraseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Phrases.
     */
    data: PhraseCreateManyInput | PhraseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Phrase createManyAndReturn
   */
  export type PhraseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phrase
     */
    select?: PhraseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Phrase
     */
    omit?: PhraseOmit<ExtArgs> | null
    /**
     * The data used to create many Phrases.
     */
    data: PhraseCreateManyInput | PhraseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Phrase update
   */
  export type PhraseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phrase
     */
    select?: PhraseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phrase
     */
    omit?: PhraseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseInclude<ExtArgs> | null
    /**
     * The data needed to update a Phrase.
     */
    data: XOR<PhraseUpdateInput, PhraseUncheckedUpdateInput>
    /**
     * Choose, which Phrase to update.
     */
    where: PhraseWhereUniqueInput
  }

  /**
   * Phrase updateMany
   */
  export type PhraseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Phrases.
     */
    data: XOR<PhraseUpdateManyMutationInput, PhraseUncheckedUpdateManyInput>
    /**
     * Filter which Phrases to update
     */
    where?: PhraseWhereInput
  }

  /**
   * Phrase upsert
   */
  export type PhraseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phrase
     */
    select?: PhraseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phrase
     */
    omit?: PhraseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseInclude<ExtArgs> | null
    /**
     * The filter to search for the Phrase to update in case it exists.
     */
    where: PhraseWhereUniqueInput
    /**
     * In case the Phrase found by the `where` argument doesn't exist, create a new Phrase with this data.
     */
    create: XOR<PhraseCreateInput, PhraseUncheckedCreateInput>
    /**
     * In case the Phrase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhraseUpdateInput, PhraseUncheckedUpdateInput>
  }

  /**
   * Phrase delete
   */
  export type PhraseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phrase
     */
    select?: PhraseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phrase
     */
    omit?: PhraseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseInclude<ExtArgs> | null
    /**
     * Filter which Phrase to delete.
     */
    where: PhraseWhereUniqueInput
  }

  /**
   * Phrase deleteMany
   */
  export type PhraseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Phrases to delete
     */
    where?: PhraseWhereInput
  }

  /**
   * Phrase.phraseIntentClassifications
   */
  export type Phrase$phraseIntentClassificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseIntentClassification
     */
    select?: PhraseIntentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhraseIntentClassification
     */
    omit?: PhraseIntentClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseIntentClassificationInclude<ExtArgs> | null
    where?: PhraseIntentClassificationWhereInput
    orderBy?: PhraseIntentClassificationOrderByWithRelationInput | PhraseIntentClassificationOrderByWithRelationInput[]
    cursor?: PhraseIntentClassificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhraseIntentClassificationScalarFieldEnum | PhraseIntentClassificationScalarFieldEnum[]
  }

  /**
   * Phrase.phraseScores
   */
  export type Phrase$phraseScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseScore
     */
    select?: PhraseScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhraseScore
     */
    omit?: PhraseScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseScoreInclude<ExtArgs> | null
    where?: PhraseScoreWhereInput
    orderBy?: PhraseScoreOrderByWithRelationInput | PhraseScoreOrderByWithRelationInput[]
    cursor?: PhraseScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhraseScoreScalarFieldEnum | PhraseScoreScalarFieldEnum[]
  }

  /**
   * Phrase without action
   */
  export type PhraseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phrase
     */
    select?: PhraseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phrase
     */
    omit?: PhraseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseInclude<ExtArgs> | null
  }


  /**
   * Model AIQueryResult
   */

  export type AggregateAIQueryResult = {
    _count: AIQueryResultCountAggregateOutputType | null
    _avg: AIQueryResultAvgAggregateOutputType | null
    _sum: AIQueryResultSumAggregateOutputType | null
    _min: AIQueryResultMinAggregateOutputType | null
    _max: AIQueryResultMaxAggregateOutputType | null
  }

  export type AIQueryResultAvgAggregateOutputType = {
    id: number | null
    phraseId: number | null
    latency: number | null
    cost: number | null
    presence: number | null
    relevance: number | null
    accuracy: number | null
    sentiment: number | null
    overall: number | null
  }

  export type AIQueryResultSumAggregateOutputType = {
    id: number | null
    phraseId: number | null
    latency: number | null
    cost: number | null
    presence: number | null
    relevance: number | null
    accuracy: number | null
    sentiment: number | null
    overall: number | null
  }

  export type AIQueryResultMinAggregateOutputType = {
    id: number | null
    phraseId: number | null
    model: string | null
    response: string | null
    latency: number | null
    cost: number | null
    presence: number | null
    relevance: number | null
    accuracy: number | null
    sentiment: number | null
    overall: number | null
    createdAt: Date | null
  }

  export type AIQueryResultMaxAggregateOutputType = {
    id: number | null
    phraseId: number | null
    model: string | null
    response: string | null
    latency: number | null
    cost: number | null
    presence: number | null
    relevance: number | null
    accuracy: number | null
    sentiment: number | null
    overall: number | null
    createdAt: Date | null
  }

  export type AIQueryResultCountAggregateOutputType = {
    id: number
    phraseId: number
    model: number
    response: number
    latency: number
    cost: number
    presence: number
    relevance: number
    accuracy: number
    sentiment: number
    overall: number
    createdAt: number
    _all: number
  }


  export type AIQueryResultAvgAggregateInputType = {
    id?: true
    phraseId?: true
    latency?: true
    cost?: true
    presence?: true
    relevance?: true
    accuracy?: true
    sentiment?: true
    overall?: true
  }

  export type AIQueryResultSumAggregateInputType = {
    id?: true
    phraseId?: true
    latency?: true
    cost?: true
    presence?: true
    relevance?: true
    accuracy?: true
    sentiment?: true
    overall?: true
  }

  export type AIQueryResultMinAggregateInputType = {
    id?: true
    phraseId?: true
    model?: true
    response?: true
    latency?: true
    cost?: true
    presence?: true
    relevance?: true
    accuracy?: true
    sentiment?: true
    overall?: true
    createdAt?: true
  }

  export type AIQueryResultMaxAggregateInputType = {
    id?: true
    phraseId?: true
    model?: true
    response?: true
    latency?: true
    cost?: true
    presence?: true
    relevance?: true
    accuracy?: true
    sentiment?: true
    overall?: true
    createdAt?: true
  }

  export type AIQueryResultCountAggregateInputType = {
    id?: true
    phraseId?: true
    model?: true
    response?: true
    latency?: true
    cost?: true
    presence?: true
    relevance?: true
    accuracy?: true
    sentiment?: true
    overall?: true
    createdAt?: true
    _all?: true
  }

  export type AIQueryResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIQueryResult to aggregate.
     */
    where?: AIQueryResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIQueryResults to fetch.
     */
    orderBy?: AIQueryResultOrderByWithRelationInput | AIQueryResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIQueryResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIQueryResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIQueryResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIQueryResults
    **/
    _count?: true | AIQueryResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIQueryResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIQueryResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIQueryResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIQueryResultMaxAggregateInputType
  }

  export type GetAIQueryResultAggregateType<T extends AIQueryResultAggregateArgs> = {
        [P in keyof T & keyof AggregateAIQueryResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIQueryResult[P]>
      : GetScalarType<T[P], AggregateAIQueryResult[P]>
  }




  export type AIQueryResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIQueryResultWhereInput
    orderBy?: AIQueryResultOrderByWithAggregationInput | AIQueryResultOrderByWithAggregationInput[]
    by: AIQueryResultScalarFieldEnum[] | AIQueryResultScalarFieldEnum
    having?: AIQueryResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIQueryResultCountAggregateInputType | true
    _avg?: AIQueryResultAvgAggregateInputType
    _sum?: AIQueryResultSumAggregateInputType
    _min?: AIQueryResultMinAggregateInputType
    _max?: AIQueryResultMaxAggregateInputType
  }

  export type AIQueryResultGroupByOutputType = {
    id: number
    phraseId: number
    model: string
    response: string
    latency: number
    cost: number
    presence: number
    relevance: number
    accuracy: number
    sentiment: number
    overall: number
    createdAt: Date
    _count: AIQueryResultCountAggregateOutputType | null
    _avg: AIQueryResultAvgAggregateOutputType | null
    _sum: AIQueryResultSumAggregateOutputType | null
    _min: AIQueryResultMinAggregateOutputType | null
    _max: AIQueryResultMaxAggregateOutputType | null
  }

  type GetAIQueryResultGroupByPayload<T extends AIQueryResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIQueryResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIQueryResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIQueryResultGroupByOutputType[P]>
            : GetScalarType<T[P], AIQueryResultGroupByOutputType[P]>
        }
      >
    >


  export type AIQueryResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phraseId?: boolean
    model?: boolean
    response?: boolean
    latency?: boolean
    cost?: boolean
    presence?: boolean
    relevance?: boolean
    accuracy?: boolean
    sentiment?: boolean
    overall?: boolean
    createdAt?: boolean
    phrase?: boolean | GeneratedIntentPhraseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIQueryResult"]>

  export type AIQueryResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phraseId?: boolean
    model?: boolean
    response?: boolean
    latency?: boolean
    cost?: boolean
    presence?: boolean
    relevance?: boolean
    accuracy?: boolean
    sentiment?: boolean
    overall?: boolean
    createdAt?: boolean
    phrase?: boolean | GeneratedIntentPhraseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIQueryResult"]>


  export type AIQueryResultSelectScalar = {
    id?: boolean
    phraseId?: boolean
    model?: boolean
    response?: boolean
    latency?: boolean
    cost?: boolean
    presence?: boolean
    relevance?: boolean
    accuracy?: boolean
    sentiment?: boolean
    overall?: boolean
    createdAt?: boolean
  }

  export type AIQueryResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phraseId" | "model" | "response" | "latency" | "cost" | "presence" | "relevance" | "accuracy" | "sentiment" | "overall" | "createdAt", ExtArgs["result"]["aIQueryResult"]>
  export type AIQueryResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phrase?: boolean | GeneratedIntentPhraseDefaultArgs<ExtArgs>
  }
  export type AIQueryResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phrase?: boolean | GeneratedIntentPhraseDefaultArgs<ExtArgs>
  }

  export type $AIQueryResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIQueryResult"
    objects: {
      phrase: Prisma.$GeneratedIntentPhrasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      phraseId: number
      model: string
      response: string
      latency: number
      cost: number
      presence: number
      relevance: number
      accuracy: number
      sentiment: number
      overall: number
      createdAt: Date
    }, ExtArgs["result"]["aIQueryResult"]>
    composites: {}
  }

  type AIQueryResultGetPayload<S extends boolean | null | undefined | AIQueryResultDefaultArgs> = $Result.GetResult<Prisma.$AIQueryResultPayload, S>

  type AIQueryResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIQueryResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIQueryResultCountAggregateInputType | true
    }

  export interface AIQueryResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIQueryResult'], meta: { name: 'AIQueryResult' } }
    /**
     * Find zero or one AIQueryResult that matches the filter.
     * @param {AIQueryResultFindUniqueArgs} args - Arguments to find a AIQueryResult
     * @example
     * // Get one AIQueryResult
     * const aIQueryResult = await prisma.aIQueryResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIQueryResultFindUniqueArgs>(args: SelectSubset<T, AIQueryResultFindUniqueArgs<ExtArgs>>): Prisma__AIQueryResultClient<$Result.GetResult<Prisma.$AIQueryResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIQueryResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIQueryResultFindUniqueOrThrowArgs} args - Arguments to find a AIQueryResult
     * @example
     * // Get one AIQueryResult
     * const aIQueryResult = await prisma.aIQueryResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIQueryResultFindUniqueOrThrowArgs>(args: SelectSubset<T, AIQueryResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIQueryResultClient<$Result.GetResult<Prisma.$AIQueryResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIQueryResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIQueryResultFindFirstArgs} args - Arguments to find a AIQueryResult
     * @example
     * // Get one AIQueryResult
     * const aIQueryResult = await prisma.aIQueryResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIQueryResultFindFirstArgs>(args?: SelectSubset<T, AIQueryResultFindFirstArgs<ExtArgs>>): Prisma__AIQueryResultClient<$Result.GetResult<Prisma.$AIQueryResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIQueryResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIQueryResultFindFirstOrThrowArgs} args - Arguments to find a AIQueryResult
     * @example
     * // Get one AIQueryResult
     * const aIQueryResult = await prisma.aIQueryResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIQueryResultFindFirstOrThrowArgs>(args?: SelectSubset<T, AIQueryResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIQueryResultClient<$Result.GetResult<Prisma.$AIQueryResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIQueryResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIQueryResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIQueryResults
     * const aIQueryResults = await prisma.aIQueryResult.findMany()
     * 
     * // Get first 10 AIQueryResults
     * const aIQueryResults = await prisma.aIQueryResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIQueryResultWithIdOnly = await prisma.aIQueryResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIQueryResultFindManyArgs>(args?: SelectSubset<T, AIQueryResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIQueryResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIQueryResult.
     * @param {AIQueryResultCreateArgs} args - Arguments to create a AIQueryResult.
     * @example
     * // Create one AIQueryResult
     * const AIQueryResult = await prisma.aIQueryResult.create({
     *   data: {
     *     // ... data to create a AIQueryResult
     *   }
     * })
     * 
     */
    create<T extends AIQueryResultCreateArgs>(args: SelectSubset<T, AIQueryResultCreateArgs<ExtArgs>>): Prisma__AIQueryResultClient<$Result.GetResult<Prisma.$AIQueryResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIQueryResults.
     * @param {AIQueryResultCreateManyArgs} args - Arguments to create many AIQueryResults.
     * @example
     * // Create many AIQueryResults
     * const aIQueryResult = await prisma.aIQueryResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIQueryResultCreateManyArgs>(args?: SelectSubset<T, AIQueryResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIQueryResults and returns the data saved in the database.
     * @param {AIQueryResultCreateManyAndReturnArgs} args - Arguments to create many AIQueryResults.
     * @example
     * // Create many AIQueryResults
     * const aIQueryResult = await prisma.aIQueryResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIQueryResults and only return the `id`
     * const aIQueryResultWithIdOnly = await prisma.aIQueryResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIQueryResultCreateManyAndReturnArgs>(args?: SelectSubset<T, AIQueryResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIQueryResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIQueryResult.
     * @param {AIQueryResultDeleteArgs} args - Arguments to delete one AIQueryResult.
     * @example
     * // Delete one AIQueryResult
     * const AIQueryResult = await prisma.aIQueryResult.delete({
     *   where: {
     *     // ... filter to delete one AIQueryResult
     *   }
     * })
     * 
     */
    delete<T extends AIQueryResultDeleteArgs>(args: SelectSubset<T, AIQueryResultDeleteArgs<ExtArgs>>): Prisma__AIQueryResultClient<$Result.GetResult<Prisma.$AIQueryResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIQueryResult.
     * @param {AIQueryResultUpdateArgs} args - Arguments to update one AIQueryResult.
     * @example
     * // Update one AIQueryResult
     * const aIQueryResult = await prisma.aIQueryResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIQueryResultUpdateArgs>(args: SelectSubset<T, AIQueryResultUpdateArgs<ExtArgs>>): Prisma__AIQueryResultClient<$Result.GetResult<Prisma.$AIQueryResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIQueryResults.
     * @param {AIQueryResultDeleteManyArgs} args - Arguments to filter AIQueryResults to delete.
     * @example
     * // Delete a few AIQueryResults
     * const { count } = await prisma.aIQueryResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIQueryResultDeleteManyArgs>(args?: SelectSubset<T, AIQueryResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIQueryResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIQueryResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIQueryResults
     * const aIQueryResult = await prisma.aIQueryResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIQueryResultUpdateManyArgs>(args: SelectSubset<T, AIQueryResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AIQueryResult.
     * @param {AIQueryResultUpsertArgs} args - Arguments to update or create a AIQueryResult.
     * @example
     * // Update or create a AIQueryResult
     * const aIQueryResult = await prisma.aIQueryResult.upsert({
     *   create: {
     *     // ... data to create a AIQueryResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIQueryResult we want to update
     *   }
     * })
     */
    upsert<T extends AIQueryResultUpsertArgs>(args: SelectSubset<T, AIQueryResultUpsertArgs<ExtArgs>>): Prisma__AIQueryResultClient<$Result.GetResult<Prisma.$AIQueryResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIQueryResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIQueryResultCountArgs} args - Arguments to filter AIQueryResults to count.
     * @example
     * // Count the number of AIQueryResults
     * const count = await prisma.aIQueryResult.count({
     *   where: {
     *     // ... the filter for the AIQueryResults we want to count
     *   }
     * })
    **/
    count<T extends AIQueryResultCountArgs>(
      args?: Subset<T, AIQueryResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIQueryResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIQueryResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIQueryResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIQueryResultAggregateArgs>(args: Subset<T, AIQueryResultAggregateArgs>): Prisma.PrismaPromise<GetAIQueryResultAggregateType<T>>

    /**
     * Group by AIQueryResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIQueryResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIQueryResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIQueryResultGroupByArgs['orderBy'] }
        : { orderBy?: AIQueryResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIQueryResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIQueryResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIQueryResult model
   */
  readonly fields: AIQueryResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIQueryResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIQueryResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    phrase<T extends GeneratedIntentPhraseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedIntentPhraseDefaultArgs<ExtArgs>>): Prisma__GeneratedIntentPhraseClient<$Result.GetResult<Prisma.$GeneratedIntentPhrasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIQueryResult model
   */
  interface AIQueryResultFieldRefs {
    readonly id: FieldRef<"AIQueryResult", 'Int'>
    readonly phraseId: FieldRef<"AIQueryResult", 'Int'>
    readonly model: FieldRef<"AIQueryResult", 'String'>
    readonly response: FieldRef<"AIQueryResult", 'String'>
    readonly latency: FieldRef<"AIQueryResult", 'Float'>
    readonly cost: FieldRef<"AIQueryResult", 'Float'>
    readonly presence: FieldRef<"AIQueryResult", 'Int'>
    readonly relevance: FieldRef<"AIQueryResult", 'Int'>
    readonly accuracy: FieldRef<"AIQueryResult", 'Int'>
    readonly sentiment: FieldRef<"AIQueryResult", 'Int'>
    readonly overall: FieldRef<"AIQueryResult", 'Float'>
    readonly createdAt: FieldRef<"AIQueryResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIQueryResult findUnique
   */
  export type AIQueryResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIQueryResult
     */
    select?: AIQueryResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIQueryResult
     */
    omit?: AIQueryResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIQueryResultInclude<ExtArgs> | null
    /**
     * Filter, which AIQueryResult to fetch.
     */
    where: AIQueryResultWhereUniqueInput
  }

  /**
   * AIQueryResult findUniqueOrThrow
   */
  export type AIQueryResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIQueryResult
     */
    select?: AIQueryResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIQueryResult
     */
    omit?: AIQueryResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIQueryResultInclude<ExtArgs> | null
    /**
     * Filter, which AIQueryResult to fetch.
     */
    where: AIQueryResultWhereUniqueInput
  }

  /**
   * AIQueryResult findFirst
   */
  export type AIQueryResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIQueryResult
     */
    select?: AIQueryResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIQueryResult
     */
    omit?: AIQueryResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIQueryResultInclude<ExtArgs> | null
    /**
     * Filter, which AIQueryResult to fetch.
     */
    where?: AIQueryResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIQueryResults to fetch.
     */
    orderBy?: AIQueryResultOrderByWithRelationInput | AIQueryResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIQueryResults.
     */
    cursor?: AIQueryResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIQueryResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIQueryResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIQueryResults.
     */
    distinct?: AIQueryResultScalarFieldEnum | AIQueryResultScalarFieldEnum[]
  }

  /**
   * AIQueryResult findFirstOrThrow
   */
  export type AIQueryResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIQueryResult
     */
    select?: AIQueryResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIQueryResult
     */
    omit?: AIQueryResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIQueryResultInclude<ExtArgs> | null
    /**
     * Filter, which AIQueryResult to fetch.
     */
    where?: AIQueryResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIQueryResults to fetch.
     */
    orderBy?: AIQueryResultOrderByWithRelationInput | AIQueryResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIQueryResults.
     */
    cursor?: AIQueryResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIQueryResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIQueryResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIQueryResults.
     */
    distinct?: AIQueryResultScalarFieldEnum | AIQueryResultScalarFieldEnum[]
  }

  /**
   * AIQueryResult findMany
   */
  export type AIQueryResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIQueryResult
     */
    select?: AIQueryResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIQueryResult
     */
    omit?: AIQueryResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIQueryResultInclude<ExtArgs> | null
    /**
     * Filter, which AIQueryResults to fetch.
     */
    where?: AIQueryResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIQueryResults to fetch.
     */
    orderBy?: AIQueryResultOrderByWithRelationInput | AIQueryResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIQueryResults.
     */
    cursor?: AIQueryResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIQueryResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIQueryResults.
     */
    skip?: number
    distinct?: AIQueryResultScalarFieldEnum | AIQueryResultScalarFieldEnum[]
  }

  /**
   * AIQueryResult create
   */
  export type AIQueryResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIQueryResult
     */
    select?: AIQueryResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIQueryResult
     */
    omit?: AIQueryResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIQueryResultInclude<ExtArgs> | null
    /**
     * The data needed to create a AIQueryResult.
     */
    data: XOR<AIQueryResultCreateInput, AIQueryResultUncheckedCreateInput>
  }

  /**
   * AIQueryResult createMany
   */
  export type AIQueryResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIQueryResults.
     */
    data: AIQueryResultCreateManyInput | AIQueryResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIQueryResult createManyAndReturn
   */
  export type AIQueryResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIQueryResult
     */
    select?: AIQueryResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIQueryResult
     */
    omit?: AIQueryResultOmit<ExtArgs> | null
    /**
     * The data used to create many AIQueryResults.
     */
    data: AIQueryResultCreateManyInput | AIQueryResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIQueryResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIQueryResult update
   */
  export type AIQueryResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIQueryResult
     */
    select?: AIQueryResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIQueryResult
     */
    omit?: AIQueryResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIQueryResultInclude<ExtArgs> | null
    /**
     * The data needed to update a AIQueryResult.
     */
    data: XOR<AIQueryResultUpdateInput, AIQueryResultUncheckedUpdateInput>
    /**
     * Choose, which AIQueryResult to update.
     */
    where: AIQueryResultWhereUniqueInput
  }

  /**
   * AIQueryResult updateMany
   */
  export type AIQueryResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIQueryResults.
     */
    data: XOR<AIQueryResultUpdateManyMutationInput, AIQueryResultUncheckedUpdateManyInput>
    /**
     * Filter which AIQueryResults to update
     */
    where?: AIQueryResultWhereInput
  }

  /**
   * AIQueryResult upsert
   */
  export type AIQueryResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIQueryResult
     */
    select?: AIQueryResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIQueryResult
     */
    omit?: AIQueryResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIQueryResultInclude<ExtArgs> | null
    /**
     * The filter to search for the AIQueryResult to update in case it exists.
     */
    where: AIQueryResultWhereUniqueInput
    /**
     * In case the AIQueryResult found by the `where` argument doesn't exist, create a new AIQueryResult with this data.
     */
    create: XOR<AIQueryResultCreateInput, AIQueryResultUncheckedCreateInput>
    /**
     * In case the AIQueryResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIQueryResultUpdateInput, AIQueryResultUncheckedUpdateInput>
  }

  /**
   * AIQueryResult delete
   */
  export type AIQueryResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIQueryResult
     */
    select?: AIQueryResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIQueryResult
     */
    omit?: AIQueryResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIQueryResultInclude<ExtArgs> | null
    /**
     * Filter which AIQueryResult to delete.
     */
    where: AIQueryResultWhereUniqueInput
  }

  /**
   * AIQueryResult deleteMany
   */
  export type AIQueryResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIQueryResults to delete
     */
    where?: AIQueryResultWhereInput
  }

  /**
   * AIQueryResult without action
   */
  export type AIQueryResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIQueryResult
     */
    select?: AIQueryResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIQueryResult
     */
    omit?: AIQueryResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIQueryResultInclude<ExtArgs> | null
  }


  /**
   * Model DashboardAnalysis
   */

  export type AggregateDashboardAnalysis = {
    _count: DashboardAnalysisCountAggregateOutputType | null
    _avg: DashboardAnalysisAvgAggregateOutputType | null
    _sum: DashboardAnalysisSumAggregateOutputType | null
    _min: DashboardAnalysisMinAggregateOutputType | null
    _max: DashboardAnalysisMaxAggregateOutputType | null
  }

  export type DashboardAnalysisAvgAggregateOutputType = {
    id: number | null
    domainId: number | null
  }

  export type DashboardAnalysisSumAggregateOutputType = {
    id: number | null
    domainId: number | null
  }

  export type DashboardAnalysisMinAggregateOutputType = {
    id: number | null
    domainId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DashboardAnalysisMaxAggregateOutputType = {
    id: number | null
    domainId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DashboardAnalysisCountAggregateOutputType = {
    id: number
    domainId: number
    metrics: number
    insights: number
    industryAnalysis: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DashboardAnalysisAvgAggregateInputType = {
    id?: true
    domainId?: true
  }

  export type DashboardAnalysisSumAggregateInputType = {
    id?: true
    domainId?: true
  }

  export type DashboardAnalysisMinAggregateInputType = {
    id?: true
    domainId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DashboardAnalysisMaxAggregateInputType = {
    id?: true
    domainId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DashboardAnalysisCountAggregateInputType = {
    id?: true
    domainId?: true
    metrics?: true
    insights?: true
    industryAnalysis?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DashboardAnalysisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DashboardAnalysis to aggregate.
     */
    where?: DashboardAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardAnalyses to fetch.
     */
    orderBy?: DashboardAnalysisOrderByWithRelationInput | DashboardAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DashboardAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DashboardAnalyses
    **/
    _count?: true | DashboardAnalysisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DashboardAnalysisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DashboardAnalysisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DashboardAnalysisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DashboardAnalysisMaxAggregateInputType
  }

  export type GetDashboardAnalysisAggregateType<T extends DashboardAnalysisAggregateArgs> = {
        [P in keyof T & keyof AggregateDashboardAnalysis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDashboardAnalysis[P]>
      : GetScalarType<T[P], AggregateDashboardAnalysis[P]>
  }




  export type DashboardAnalysisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DashboardAnalysisWhereInput
    orderBy?: DashboardAnalysisOrderByWithAggregationInput | DashboardAnalysisOrderByWithAggregationInput[]
    by: DashboardAnalysisScalarFieldEnum[] | DashboardAnalysisScalarFieldEnum
    having?: DashboardAnalysisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DashboardAnalysisCountAggregateInputType | true
    _avg?: DashboardAnalysisAvgAggregateInputType
    _sum?: DashboardAnalysisSumAggregateInputType
    _min?: DashboardAnalysisMinAggregateInputType
    _max?: DashboardAnalysisMaxAggregateInputType
  }

  export type DashboardAnalysisGroupByOutputType = {
    id: number
    domainId: number | null
    metrics: JsonValue
    insights: JsonValue
    industryAnalysis: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: DashboardAnalysisCountAggregateOutputType | null
    _avg: DashboardAnalysisAvgAggregateOutputType | null
    _sum: DashboardAnalysisSumAggregateOutputType | null
    _min: DashboardAnalysisMinAggregateOutputType | null
    _max: DashboardAnalysisMaxAggregateOutputType | null
  }

  type GetDashboardAnalysisGroupByPayload<T extends DashboardAnalysisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DashboardAnalysisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DashboardAnalysisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DashboardAnalysisGroupByOutputType[P]>
            : GetScalarType<T[P], DashboardAnalysisGroupByOutputType[P]>
        }
      >
    >


  export type DashboardAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    metrics?: boolean
    insights?: boolean
    industryAnalysis?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domain?: boolean | DashboardAnalysis$domainArgs<ExtArgs>
  }, ExtArgs["result"]["dashboardAnalysis"]>

  export type DashboardAnalysisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    metrics?: boolean
    insights?: boolean
    industryAnalysis?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domain?: boolean | DashboardAnalysis$domainArgs<ExtArgs>
  }, ExtArgs["result"]["dashboardAnalysis"]>


  export type DashboardAnalysisSelectScalar = {
    id?: boolean
    domainId?: boolean
    metrics?: boolean
    insights?: boolean
    industryAnalysis?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DashboardAnalysisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "domainId" | "metrics" | "insights" | "industryAnalysis" | "createdAt" | "updatedAt", ExtArgs["result"]["dashboardAnalysis"]>
  export type DashboardAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | DashboardAnalysis$domainArgs<ExtArgs>
  }
  export type DashboardAnalysisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | DashboardAnalysis$domainArgs<ExtArgs>
  }

  export type $DashboardAnalysisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DashboardAnalysis"
    objects: {
      domain: Prisma.$DomainPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      domainId: number | null
      metrics: Prisma.JsonValue
      insights: Prisma.JsonValue
      industryAnalysis: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dashboardAnalysis"]>
    composites: {}
  }

  type DashboardAnalysisGetPayload<S extends boolean | null | undefined | DashboardAnalysisDefaultArgs> = $Result.GetResult<Prisma.$DashboardAnalysisPayload, S>

  type DashboardAnalysisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DashboardAnalysisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DashboardAnalysisCountAggregateInputType | true
    }

  export interface DashboardAnalysisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DashboardAnalysis'], meta: { name: 'DashboardAnalysis' } }
    /**
     * Find zero or one DashboardAnalysis that matches the filter.
     * @param {DashboardAnalysisFindUniqueArgs} args - Arguments to find a DashboardAnalysis
     * @example
     * // Get one DashboardAnalysis
     * const dashboardAnalysis = await prisma.dashboardAnalysis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DashboardAnalysisFindUniqueArgs>(args: SelectSubset<T, DashboardAnalysisFindUniqueArgs<ExtArgs>>): Prisma__DashboardAnalysisClient<$Result.GetResult<Prisma.$DashboardAnalysisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DashboardAnalysis that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DashboardAnalysisFindUniqueOrThrowArgs} args - Arguments to find a DashboardAnalysis
     * @example
     * // Get one DashboardAnalysis
     * const dashboardAnalysis = await prisma.dashboardAnalysis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DashboardAnalysisFindUniqueOrThrowArgs>(args: SelectSubset<T, DashboardAnalysisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DashboardAnalysisClient<$Result.GetResult<Prisma.$DashboardAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DashboardAnalysis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardAnalysisFindFirstArgs} args - Arguments to find a DashboardAnalysis
     * @example
     * // Get one DashboardAnalysis
     * const dashboardAnalysis = await prisma.dashboardAnalysis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DashboardAnalysisFindFirstArgs>(args?: SelectSubset<T, DashboardAnalysisFindFirstArgs<ExtArgs>>): Prisma__DashboardAnalysisClient<$Result.GetResult<Prisma.$DashboardAnalysisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DashboardAnalysis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardAnalysisFindFirstOrThrowArgs} args - Arguments to find a DashboardAnalysis
     * @example
     * // Get one DashboardAnalysis
     * const dashboardAnalysis = await prisma.dashboardAnalysis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DashboardAnalysisFindFirstOrThrowArgs>(args?: SelectSubset<T, DashboardAnalysisFindFirstOrThrowArgs<ExtArgs>>): Prisma__DashboardAnalysisClient<$Result.GetResult<Prisma.$DashboardAnalysisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DashboardAnalyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardAnalysisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DashboardAnalyses
     * const dashboardAnalyses = await prisma.dashboardAnalysis.findMany()
     * 
     * // Get first 10 DashboardAnalyses
     * const dashboardAnalyses = await prisma.dashboardAnalysis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dashboardAnalysisWithIdOnly = await prisma.dashboardAnalysis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DashboardAnalysisFindManyArgs>(args?: SelectSubset<T, DashboardAnalysisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DashboardAnalysis.
     * @param {DashboardAnalysisCreateArgs} args - Arguments to create a DashboardAnalysis.
     * @example
     * // Create one DashboardAnalysis
     * const DashboardAnalysis = await prisma.dashboardAnalysis.create({
     *   data: {
     *     // ... data to create a DashboardAnalysis
     *   }
     * })
     * 
     */
    create<T extends DashboardAnalysisCreateArgs>(args: SelectSubset<T, DashboardAnalysisCreateArgs<ExtArgs>>): Prisma__DashboardAnalysisClient<$Result.GetResult<Prisma.$DashboardAnalysisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DashboardAnalyses.
     * @param {DashboardAnalysisCreateManyArgs} args - Arguments to create many DashboardAnalyses.
     * @example
     * // Create many DashboardAnalyses
     * const dashboardAnalysis = await prisma.dashboardAnalysis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DashboardAnalysisCreateManyArgs>(args?: SelectSubset<T, DashboardAnalysisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DashboardAnalyses and returns the data saved in the database.
     * @param {DashboardAnalysisCreateManyAndReturnArgs} args - Arguments to create many DashboardAnalyses.
     * @example
     * // Create many DashboardAnalyses
     * const dashboardAnalysis = await prisma.dashboardAnalysis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DashboardAnalyses and only return the `id`
     * const dashboardAnalysisWithIdOnly = await prisma.dashboardAnalysis.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DashboardAnalysisCreateManyAndReturnArgs>(args?: SelectSubset<T, DashboardAnalysisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardAnalysisPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DashboardAnalysis.
     * @param {DashboardAnalysisDeleteArgs} args - Arguments to delete one DashboardAnalysis.
     * @example
     * // Delete one DashboardAnalysis
     * const DashboardAnalysis = await prisma.dashboardAnalysis.delete({
     *   where: {
     *     // ... filter to delete one DashboardAnalysis
     *   }
     * })
     * 
     */
    delete<T extends DashboardAnalysisDeleteArgs>(args: SelectSubset<T, DashboardAnalysisDeleteArgs<ExtArgs>>): Prisma__DashboardAnalysisClient<$Result.GetResult<Prisma.$DashboardAnalysisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DashboardAnalysis.
     * @param {DashboardAnalysisUpdateArgs} args - Arguments to update one DashboardAnalysis.
     * @example
     * // Update one DashboardAnalysis
     * const dashboardAnalysis = await prisma.dashboardAnalysis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DashboardAnalysisUpdateArgs>(args: SelectSubset<T, DashboardAnalysisUpdateArgs<ExtArgs>>): Prisma__DashboardAnalysisClient<$Result.GetResult<Prisma.$DashboardAnalysisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DashboardAnalyses.
     * @param {DashboardAnalysisDeleteManyArgs} args - Arguments to filter DashboardAnalyses to delete.
     * @example
     * // Delete a few DashboardAnalyses
     * const { count } = await prisma.dashboardAnalysis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DashboardAnalysisDeleteManyArgs>(args?: SelectSubset<T, DashboardAnalysisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DashboardAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardAnalysisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DashboardAnalyses
     * const dashboardAnalysis = await prisma.dashboardAnalysis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DashboardAnalysisUpdateManyArgs>(args: SelectSubset<T, DashboardAnalysisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DashboardAnalysis.
     * @param {DashboardAnalysisUpsertArgs} args - Arguments to update or create a DashboardAnalysis.
     * @example
     * // Update or create a DashboardAnalysis
     * const dashboardAnalysis = await prisma.dashboardAnalysis.upsert({
     *   create: {
     *     // ... data to create a DashboardAnalysis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DashboardAnalysis we want to update
     *   }
     * })
     */
    upsert<T extends DashboardAnalysisUpsertArgs>(args: SelectSubset<T, DashboardAnalysisUpsertArgs<ExtArgs>>): Prisma__DashboardAnalysisClient<$Result.GetResult<Prisma.$DashboardAnalysisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DashboardAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardAnalysisCountArgs} args - Arguments to filter DashboardAnalyses to count.
     * @example
     * // Count the number of DashboardAnalyses
     * const count = await prisma.dashboardAnalysis.count({
     *   where: {
     *     // ... the filter for the DashboardAnalyses we want to count
     *   }
     * })
    **/
    count<T extends DashboardAnalysisCountArgs>(
      args?: Subset<T, DashboardAnalysisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DashboardAnalysisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DashboardAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardAnalysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DashboardAnalysisAggregateArgs>(args: Subset<T, DashboardAnalysisAggregateArgs>): Prisma.PrismaPromise<GetDashboardAnalysisAggregateType<T>>

    /**
     * Group by DashboardAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardAnalysisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DashboardAnalysisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DashboardAnalysisGroupByArgs['orderBy'] }
        : { orderBy?: DashboardAnalysisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DashboardAnalysisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDashboardAnalysisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DashboardAnalysis model
   */
  readonly fields: DashboardAnalysisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DashboardAnalysis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DashboardAnalysisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domain<T extends DashboardAnalysis$domainArgs<ExtArgs> = {}>(args?: Subset<T, DashboardAnalysis$domainArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DashboardAnalysis model
   */
  interface DashboardAnalysisFieldRefs {
    readonly id: FieldRef<"DashboardAnalysis", 'Int'>
    readonly domainId: FieldRef<"DashboardAnalysis", 'Int'>
    readonly metrics: FieldRef<"DashboardAnalysis", 'Json'>
    readonly insights: FieldRef<"DashboardAnalysis", 'Json'>
    readonly industryAnalysis: FieldRef<"DashboardAnalysis", 'Json'>
    readonly createdAt: FieldRef<"DashboardAnalysis", 'DateTime'>
    readonly updatedAt: FieldRef<"DashboardAnalysis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DashboardAnalysis findUnique
   */
  export type DashboardAnalysisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardAnalysis
     */
    select?: DashboardAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardAnalysis
     */
    omit?: DashboardAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which DashboardAnalysis to fetch.
     */
    where: DashboardAnalysisWhereUniqueInput
  }

  /**
   * DashboardAnalysis findUniqueOrThrow
   */
  export type DashboardAnalysisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardAnalysis
     */
    select?: DashboardAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardAnalysis
     */
    omit?: DashboardAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which DashboardAnalysis to fetch.
     */
    where: DashboardAnalysisWhereUniqueInput
  }

  /**
   * DashboardAnalysis findFirst
   */
  export type DashboardAnalysisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardAnalysis
     */
    select?: DashboardAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardAnalysis
     */
    omit?: DashboardAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which DashboardAnalysis to fetch.
     */
    where?: DashboardAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardAnalyses to fetch.
     */
    orderBy?: DashboardAnalysisOrderByWithRelationInput | DashboardAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardAnalyses.
     */
    cursor?: DashboardAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardAnalyses.
     */
    distinct?: DashboardAnalysisScalarFieldEnum | DashboardAnalysisScalarFieldEnum[]
  }

  /**
   * DashboardAnalysis findFirstOrThrow
   */
  export type DashboardAnalysisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardAnalysis
     */
    select?: DashboardAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardAnalysis
     */
    omit?: DashboardAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which DashboardAnalysis to fetch.
     */
    where?: DashboardAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardAnalyses to fetch.
     */
    orderBy?: DashboardAnalysisOrderByWithRelationInput | DashboardAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardAnalyses.
     */
    cursor?: DashboardAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardAnalyses.
     */
    distinct?: DashboardAnalysisScalarFieldEnum | DashboardAnalysisScalarFieldEnum[]
  }

  /**
   * DashboardAnalysis findMany
   */
  export type DashboardAnalysisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardAnalysis
     */
    select?: DashboardAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardAnalysis
     */
    omit?: DashboardAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which DashboardAnalyses to fetch.
     */
    where?: DashboardAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardAnalyses to fetch.
     */
    orderBy?: DashboardAnalysisOrderByWithRelationInput | DashboardAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DashboardAnalyses.
     */
    cursor?: DashboardAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardAnalyses.
     */
    skip?: number
    distinct?: DashboardAnalysisScalarFieldEnum | DashboardAnalysisScalarFieldEnum[]
  }

  /**
   * DashboardAnalysis create
   */
  export type DashboardAnalysisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardAnalysis
     */
    select?: DashboardAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardAnalysis
     */
    omit?: DashboardAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to create a DashboardAnalysis.
     */
    data: XOR<DashboardAnalysisCreateInput, DashboardAnalysisUncheckedCreateInput>
  }

  /**
   * DashboardAnalysis createMany
   */
  export type DashboardAnalysisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DashboardAnalyses.
     */
    data: DashboardAnalysisCreateManyInput | DashboardAnalysisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DashboardAnalysis createManyAndReturn
   */
  export type DashboardAnalysisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardAnalysis
     */
    select?: DashboardAnalysisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardAnalysis
     */
    omit?: DashboardAnalysisOmit<ExtArgs> | null
    /**
     * The data used to create many DashboardAnalyses.
     */
    data: DashboardAnalysisCreateManyInput | DashboardAnalysisCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardAnalysisIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DashboardAnalysis update
   */
  export type DashboardAnalysisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardAnalysis
     */
    select?: DashboardAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardAnalysis
     */
    omit?: DashboardAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to update a DashboardAnalysis.
     */
    data: XOR<DashboardAnalysisUpdateInput, DashboardAnalysisUncheckedUpdateInput>
    /**
     * Choose, which DashboardAnalysis to update.
     */
    where: DashboardAnalysisWhereUniqueInput
  }

  /**
   * DashboardAnalysis updateMany
   */
  export type DashboardAnalysisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DashboardAnalyses.
     */
    data: XOR<DashboardAnalysisUpdateManyMutationInput, DashboardAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which DashboardAnalyses to update
     */
    where?: DashboardAnalysisWhereInput
  }

  /**
   * DashboardAnalysis upsert
   */
  export type DashboardAnalysisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardAnalysis
     */
    select?: DashboardAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardAnalysis
     */
    omit?: DashboardAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardAnalysisInclude<ExtArgs> | null
    /**
     * The filter to search for the DashboardAnalysis to update in case it exists.
     */
    where: DashboardAnalysisWhereUniqueInput
    /**
     * In case the DashboardAnalysis found by the `where` argument doesn't exist, create a new DashboardAnalysis with this data.
     */
    create: XOR<DashboardAnalysisCreateInput, DashboardAnalysisUncheckedCreateInput>
    /**
     * In case the DashboardAnalysis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DashboardAnalysisUpdateInput, DashboardAnalysisUncheckedUpdateInput>
  }

  /**
   * DashboardAnalysis delete
   */
  export type DashboardAnalysisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardAnalysis
     */
    select?: DashboardAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardAnalysis
     */
    omit?: DashboardAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardAnalysisInclude<ExtArgs> | null
    /**
     * Filter which DashboardAnalysis to delete.
     */
    where: DashboardAnalysisWhereUniqueInput
  }

  /**
   * DashboardAnalysis deleteMany
   */
  export type DashboardAnalysisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DashboardAnalyses to delete
     */
    where?: DashboardAnalysisWhereInput
  }

  /**
   * DashboardAnalysis.domain
   */
  export type DashboardAnalysis$domainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    where?: DomainWhereInput
  }

  /**
   * DashboardAnalysis without action
   */
  export type DashboardAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardAnalysis
     */
    select?: DashboardAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardAnalysis
     */
    omit?: DashboardAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model CompetitorAnalysis
   */

  export type AggregateCompetitorAnalysis = {
    _count: CompetitorAnalysisCountAggregateOutputType | null
    _avg: CompetitorAnalysisAvgAggregateOutputType | null
    _sum: CompetitorAnalysisSumAggregateOutputType | null
    _min: CompetitorAnalysisMinAggregateOutputType | null
    _max: CompetitorAnalysisMaxAggregateOutputType | null
  }

  export type CompetitorAnalysisAvgAggregateOutputType = {
    id: number | null
    domainId: number | null
  }

  export type CompetitorAnalysisSumAggregateOutputType = {
    id: number | null
    domainId: number | null
  }

  export type CompetitorAnalysisMinAggregateOutputType = {
    id: number | null
    domainId: number | null
    competitorList: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompetitorAnalysisMaxAggregateOutputType = {
    id: number | null
    domainId: number | null
    competitorList: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompetitorAnalysisCountAggregateOutputType = {
    id: number
    domainId: number
    competitors: number
    marketInsights: number
    strategicRecommendations: number
    competitiveAnalysis: number
    competitorList: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompetitorAnalysisAvgAggregateInputType = {
    id?: true
    domainId?: true
  }

  export type CompetitorAnalysisSumAggregateInputType = {
    id?: true
    domainId?: true
  }

  export type CompetitorAnalysisMinAggregateInputType = {
    id?: true
    domainId?: true
    competitorList?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompetitorAnalysisMaxAggregateInputType = {
    id?: true
    domainId?: true
    competitorList?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompetitorAnalysisCountAggregateInputType = {
    id?: true
    domainId?: true
    competitors?: true
    marketInsights?: true
    strategicRecommendations?: true
    competitiveAnalysis?: true
    competitorList?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompetitorAnalysisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompetitorAnalysis to aggregate.
     */
    where?: CompetitorAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompetitorAnalyses to fetch.
     */
    orderBy?: CompetitorAnalysisOrderByWithRelationInput | CompetitorAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompetitorAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompetitorAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompetitorAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompetitorAnalyses
    **/
    _count?: true | CompetitorAnalysisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompetitorAnalysisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompetitorAnalysisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompetitorAnalysisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompetitorAnalysisMaxAggregateInputType
  }

  export type GetCompetitorAnalysisAggregateType<T extends CompetitorAnalysisAggregateArgs> = {
        [P in keyof T & keyof AggregateCompetitorAnalysis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompetitorAnalysis[P]>
      : GetScalarType<T[P], AggregateCompetitorAnalysis[P]>
  }




  export type CompetitorAnalysisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompetitorAnalysisWhereInput
    orderBy?: CompetitorAnalysisOrderByWithAggregationInput | CompetitorAnalysisOrderByWithAggregationInput[]
    by: CompetitorAnalysisScalarFieldEnum[] | CompetitorAnalysisScalarFieldEnum
    having?: CompetitorAnalysisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompetitorAnalysisCountAggregateInputType | true
    _avg?: CompetitorAnalysisAvgAggregateInputType
    _sum?: CompetitorAnalysisSumAggregateInputType
    _min?: CompetitorAnalysisMinAggregateInputType
    _max?: CompetitorAnalysisMaxAggregateInputType
  }

  export type CompetitorAnalysisGroupByOutputType = {
    id: number
    domainId: number | null
    competitors: JsonValue
    marketInsights: JsonValue
    strategicRecommendations: JsonValue
    competitiveAnalysis: JsonValue
    competitorList: string
    createdAt: Date
    updatedAt: Date
    _count: CompetitorAnalysisCountAggregateOutputType | null
    _avg: CompetitorAnalysisAvgAggregateOutputType | null
    _sum: CompetitorAnalysisSumAggregateOutputType | null
    _min: CompetitorAnalysisMinAggregateOutputType | null
    _max: CompetitorAnalysisMaxAggregateOutputType | null
  }

  type GetCompetitorAnalysisGroupByPayload<T extends CompetitorAnalysisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompetitorAnalysisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompetitorAnalysisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompetitorAnalysisGroupByOutputType[P]>
            : GetScalarType<T[P], CompetitorAnalysisGroupByOutputType[P]>
        }
      >
    >


  export type CompetitorAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    competitors?: boolean
    marketInsights?: boolean
    strategicRecommendations?: boolean
    competitiveAnalysis?: boolean
    competitorList?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domain?: boolean | CompetitorAnalysis$domainArgs<ExtArgs>
  }, ExtArgs["result"]["competitorAnalysis"]>

  export type CompetitorAnalysisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    competitors?: boolean
    marketInsights?: boolean
    strategicRecommendations?: boolean
    competitiveAnalysis?: boolean
    competitorList?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domain?: boolean | CompetitorAnalysis$domainArgs<ExtArgs>
  }, ExtArgs["result"]["competitorAnalysis"]>


  export type CompetitorAnalysisSelectScalar = {
    id?: boolean
    domainId?: boolean
    competitors?: boolean
    marketInsights?: boolean
    strategicRecommendations?: boolean
    competitiveAnalysis?: boolean
    competitorList?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompetitorAnalysisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "domainId" | "competitors" | "marketInsights" | "strategicRecommendations" | "competitiveAnalysis" | "competitorList" | "createdAt" | "updatedAt", ExtArgs["result"]["competitorAnalysis"]>
  export type CompetitorAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | CompetitorAnalysis$domainArgs<ExtArgs>
  }
  export type CompetitorAnalysisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | CompetitorAnalysis$domainArgs<ExtArgs>
  }

  export type $CompetitorAnalysisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompetitorAnalysis"
    objects: {
      domain: Prisma.$DomainPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      domainId: number | null
      competitors: Prisma.JsonValue
      marketInsights: Prisma.JsonValue
      strategicRecommendations: Prisma.JsonValue
      competitiveAnalysis: Prisma.JsonValue
      competitorList: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["competitorAnalysis"]>
    composites: {}
  }

  type CompetitorAnalysisGetPayload<S extends boolean | null | undefined | CompetitorAnalysisDefaultArgs> = $Result.GetResult<Prisma.$CompetitorAnalysisPayload, S>

  type CompetitorAnalysisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompetitorAnalysisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompetitorAnalysisCountAggregateInputType | true
    }

  export interface CompetitorAnalysisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompetitorAnalysis'], meta: { name: 'CompetitorAnalysis' } }
    /**
     * Find zero or one CompetitorAnalysis that matches the filter.
     * @param {CompetitorAnalysisFindUniqueArgs} args - Arguments to find a CompetitorAnalysis
     * @example
     * // Get one CompetitorAnalysis
     * const competitorAnalysis = await prisma.competitorAnalysis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompetitorAnalysisFindUniqueArgs>(args: SelectSubset<T, CompetitorAnalysisFindUniqueArgs<ExtArgs>>): Prisma__CompetitorAnalysisClient<$Result.GetResult<Prisma.$CompetitorAnalysisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompetitorAnalysis that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompetitorAnalysisFindUniqueOrThrowArgs} args - Arguments to find a CompetitorAnalysis
     * @example
     * // Get one CompetitorAnalysis
     * const competitorAnalysis = await prisma.competitorAnalysis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompetitorAnalysisFindUniqueOrThrowArgs>(args: SelectSubset<T, CompetitorAnalysisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompetitorAnalysisClient<$Result.GetResult<Prisma.$CompetitorAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompetitorAnalysis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorAnalysisFindFirstArgs} args - Arguments to find a CompetitorAnalysis
     * @example
     * // Get one CompetitorAnalysis
     * const competitorAnalysis = await prisma.competitorAnalysis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompetitorAnalysisFindFirstArgs>(args?: SelectSubset<T, CompetitorAnalysisFindFirstArgs<ExtArgs>>): Prisma__CompetitorAnalysisClient<$Result.GetResult<Prisma.$CompetitorAnalysisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompetitorAnalysis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorAnalysisFindFirstOrThrowArgs} args - Arguments to find a CompetitorAnalysis
     * @example
     * // Get one CompetitorAnalysis
     * const competitorAnalysis = await prisma.competitorAnalysis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompetitorAnalysisFindFirstOrThrowArgs>(args?: SelectSubset<T, CompetitorAnalysisFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompetitorAnalysisClient<$Result.GetResult<Prisma.$CompetitorAnalysisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompetitorAnalyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorAnalysisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompetitorAnalyses
     * const competitorAnalyses = await prisma.competitorAnalysis.findMany()
     * 
     * // Get first 10 CompetitorAnalyses
     * const competitorAnalyses = await prisma.competitorAnalysis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const competitorAnalysisWithIdOnly = await prisma.competitorAnalysis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompetitorAnalysisFindManyArgs>(args?: SelectSubset<T, CompetitorAnalysisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompetitorAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompetitorAnalysis.
     * @param {CompetitorAnalysisCreateArgs} args - Arguments to create a CompetitorAnalysis.
     * @example
     * // Create one CompetitorAnalysis
     * const CompetitorAnalysis = await prisma.competitorAnalysis.create({
     *   data: {
     *     // ... data to create a CompetitorAnalysis
     *   }
     * })
     * 
     */
    create<T extends CompetitorAnalysisCreateArgs>(args: SelectSubset<T, CompetitorAnalysisCreateArgs<ExtArgs>>): Prisma__CompetitorAnalysisClient<$Result.GetResult<Prisma.$CompetitorAnalysisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompetitorAnalyses.
     * @param {CompetitorAnalysisCreateManyArgs} args - Arguments to create many CompetitorAnalyses.
     * @example
     * // Create many CompetitorAnalyses
     * const competitorAnalysis = await prisma.competitorAnalysis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompetitorAnalysisCreateManyArgs>(args?: SelectSubset<T, CompetitorAnalysisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompetitorAnalyses and returns the data saved in the database.
     * @param {CompetitorAnalysisCreateManyAndReturnArgs} args - Arguments to create many CompetitorAnalyses.
     * @example
     * // Create many CompetitorAnalyses
     * const competitorAnalysis = await prisma.competitorAnalysis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompetitorAnalyses and only return the `id`
     * const competitorAnalysisWithIdOnly = await prisma.competitorAnalysis.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompetitorAnalysisCreateManyAndReturnArgs>(args?: SelectSubset<T, CompetitorAnalysisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompetitorAnalysisPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompetitorAnalysis.
     * @param {CompetitorAnalysisDeleteArgs} args - Arguments to delete one CompetitorAnalysis.
     * @example
     * // Delete one CompetitorAnalysis
     * const CompetitorAnalysis = await prisma.competitorAnalysis.delete({
     *   where: {
     *     // ... filter to delete one CompetitorAnalysis
     *   }
     * })
     * 
     */
    delete<T extends CompetitorAnalysisDeleteArgs>(args: SelectSubset<T, CompetitorAnalysisDeleteArgs<ExtArgs>>): Prisma__CompetitorAnalysisClient<$Result.GetResult<Prisma.$CompetitorAnalysisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompetitorAnalysis.
     * @param {CompetitorAnalysisUpdateArgs} args - Arguments to update one CompetitorAnalysis.
     * @example
     * // Update one CompetitorAnalysis
     * const competitorAnalysis = await prisma.competitorAnalysis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompetitorAnalysisUpdateArgs>(args: SelectSubset<T, CompetitorAnalysisUpdateArgs<ExtArgs>>): Prisma__CompetitorAnalysisClient<$Result.GetResult<Prisma.$CompetitorAnalysisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompetitorAnalyses.
     * @param {CompetitorAnalysisDeleteManyArgs} args - Arguments to filter CompetitorAnalyses to delete.
     * @example
     * // Delete a few CompetitorAnalyses
     * const { count } = await prisma.competitorAnalysis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompetitorAnalysisDeleteManyArgs>(args?: SelectSubset<T, CompetitorAnalysisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompetitorAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorAnalysisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompetitorAnalyses
     * const competitorAnalysis = await prisma.competitorAnalysis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompetitorAnalysisUpdateManyArgs>(args: SelectSubset<T, CompetitorAnalysisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompetitorAnalysis.
     * @param {CompetitorAnalysisUpsertArgs} args - Arguments to update or create a CompetitorAnalysis.
     * @example
     * // Update or create a CompetitorAnalysis
     * const competitorAnalysis = await prisma.competitorAnalysis.upsert({
     *   create: {
     *     // ... data to create a CompetitorAnalysis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompetitorAnalysis we want to update
     *   }
     * })
     */
    upsert<T extends CompetitorAnalysisUpsertArgs>(args: SelectSubset<T, CompetitorAnalysisUpsertArgs<ExtArgs>>): Prisma__CompetitorAnalysisClient<$Result.GetResult<Prisma.$CompetitorAnalysisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompetitorAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorAnalysisCountArgs} args - Arguments to filter CompetitorAnalyses to count.
     * @example
     * // Count the number of CompetitorAnalyses
     * const count = await prisma.competitorAnalysis.count({
     *   where: {
     *     // ... the filter for the CompetitorAnalyses we want to count
     *   }
     * })
    **/
    count<T extends CompetitorAnalysisCountArgs>(
      args?: Subset<T, CompetitorAnalysisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompetitorAnalysisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompetitorAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorAnalysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompetitorAnalysisAggregateArgs>(args: Subset<T, CompetitorAnalysisAggregateArgs>): Prisma.PrismaPromise<GetCompetitorAnalysisAggregateType<T>>

    /**
     * Group by CompetitorAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorAnalysisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompetitorAnalysisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompetitorAnalysisGroupByArgs['orderBy'] }
        : { orderBy?: CompetitorAnalysisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompetitorAnalysisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompetitorAnalysisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompetitorAnalysis model
   */
  readonly fields: CompetitorAnalysisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompetitorAnalysis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompetitorAnalysisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domain<T extends CompetitorAnalysis$domainArgs<ExtArgs> = {}>(args?: Subset<T, CompetitorAnalysis$domainArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompetitorAnalysis model
   */
  interface CompetitorAnalysisFieldRefs {
    readonly id: FieldRef<"CompetitorAnalysis", 'Int'>
    readonly domainId: FieldRef<"CompetitorAnalysis", 'Int'>
    readonly competitors: FieldRef<"CompetitorAnalysis", 'Json'>
    readonly marketInsights: FieldRef<"CompetitorAnalysis", 'Json'>
    readonly strategicRecommendations: FieldRef<"CompetitorAnalysis", 'Json'>
    readonly competitiveAnalysis: FieldRef<"CompetitorAnalysis", 'Json'>
    readonly competitorList: FieldRef<"CompetitorAnalysis", 'String'>
    readonly createdAt: FieldRef<"CompetitorAnalysis", 'DateTime'>
    readonly updatedAt: FieldRef<"CompetitorAnalysis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompetitorAnalysis findUnique
   */
  export type CompetitorAnalysisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorAnalysis
     */
    select?: CompetitorAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompetitorAnalysis
     */
    omit?: CompetitorAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitorAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which CompetitorAnalysis to fetch.
     */
    where: CompetitorAnalysisWhereUniqueInput
  }

  /**
   * CompetitorAnalysis findUniqueOrThrow
   */
  export type CompetitorAnalysisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorAnalysis
     */
    select?: CompetitorAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompetitorAnalysis
     */
    omit?: CompetitorAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitorAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which CompetitorAnalysis to fetch.
     */
    where: CompetitorAnalysisWhereUniqueInput
  }

  /**
   * CompetitorAnalysis findFirst
   */
  export type CompetitorAnalysisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorAnalysis
     */
    select?: CompetitorAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompetitorAnalysis
     */
    omit?: CompetitorAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitorAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which CompetitorAnalysis to fetch.
     */
    where?: CompetitorAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompetitorAnalyses to fetch.
     */
    orderBy?: CompetitorAnalysisOrderByWithRelationInput | CompetitorAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompetitorAnalyses.
     */
    cursor?: CompetitorAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompetitorAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompetitorAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompetitorAnalyses.
     */
    distinct?: CompetitorAnalysisScalarFieldEnum | CompetitorAnalysisScalarFieldEnum[]
  }

  /**
   * CompetitorAnalysis findFirstOrThrow
   */
  export type CompetitorAnalysisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorAnalysis
     */
    select?: CompetitorAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompetitorAnalysis
     */
    omit?: CompetitorAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitorAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which CompetitorAnalysis to fetch.
     */
    where?: CompetitorAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompetitorAnalyses to fetch.
     */
    orderBy?: CompetitorAnalysisOrderByWithRelationInput | CompetitorAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompetitorAnalyses.
     */
    cursor?: CompetitorAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompetitorAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompetitorAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompetitorAnalyses.
     */
    distinct?: CompetitorAnalysisScalarFieldEnum | CompetitorAnalysisScalarFieldEnum[]
  }

  /**
   * CompetitorAnalysis findMany
   */
  export type CompetitorAnalysisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorAnalysis
     */
    select?: CompetitorAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompetitorAnalysis
     */
    omit?: CompetitorAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitorAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which CompetitorAnalyses to fetch.
     */
    where?: CompetitorAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompetitorAnalyses to fetch.
     */
    orderBy?: CompetitorAnalysisOrderByWithRelationInput | CompetitorAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompetitorAnalyses.
     */
    cursor?: CompetitorAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompetitorAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompetitorAnalyses.
     */
    skip?: number
    distinct?: CompetitorAnalysisScalarFieldEnum | CompetitorAnalysisScalarFieldEnum[]
  }

  /**
   * CompetitorAnalysis create
   */
  export type CompetitorAnalysisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorAnalysis
     */
    select?: CompetitorAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompetitorAnalysis
     */
    omit?: CompetitorAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitorAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to create a CompetitorAnalysis.
     */
    data: XOR<CompetitorAnalysisCreateInput, CompetitorAnalysisUncheckedCreateInput>
  }

  /**
   * CompetitorAnalysis createMany
   */
  export type CompetitorAnalysisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompetitorAnalyses.
     */
    data: CompetitorAnalysisCreateManyInput | CompetitorAnalysisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompetitorAnalysis createManyAndReturn
   */
  export type CompetitorAnalysisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorAnalysis
     */
    select?: CompetitorAnalysisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompetitorAnalysis
     */
    omit?: CompetitorAnalysisOmit<ExtArgs> | null
    /**
     * The data used to create many CompetitorAnalyses.
     */
    data: CompetitorAnalysisCreateManyInput | CompetitorAnalysisCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitorAnalysisIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompetitorAnalysis update
   */
  export type CompetitorAnalysisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorAnalysis
     */
    select?: CompetitorAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompetitorAnalysis
     */
    omit?: CompetitorAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitorAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to update a CompetitorAnalysis.
     */
    data: XOR<CompetitorAnalysisUpdateInput, CompetitorAnalysisUncheckedUpdateInput>
    /**
     * Choose, which CompetitorAnalysis to update.
     */
    where: CompetitorAnalysisWhereUniqueInput
  }

  /**
   * CompetitorAnalysis updateMany
   */
  export type CompetitorAnalysisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompetitorAnalyses.
     */
    data: XOR<CompetitorAnalysisUpdateManyMutationInput, CompetitorAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which CompetitorAnalyses to update
     */
    where?: CompetitorAnalysisWhereInput
  }

  /**
   * CompetitorAnalysis upsert
   */
  export type CompetitorAnalysisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorAnalysis
     */
    select?: CompetitorAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompetitorAnalysis
     */
    omit?: CompetitorAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitorAnalysisInclude<ExtArgs> | null
    /**
     * The filter to search for the CompetitorAnalysis to update in case it exists.
     */
    where: CompetitorAnalysisWhereUniqueInput
    /**
     * In case the CompetitorAnalysis found by the `where` argument doesn't exist, create a new CompetitorAnalysis with this data.
     */
    create: XOR<CompetitorAnalysisCreateInput, CompetitorAnalysisUncheckedCreateInput>
    /**
     * In case the CompetitorAnalysis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompetitorAnalysisUpdateInput, CompetitorAnalysisUncheckedUpdateInput>
  }

  /**
   * CompetitorAnalysis delete
   */
  export type CompetitorAnalysisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorAnalysis
     */
    select?: CompetitorAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompetitorAnalysis
     */
    omit?: CompetitorAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitorAnalysisInclude<ExtArgs> | null
    /**
     * Filter which CompetitorAnalysis to delete.
     */
    where: CompetitorAnalysisWhereUniqueInput
  }

  /**
   * CompetitorAnalysis deleteMany
   */
  export type CompetitorAnalysisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompetitorAnalyses to delete
     */
    where?: CompetitorAnalysisWhereInput
  }

  /**
   * CompetitorAnalysis.domain
   */
  export type CompetitorAnalysis$domainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    where?: DomainWhereInput
  }

  /**
   * CompetitorAnalysis without action
   */
  export type CompetitorAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorAnalysis
     */
    select?: CompetitorAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompetitorAnalysis
     */
    omit?: CompetitorAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitorAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model SuggestedCompetitor
   */

  export type AggregateSuggestedCompetitor = {
    _count: SuggestedCompetitorCountAggregateOutputType | null
    _avg: SuggestedCompetitorAvgAggregateOutputType | null
    _sum: SuggestedCompetitorSumAggregateOutputType | null
    _min: SuggestedCompetitorMinAggregateOutputType | null
    _max: SuggestedCompetitorMaxAggregateOutputType | null
  }

  export type SuggestedCompetitorAvgAggregateOutputType = {
    id: number | null
    domainId: number | null
  }

  export type SuggestedCompetitorSumAggregateOutputType = {
    id: number | null
    domainId: number | null
  }

  export type SuggestedCompetitorMinAggregateOutputType = {
    id: number | null
    domainId: number | null
    name: string | null
    competitorDomain: string | null
    reason: string | null
    type: string | null
    createdAt: Date | null
  }

  export type SuggestedCompetitorMaxAggregateOutputType = {
    id: number | null
    domainId: number | null
    name: string | null
    competitorDomain: string | null
    reason: string | null
    type: string | null
    createdAt: Date | null
  }

  export type SuggestedCompetitorCountAggregateOutputType = {
    id: number
    domainId: number
    name: number
    competitorDomain: number
    reason: number
    type: number
    createdAt: number
    _all: number
  }


  export type SuggestedCompetitorAvgAggregateInputType = {
    id?: true
    domainId?: true
  }

  export type SuggestedCompetitorSumAggregateInputType = {
    id?: true
    domainId?: true
  }

  export type SuggestedCompetitorMinAggregateInputType = {
    id?: true
    domainId?: true
    name?: true
    competitorDomain?: true
    reason?: true
    type?: true
    createdAt?: true
  }

  export type SuggestedCompetitorMaxAggregateInputType = {
    id?: true
    domainId?: true
    name?: true
    competitorDomain?: true
    reason?: true
    type?: true
    createdAt?: true
  }

  export type SuggestedCompetitorCountAggregateInputType = {
    id?: true
    domainId?: true
    name?: true
    competitorDomain?: true
    reason?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type SuggestedCompetitorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuggestedCompetitor to aggregate.
     */
    where?: SuggestedCompetitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuggestedCompetitors to fetch.
     */
    orderBy?: SuggestedCompetitorOrderByWithRelationInput | SuggestedCompetitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SuggestedCompetitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuggestedCompetitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuggestedCompetitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SuggestedCompetitors
    **/
    _count?: true | SuggestedCompetitorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SuggestedCompetitorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SuggestedCompetitorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuggestedCompetitorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuggestedCompetitorMaxAggregateInputType
  }

  export type GetSuggestedCompetitorAggregateType<T extends SuggestedCompetitorAggregateArgs> = {
        [P in keyof T & keyof AggregateSuggestedCompetitor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuggestedCompetitor[P]>
      : GetScalarType<T[P], AggregateSuggestedCompetitor[P]>
  }




  export type SuggestedCompetitorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuggestedCompetitorWhereInput
    orderBy?: SuggestedCompetitorOrderByWithAggregationInput | SuggestedCompetitorOrderByWithAggregationInput[]
    by: SuggestedCompetitorScalarFieldEnum[] | SuggestedCompetitorScalarFieldEnum
    having?: SuggestedCompetitorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuggestedCompetitorCountAggregateInputType | true
    _avg?: SuggestedCompetitorAvgAggregateInputType
    _sum?: SuggestedCompetitorSumAggregateInputType
    _min?: SuggestedCompetitorMinAggregateInputType
    _max?: SuggestedCompetitorMaxAggregateInputType
  }

  export type SuggestedCompetitorGroupByOutputType = {
    id: number
    domainId: number | null
    name: string
    competitorDomain: string
    reason: string
    type: string
    createdAt: Date
    _count: SuggestedCompetitorCountAggregateOutputType | null
    _avg: SuggestedCompetitorAvgAggregateOutputType | null
    _sum: SuggestedCompetitorSumAggregateOutputType | null
    _min: SuggestedCompetitorMinAggregateOutputType | null
    _max: SuggestedCompetitorMaxAggregateOutputType | null
  }

  type GetSuggestedCompetitorGroupByPayload<T extends SuggestedCompetitorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuggestedCompetitorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuggestedCompetitorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuggestedCompetitorGroupByOutputType[P]>
            : GetScalarType<T[P], SuggestedCompetitorGroupByOutputType[P]>
        }
      >
    >


  export type SuggestedCompetitorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    name?: boolean
    competitorDomain?: boolean
    reason?: boolean
    type?: boolean
    createdAt?: boolean
    domain?: boolean | SuggestedCompetitor$domainArgs<ExtArgs>
  }, ExtArgs["result"]["suggestedCompetitor"]>

  export type SuggestedCompetitorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    name?: boolean
    competitorDomain?: boolean
    reason?: boolean
    type?: boolean
    createdAt?: boolean
    domain?: boolean | SuggestedCompetitor$domainArgs<ExtArgs>
  }, ExtArgs["result"]["suggestedCompetitor"]>


  export type SuggestedCompetitorSelectScalar = {
    id?: boolean
    domainId?: boolean
    name?: boolean
    competitorDomain?: boolean
    reason?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type SuggestedCompetitorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "domainId" | "name" | "competitorDomain" | "reason" | "type" | "createdAt", ExtArgs["result"]["suggestedCompetitor"]>
  export type SuggestedCompetitorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | SuggestedCompetitor$domainArgs<ExtArgs>
  }
  export type SuggestedCompetitorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | SuggestedCompetitor$domainArgs<ExtArgs>
  }

  export type $SuggestedCompetitorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SuggestedCompetitor"
    objects: {
      domain: Prisma.$DomainPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      domainId: number | null
      name: string
      competitorDomain: string
      reason: string
      type: string
      createdAt: Date
    }, ExtArgs["result"]["suggestedCompetitor"]>
    composites: {}
  }

  type SuggestedCompetitorGetPayload<S extends boolean | null | undefined | SuggestedCompetitorDefaultArgs> = $Result.GetResult<Prisma.$SuggestedCompetitorPayload, S>

  type SuggestedCompetitorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SuggestedCompetitorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SuggestedCompetitorCountAggregateInputType | true
    }

  export interface SuggestedCompetitorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SuggestedCompetitor'], meta: { name: 'SuggestedCompetitor' } }
    /**
     * Find zero or one SuggestedCompetitor that matches the filter.
     * @param {SuggestedCompetitorFindUniqueArgs} args - Arguments to find a SuggestedCompetitor
     * @example
     * // Get one SuggestedCompetitor
     * const suggestedCompetitor = await prisma.suggestedCompetitor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SuggestedCompetitorFindUniqueArgs>(args: SelectSubset<T, SuggestedCompetitorFindUniqueArgs<ExtArgs>>): Prisma__SuggestedCompetitorClient<$Result.GetResult<Prisma.$SuggestedCompetitorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SuggestedCompetitor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SuggestedCompetitorFindUniqueOrThrowArgs} args - Arguments to find a SuggestedCompetitor
     * @example
     * // Get one SuggestedCompetitor
     * const suggestedCompetitor = await prisma.suggestedCompetitor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SuggestedCompetitorFindUniqueOrThrowArgs>(args: SelectSubset<T, SuggestedCompetitorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SuggestedCompetitorClient<$Result.GetResult<Prisma.$SuggestedCompetitorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuggestedCompetitor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestedCompetitorFindFirstArgs} args - Arguments to find a SuggestedCompetitor
     * @example
     * // Get one SuggestedCompetitor
     * const suggestedCompetitor = await prisma.suggestedCompetitor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SuggestedCompetitorFindFirstArgs>(args?: SelectSubset<T, SuggestedCompetitorFindFirstArgs<ExtArgs>>): Prisma__SuggestedCompetitorClient<$Result.GetResult<Prisma.$SuggestedCompetitorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuggestedCompetitor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestedCompetitorFindFirstOrThrowArgs} args - Arguments to find a SuggestedCompetitor
     * @example
     * // Get one SuggestedCompetitor
     * const suggestedCompetitor = await prisma.suggestedCompetitor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SuggestedCompetitorFindFirstOrThrowArgs>(args?: SelectSubset<T, SuggestedCompetitorFindFirstOrThrowArgs<ExtArgs>>): Prisma__SuggestedCompetitorClient<$Result.GetResult<Prisma.$SuggestedCompetitorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SuggestedCompetitors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestedCompetitorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SuggestedCompetitors
     * const suggestedCompetitors = await prisma.suggestedCompetitor.findMany()
     * 
     * // Get first 10 SuggestedCompetitors
     * const suggestedCompetitors = await prisma.suggestedCompetitor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const suggestedCompetitorWithIdOnly = await prisma.suggestedCompetitor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SuggestedCompetitorFindManyArgs>(args?: SelectSubset<T, SuggestedCompetitorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuggestedCompetitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SuggestedCompetitor.
     * @param {SuggestedCompetitorCreateArgs} args - Arguments to create a SuggestedCompetitor.
     * @example
     * // Create one SuggestedCompetitor
     * const SuggestedCompetitor = await prisma.suggestedCompetitor.create({
     *   data: {
     *     // ... data to create a SuggestedCompetitor
     *   }
     * })
     * 
     */
    create<T extends SuggestedCompetitorCreateArgs>(args: SelectSubset<T, SuggestedCompetitorCreateArgs<ExtArgs>>): Prisma__SuggestedCompetitorClient<$Result.GetResult<Prisma.$SuggestedCompetitorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SuggestedCompetitors.
     * @param {SuggestedCompetitorCreateManyArgs} args - Arguments to create many SuggestedCompetitors.
     * @example
     * // Create many SuggestedCompetitors
     * const suggestedCompetitor = await prisma.suggestedCompetitor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SuggestedCompetitorCreateManyArgs>(args?: SelectSubset<T, SuggestedCompetitorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SuggestedCompetitors and returns the data saved in the database.
     * @param {SuggestedCompetitorCreateManyAndReturnArgs} args - Arguments to create many SuggestedCompetitors.
     * @example
     * // Create many SuggestedCompetitors
     * const suggestedCompetitor = await prisma.suggestedCompetitor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SuggestedCompetitors and only return the `id`
     * const suggestedCompetitorWithIdOnly = await prisma.suggestedCompetitor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SuggestedCompetitorCreateManyAndReturnArgs>(args?: SelectSubset<T, SuggestedCompetitorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuggestedCompetitorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SuggestedCompetitor.
     * @param {SuggestedCompetitorDeleteArgs} args - Arguments to delete one SuggestedCompetitor.
     * @example
     * // Delete one SuggestedCompetitor
     * const SuggestedCompetitor = await prisma.suggestedCompetitor.delete({
     *   where: {
     *     // ... filter to delete one SuggestedCompetitor
     *   }
     * })
     * 
     */
    delete<T extends SuggestedCompetitorDeleteArgs>(args: SelectSubset<T, SuggestedCompetitorDeleteArgs<ExtArgs>>): Prisma__SuggestedCompetitorClient<$Result.GetResult<Prisma.$SuggestedCompetitorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SuggestedCompetitor.
     * @param {SuggestedCompetitorUpdateArgs} args - Arguments to update one SuggestedCompetitor.
     * @example
     * // Update one SuggestedCompetitor
     * const suggestedCompetitor = await prisma.suggestedCompetitor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SuggestedCompetitorUpdateArgs>(args: SelectSubset<T, SuggestedCompetitorUpdateArgs<ExtArgs>>): Prisma__SuggestedCompetitorClient<$Result.GetResult<Prisma.$SuggestedCompetitorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SuggestedCompetitors.
     * @param {SuggestedCompetitorDeleteManyArgs} args - Arguments to filter SuggestedCompetitors to delete.
     * @example
     * // Delete a few SuggestedCompetitors
     * const { count } = await prisma.suggestedCompetitor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SuggestedCompetitorDeleteManyArgs>(args?: SelectSubset<T, SuggestedCompetitorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuggestedCompetitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestedCompetitorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SuggestedCompetitors
     * const suggestedCompetitor = await prisma.suggestedCompetitor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SuggestedCompetitorUpdateManyArgs>(args: SelectSubset<T, SuggestedCompetitorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SuggestedCompetitor.
     * @param {SuggestedCompetitorUpsertArgs} args - Arguments to update or create a SuggestedCompetitor.
     * @example
     * // Update or create a SuggestedCompetitor
     * const suggestedCompetitor = await prisma.suggestedCompetitor.upsert({
     *   create: {
     *     // ... data to create a SuggestedCompetitor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SuggestedCompetitor we want to update
     *   }
     * })
     */
    upsert<T extends SuggestedCompetitorUpsertArgs>(args: SelectSubset<T, SuggestedCompetitorUpsertArgs<ExtArgs>>): Prisma__SuggestedCompetitorClient<$Result.GetResult<Prisma.$SuggestedCompetitorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SuggestedCompetitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestedCompetitorCountArgs} args - Arguments to filter SuggestedCompetitors to count.
     * @example
     * // Count the number of SuggestedCompetitors
     * const count = await prisma.suggestedCompetitor.count({
     *   where: {
     *     // ... the filter for the SuggestedCompetitors we want to count
     *   }
     * })
    **/
    count<T extends SuggestedCompetitorCountArgs>(
      args?: Subset<T, SuggestedCompetitorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuggestedCompetitorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SuggestedCompetitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestedCompetitorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuggestedCompetitorAggregateArgs>(args: Subset<T, SuggestedCompetitorAggregateArgs>): Prisma.PrismaPromise<GetSuggestedCompetitorAggregateType<T>>

    /**
     * Group by SuggestedCompetitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestedCompetitorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuggestedCompetitorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuggestedCompetitorGroupByArgs['orderBy'] }
        : { orderBy?: SuggestedCompetitorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuggestedCompetitorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuggestedCompetitorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SuggestedCompetitor model
   */
  readonly fields: SuggestedCompetitorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SuggestedCompetitor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SuggestedCompetitorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domain<T extends SuggestedCompetitor$domainArgs<ExtArgs> = {}>(args?: Subset<T, SuggestedCompetitor$domainArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SuggestedCompetitor model
   */
  interface SuggestedCompetitorFieldRefs {
    readonly id: FieldRef<"SuggestedCompetitor", 'Int'>
    readonly domainId: FieldRef<"SuggestedCompetitor", 'Int'>
    readonly name: FieldRef<"SuggestedCompetitor", 'String'>
    readonly competitorDomain: FieldRef<"SuggestedCompetitor", 'String'>
    readonly reason: FieldRef<"SuggestedCompetitor", 'String'>
    readonly type: FieldRef<"SuggestedCompetitor", 'String'>
    readonly createdAt: FieldRef<"SuggestedCompetitor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SuggestedCompetitor findUnique
   */
  export type SuggestedCompetitorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestedCompetitor
     */
    select?: SuggestedCompetitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestedCompetitor
     */
    omit?: SuggestedCompetitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestedCompetitorInclude<ExtArgs> | null
    /**
     * Filter, which SuggestedCompetitor to fetch.
     */
    where: SuggestedCompetitorWhereUniqueInput
  }

  /**
   * SuggestedCompetitor findUniqueOrThrow
   */
  export type SuggestedCompetitorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestedCompetitor
     */
    select?: SuggestedCompetitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestedCompetitor
     */
    omit?: SuggestedCompetitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestedCompetitorInclude<ExtArgs> | null
    /**
     * Filter, which SuggestedCompetitor to fetch.
     */
    where: SuggestedCompetitorWhereUniqueInput
  }

  /**
   * SuggestedCompetitor findFirst
   */
  export type SuggestedCompetitorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestedCompetitor
     */
    select?: SuggestedCompetitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestedCompetitor
     */
    omit?: SuggestedCompetitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestedCompetitorInclude<ExtArgs> | null
    /**
     * Filter, which SuggestedCompetitor to fetch.
     */
    where?: SuggestedCompetitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuggestedCompetitors to fetch.
     */
    orderBy?: SuggestedCompetitorOrderByWithRelationInput | SuggestedCompetitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuggestedCompetitors.
     */
    cursor?: SuggestedCompetitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuggestedCompetitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuggestedCompetitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuggestedCompetitors.
     */
    distinct?: SuggestedCompetitorScalarFieldEnum | SuggestedCompetitorScalarFieldEnum[]
  }

  /**
   * SuggestedCompetitor findFirstOrThrow
   */
  export type SuggestedCompetitorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestedCompetitor
     */
    select?: SuggestedCompetitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestedCompetitor
     */
    omit?: SuggestedCompetitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestedCompetitorInclude<ExtArgs> | null
    /**
     * Filter, which SuggestedCompetitor to fetch.
     */
    where?: SuggestedCompetitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuggestedCompetitors to fetch.
     */
    orderBy?: SuggestedCompetitorOrderByWithRelationInput | SuggestedCompetitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuggestedCompetitors.
     */
    cursor?: SuggestedCompetitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuggestedCompetitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuggestedCompetitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuggestedCompetitors.
     */
    distinct?: SuggestedCompetitorScalarFieldEnum | SuggestedCompetitorScalarFieldEnum[]
  }

  /**
   * SuggestedCompetitor findMany
   */
  export type SuggestedCompetitorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestedCompetitor
     */
    select?: SuggestedCompetitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestedCompetitor
     */
    omit?: SuggestedCompetitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestedCompetitorInclude<ExtArgs> | null
    /**
     * Filter, which SuggestedCompetitors to fetch.
     */
    where?: SuggestedCompetitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuggestedCompetitors to fetch.
     */
    orderBy?: SuggestedCompetitorOrderByWithRelationInput | SuggestedCompetitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SuggestedCompetitors.
     */
    cursor?: SuggestedCompetitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuggestedCompetitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuggestedCompetitors.
     */
    skip?: number
    distinct?: SuggestedCompetitorScalarFieldEnum | SuggestedCompetitorScalarFieldEnum[]
  }

  /**
   * SuggestedCompetitor create
   */
  export type SuggestedCompetitorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestedCompetitor
     */
    select?: SuggestedCompetitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestedCompetitor
     */
    omit?: SuggestedCompetitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestedCompetitorInclude<ExtArgs> | null
    /**
     * The data needed to create a SuggestedCompetitor.
     */
    data: XOR<SuggestedCompetitorCreateInput, SuggestedCompetitorUncheckedCreateInput>
  }

  /**
   * SuggestedCompetitor createMany
   */
  export type SuggestedCompetitorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SuggestedCompetitors.
     */
    data: SuggestedCompetitorCreateManyInput | SuggestedCompetitorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SuggestedCompetitor createManyAndReturn
   */
  export type SuggestedCompetitorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestedCompetitor
     */
    select?: SuggestedCompetitorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestedCompetitor
     */
    omit?: SuggestedCompetitorOmit<ExtArgs> | null
    /**
     * The data used to create many SuggestedCompetitors.
     */
    data: SuggestedCompetitorCreateManyInput | SuggestedCompetitorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestedCompetitorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SuggestedCompetitor update
   */
  export type SuggestedCompetitorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestedCompetitor
     */
    select?: SuggestedCompetitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestedCompetitor
     */
    omit?: SuggestedCompetitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestedCompetitorInclude<ExtArgs> | null
    /**
     * The data needed to update a SuggestedCompetitor.
     */
    data: XOR<SuggestedCompetitorUpdateInput, SuggestedCompetitorUncheckedUpdateInput>
    /**
     * Choose, which SuggestedCompetitor to update.
     */
    where: SuggestedCompetitorWhereUniqueInput
  }

  /**
   * SuggestedCompetitor updateMany
   */
  export type SuggestedCompetitorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SuggestedCompetitors.
     */
    data: XOR<SuggestedCompetitorUpdateManyMutationInput, SuggestedCompetitorUncheckedUpdateManyInput>
    /**
     * Filter which SuggestedCompetitors to update
     */
    where?: SuggestedCompetitorWhereInput
  }

  /**
   * SuggestedCompetitor upsert
   */
  export type SuggestedCompetitorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestedCompetitor
     */
    select?: SuggestedCompetitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestedCompetitor
     */
    omit?: SuggestedCompetitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestedCompetitorInclude<ExtArgs> | null
    /**
     * The filter to search for the SuggestedCompetitor to update in case it exists.
     */
    where: SuggestedCompetitorWhereUniqueInput
    /**
     * In case the SuggestedCompetitor found by the `where` argument doesn't exist, create a new SuggestedCompetitor with this data.
     */
    create: XOR<SuggestedCompetitorCreateInput, SuggestedCompetitorUncheckedCreateInput>
    /**
     * In case the SuggestedCompetitor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SuggestedCompetitorUpdateInput, SuggestedCompetitorUncheckedUpdateInput>
  }

  /**
   * SuggestedCompetitor delete
   */
  export type SuggestedCompetitorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestedCompetitor
     */
    select?: SuggestedCompetitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestedCompetitor
     */
    omit?: SuggestedCompetitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestedCompetitorInclude<ExtArgs> | null
    /**
     * Filter which SuggestedCompetitor to delete.
     */
    where: SuggestedCompetitorWhereUniqueInput
  }

  /**
   * SuggestedCompetitor deleteMany
   */
  export type SuggestedCompetitorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuggestedCompetitors to delete
     */
    where?: SuggestedCompetitorWhereInput
  }

  /**
   * SuggestedCompetitor.domain
   */
  export type SuggestedCompetitor$domainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    where?: DomainWhereInput
  }

  /**
   * SuggestedCompetitor without action
   */
  export type SuggestedCompetitorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestedCompetitor
     */
    select?: SuggestedCompetitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestedCompetitor
     */
    omit?: SuggestedCompetitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestedCompetitorInclude<ExtArgs> | null
  }


  /**
   * Model AnalysisPhase
   */

  export type AggregateAnalysisPhase = {
    _count: AnalysisPhaseCountAggregateOutputType | null
    _avg: AnalysisPhaseAvgAggregateOutputType | null
    _sum: AnalysisPhaseSumAggregateOutputType | null
    _min: AnalysisPhaseMinAggregateOutputType | null
    _max: AnalysisPhaseMaxAggregateOutputType | null
  }

  export type AnalysisPhaseAvgAggregateOutputType = {
    id: number | null
    domainId: number | null
    progress: number | null
    tokenUsage: number | null
  }

  export type AnalysisPhaseSumAggregateOutputType = {
    id: number | null
    domainId: number | null
    progress: number | null
    tokenUsage: number | null
  }

  export type AnalysisPhaseMinAggregateOutputType = {
    id: number | null
    domainId: number | null
    phase: string | null
    status: string | null
    progress: number | null
    startTime: Date | null
    endTime: Date | null
    error: string | null
    tokenUsage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalysisPhaseMaxAggregateOutputType = {
    id: number | null
    domainId: number | null
    phase: string | null
    status: string | null
    progress: number | null
    startTime: Date | null
    endTime: Date | null
    error: string | null
    tokenUsage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalysisPhaseCountAggregateOutputType = {
    id: number
    domainId: number
    phase: number
    status: number
    progress: number
    startTime: number
    endTime: number
    result: number
    error: number
    tokenUsage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnalysisPhaseAvgAggregateInputType = {
    id?: true
    domainId?: true
    progress?: true
    tokenUsage?: true
  }

  export type AnalysisPhaseSumAggregateInputType = {
    id?: true
    domainId?: true
    progress?: true
    tokenUsage?: true
  }

  export type AnalysisPhaseMinAggregateInputType = {
    id?: true
    domainId?: true
    phase?: true
    status?: true
    progress?: true
    startTime?: true
    endTime?: true
    error?: true
    tokenUsage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalysisPhaseMaxAggregateInputType = {
    id?: true
    domainId?: true
    phase?: true
    status?: true
    progress?: true
    startTime?: true
    endTime?: true
    error?: true
    tokenUsage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalysisPhaseCountAggregateInputType = {
    id?: true
    domainId?: true
    phase?: true
    status?: true
    progress?: true
    startTime?: true
    endTime?: true
    result?: true
    error?: true
    tokenUsage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnalysisPhaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalysisPhase to aggregate.
     */
    where?: AnalysisPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisPhases to fetch.
     */
    orderBy?: AnalysisPhaseOrderByWithRelationInput | AnalysisPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalysisPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisPhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalysisPhases
    **/
    _count?: true | AnalysisPhaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnalysisPhaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnalysisPhaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalysisPhaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalysisPhaseMaxAggregateInputType
  }

  export type GetAnalysisPhaseAggregateType<T extends AnalysisPhaseAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalysisPhase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalysisPhase[P]>
      : GetScalarType<T[P], AggregateAnalysisPhase[P]>
  }




  export type AnalysisPhaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalysisPhaseWhereInput
    orderBy?: AnalysisPhaseOrderByWithAggregationInput | AnalysisPhaseOrderByWithAggregationInput[]
    by: AnalysisPhaseScalarFieldEnum[] | AnalysisPhaseScalarFieldEnum
    having?: AnalysisPhaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalysisPhaseCountAggregateInputType | true
    _avg?: AnalysisPhaseAvgAggregateInputType
    _sum?: AnalysisPhaseSumAggregateInputType
    _min?: AnalysisPhaseMinAggregateInputType
    _max?: AnalysisPhaseMaxAggregateInputType
  }

  export type AnalysisPhaseGroupByOutputType = {
    id: number
    domainId: number | null
    phase: string
    status: string
    progress: number
    startTime: Date | null
    endTime: Date | null
    result: JsonValue | null
    error: string | null
    tokenUsage: number | null
    createdAt: Date
    updatedAt: Date
    _count: AnalysisPhaseCountAggregateOutputType | null
    _avg: AnalysisPhaseAvgAggregateOutputType | null
    _sum: AnalysisPhaseSumAggregateOutputType | null
    _min: AnalysisPhaseMinAggregateOutputType | null
    _max: AnalysisPhaseMaxAggregateOutputType | null
  }

  type GetAnalysisPhaseGroupByPayload<T extends AnalysisPhaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalysisPhaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalysisPhaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalysisPhaseGroupByOutputType[P]>
            : GetScalarType<T[P], AnalysisPhaseGroupByOutputType[P]>
        }
      >
    >


  export type AnalysisPhaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    phase?: boolean
    status?: boolean
    progress?: boolean
    startTime?: boolean
    endTime?: boolean
    result?: boolean
    error?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domain?: boolean | AnalysisPhase$domainArgs<ExtArgs>
  }, ExtArgs["result"]["analysisPhase"]>

  export type AnalysisPhaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    phase?: boolean
    status?: boolean
    progress?: boolean
    startTime?: boolean
    endTime?: boolean
    result?: boolean
    error?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domain?: boolean | AnalysisPhase$domainArgs<ExtArgs>
  }, ExtArgs["result"]["analysisPhase"]>


  export type AnalysisPhaseSelectScalar = {
    id?: boolean
    domainId?: boolean
    phase?: boolean
    status?: boolean
    progress?: boolean
    startTime?: boolean
    endTime?: boolean
    result?: boolean
    error?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnalysisPhaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "domainId" | "phase" | "status" | "progress" | "startTime" | "endTime" | "result" | "error" | "tokenUsage" | "createdAt" | "updatedAt", ExtArgs["result"]["analysisPhase"]>
  export type AnalysisPhaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | AnalysisPhase$domainArgs<ExtArgs>
  }
  export type AnalysisPhaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | AnalysisPhase$domainArgs<ExtArgs>
  }

  export type $AnalysisPhasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalysisPhase"
    objects: {
      domain: Prisma.$DomainPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      domainId: number | null
      phase: string
      status: string
      progress: number
      startTime: Date | null
      endTime: Date | null
      result: Prisma.JsonValue | null
      error: string | null
      tokenUsage: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["analysisPhase"]>
    composites: {}
  }

  type AnalysisPhaseGetPayload<S extends boolean | null | undefined | AnalysisPhaseDefaultArgs> = $Result.GetResult<Prisma.$AnalysisPhasePayload, S>

  type AnalysisPhaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalysisPhaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalysisPhaseCountAggregateInputType | true
    }

  export interface AnalysisPhaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalysisPhase'], meta: { name: 'AnalysisPhase' } }
    /**
     * Find zero or one AnalysisPhase that matches the filter.
     * @param {AnalysisPhaseFindUniqueArgs} args - Arguments to find a AnalysisPhase
     * @example
     * // Get one AnalysisPhase
     * const analysisPhase = await prisma.analysisPhase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalysisPhaseFindUniqueArgs>(args: SelectSubset<T, AnalysisPhaseFindUniqueArgs<ExtArgs>>): Prisma__AnalysisPhaseClient<$Result.GetResult<Prisma.$AnalysisPhasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalysisPhase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalysisPhaseFindUniqueOrThrowArgs} args - Arguments to find a AnalysisPhase
     * @example
     * // Get one AnalysisPhase
     * const analysisPhase = await prisma.analysisPhase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalysisPhaseFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalysisPhaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalysisPhaseClient<$Result.GetResult<Prisma.$AnalysisPhasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalysisPhase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisPhaseFindFirstArgs} args - Arguments to find a AnalysisPhase
     * @example
     * // Get one AnalysisPhase
     * const analysisPhase = await prisma.analysisPhase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalysisPhaseFindFirstArgs>(args?: SelectSubset<T, AnalysisPhaseFindFirstArgs<ExtArgs>>): Prisma__AnalysisPhaseClient<$Result.GetResult<Prisma.$AnalysisPhasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalysisPhase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisPhaseFindFirstOrThrowArgs} args - Arguments to find a AnalysisPhase
     * @example
     * // Get one AnalysisPhase
     * const analysisPhase = await prisma.analysisPhase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalysisPhaseFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalysisPhaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalysisPhaseClient<$Result.GetResult<Prisma.$AnalysisPhasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalysisPhases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisPhaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalysisPhases
     * const analysisPhases = await prisma.analysisPhase.findMany()
     * 
     * // Get first 10 AnalysisPhases
     * const analysisPhases = await prisma.analysisPhase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analysisPhaseWithIdOnly = await prisma.analysisPhase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalysisPhaseFindManyArgs>(args?: SelectSubset<T, AnalysisPhaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisPhasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalysisPhase.
     * @param {AnalysisPhaseCreateArgs} args - Arguments to create a AnalysisPhase.
     * @example
     * // Create one AnalysisPhase
     * const AnalysisPhase = await prisma.analysisPhase.create({
     *   data: {
     *     // ... data to create a AnalysisPhase
     *   }
     * })
     * 
     */
    create<T extends AnalysisPhaseCreateArgs>(args: SelectSubset<T, AnalysisPhaseCreateArgs<ExtArgs>>): Prisma__AnalysisPhaseClient<$Result.GetResult<Prisma.$AnalysisPhasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalysisPhases.
     * @param {AnalysisPhaseCreateManyArgs} args - Arguments to create many AnalysisPhases.
     * @example
     * // Create many AnalysisPhases
     * const analysisPhase = await prisma.analysisPhase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalysisPhaseCreateManyArgs>(args?: SelectSubset<T, AnalysisPhaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalysisPhases and returns the data saved in the database.
     * @param {AnalysisPhaseCreateManyAndReturnArgs} args - Arguments to create many AnalysisPhases.
     * @example
     * // Create many AnalysisPhases
     * const analysisPhase = await prisma.analysisPhase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalysisPhases and only return the `id`
     * const analysisPhaseWithIdOnly = await prisma.analysisPhase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalysisPhaseCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalysisPhaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisPhasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnalysisPhase.
     * @param {AnalysisPhaseDeleteArgs} args - Arguments to delete one AnalysisPhase.
     * @example
     * // Delete one AnalysisPhase
     * const AnalysisPhase = await prisma.analysisPhase.delete({
     *   where: {
     *     // ... filter to delete one AnalysisPhase
     *   }
     * })
     * 
     */
    delete<T extends AnalysisPhaseDeleteArgs>(args: SelectSubset<T, AnalysisPhaseDeleteArgs<ExtArgs>>): Prisma__AnalysisPhaseClient<$Result.GetResult<Prisma.$AnalysisPhasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalysisPhase.
     * @param {AnalysisPhaseUpdateArgs} args - Arguments to update one AnalysisPhase.
     * @example
     * // Update one AnalysisPhase
     * const analysisPhase = await prisma.analysisPhase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalysisPhaseUpdateArgs>(args: SelectSubset<T, AnalysisPhaseUpdateArgs<ExtArgs>>): Prisma__AnalysisPhaseClient<$Result.GetResult<Prisma.$AnalysisPhasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalysisPhases.
     * @param {AnalysisPhaseDeleteManyArgs} args - Arguments to filter AnalysisPhases to delete.
     * @example
     * // Delete a few AnalysisPhases
     * const { count } = await prisma.analysisPhase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalysisPhaseDeleteManyArgs>(args?: SelectSubset<T, AnalysisPhaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalysisPhases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisPhaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalysisPhases
     * const analysisPhase = await prisma.analysisPhase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalysisPhaseUpdateManyArgs>(args: SelectSubset<T, AnalysisPhaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AnalysisPhase.
     * @param {AnalysisPhaseUpsertArgs} args - Arguments to update or create a AnalysisPhase.
     * @example
     * // Update or create a AnalysisPhase
     * const analysisPhase = await prisma.analysisPhase.upsert({
     *   create: {
     *     // ... data to create a AnalysisPhase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalysisPhase we want to update
     *   }
     * })
     */
    upsert<T extends AnalysisPhaseUpsertArgs>(args: SelectSubset<T, AnalysisPhaseUpsertArgs<ExtArgs>>): Prisma__AnalysisPhaseClient<$Result.GetResult<Prisma.$AnalysisPhasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnalysisPhases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisPhaseCountArgs} args - Arguments to filter AnalysisPhases to count.
     * @example
     * // Count the number of AnalysisPhases
     * const count = await prisma.analysisPhase.count({
     *   where: {
     *     // ... the filter for the AnalysisPhases we want to count
     *   }
     * })
    **/
    count<T extends AnalysisPhaseCountArgs>(
      args?: Subset<T, AnalysisPhaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalysisPhaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalysisPhase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisPhaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalysisPhaseAggregateArgs>(args: Subset<T, AnalysisPhaseAggregateArgs>): Prisma.PrismaPromise<GetAnalysisPhaseAggregateType<T>>

    /**
     * Group by AnalysisPhase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisPhaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalysisPhaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalysisPhaseGroupByArgs['orderBy'] }
        : { orderBy?: AnalysisPhaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalysisPhaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalysisPhaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalysisPhase model
   */
  readonly fields: AnalysisPhaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalysisPhase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalysisPhaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domain<T extends AnalysisPhase$domainArgs<ExtArgs> = {}>(args?: Subset<T, AnalysisPhase$domainArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalysisPhase model
   */
  interface AnalysisPhaseFieldRefs {
    readonly id: FieldRef<"AnalysisPhase", 'Int'>
    readonly domainId: FieldRef<"AnalysisPhase", 'Int'>
    readonly phase: FieldRef<"AnalysisPhase", 'String'>
    readonly status: FieldRef<"AnalysisPhase", 'String'>
    readonly progress: FieldRef<"AnalysisPhase", 'Int'>
    readonly startTime: FieldRef<"AnalysisPhase", 'DateTime'>
    readonly endTime: FieldRef<"AnalysisPhase", 'DateTime'>
    readonly result: FieldRef<"AnalysisPhase", 'Json'>
    readonly error: FieldRef<"AnalysisPhase", 'String'>
    readonly tokenUsage: FieldRef<"AnalysisPhase", 'Int'>
    readonly createdAt: FieldRef<"AnalysisPhase", 'DateTime'>
    readonly updatedAt: FieldRef<"AnalysisPhase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalysisPhase findUnique
   */
  export type AnalysisPhaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisPhase
     */
    select?: AnalysisPhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisPhase
     */
    omit?: AnalysisPhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisPhaseInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisPhase to fetch.
     */
    where: AnalysisPhaseWhereUniqueInput
  }

  /**
   * AnalysisPhase findUniqueOrThrow
   */
  export type AnalysisPhaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisPhase
     */
    select?: AnalysisPhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisPhase
     */
    omit?: AnalysisPhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisPhaseInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisPhase to fetch.
     */
    where: AnalysisPhaseWhereUniqueInput
  }

  /**
   * AnalysisPhase findFirst
   */
  export type AnalysisPhaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisPhase
     */
    select?: AnalysisPhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisPhase
     */
    omit?: AnalysisPhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisPhaseInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisPhase to fetch.
     */
    where?: AnalysisPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisPhases to fetch.
     */
    orderBy?: AnalysisPhaseOrderByWithRelationInput | AnalysisPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalysisPhases.
     */
    cursor?: AnalysisPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisPhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalysisPhases.
     */
    distinct?: AnalysisPhaseScalarFieldEnum | AnalysisPhaseScalarFieldEnum[]
  }

  /**
   * AnalysisPhase findFirstOrThrow
   */
  export type AnalysisPhaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisPhase
     */
    select?: AnalysisPhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisPhase
     */
    omit?: AnalysisPhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisPhaseInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisPhase to fetch.
     */
    where?: AnalysisPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisPhases to fetch.
     */
    orderBy?: AnalysisPhaseOrderByWithRelationInput | AnalysisPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalysisPhases.
     */
    cursor?: AnalysisPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisPhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalysisPhases.
     */
    distinct?: AnalysisPhaseScalarFieldEnum | AnalysisPhaseScalarFieldEnum[]
  }

  /**
   * AnalysisPhase findMany
   */
  export type AnalysisPhaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisPhase
     */
    select?: AnalysisPhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisPhase
     */
    omit?: AnalysisPhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisPhaseInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisPhases to fetch.
     */
    where?: AnalysisPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisPhases to fetch.
     */
    orderBy?: AnalysisPhaseOrderByWithRelationInput | AnalysisPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalysisPhases.
     */
    cursor?: AnalysisPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisPhases.
     */
    skip?: number
    distinct?: AnalysisPhaseScalarFieldEnum | AnalysisPhaseScalarFieldEnum[]
  }

  /**
   * AnalysisPhase create
   */
  export type AnalysisPhaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisPhase
     */
    select?: AnalysisPhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisPhase
     */
    omit?: AnalysisPhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisPhaseInclude<ExtArgs> | null
    /**
     * The data needed to create a AnalysisPhase.
     */
    data: XOR<AnalysisPhaseCreateInput, AnalysisPhaseUncheckedCreateInput>
  }

  /**
   * AnalysisPhase createMany
   */
  export type AnalysisPhaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalysisPhases.
     */
    data: AnalysisPhaseCreateManyInput | AnalysisPhaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalysisPhase createManyAndReturn
   */
  export type AnalysisPhaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisPhase
     */
    select?: AnalysisPhaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisPhase
     */
    omit?: AnalysisPhaseOmit<ExtArgs> | null
    /**
     * The data used to create many AnalysisPhases.
     */
    data: AnalysisPhaseCreateManyInput | AnalysisPhaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisPhaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnalysisPhase update
   */
  export type AnalysisPhaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisPhase
     */
    select?: AnalysisPhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisPhase
     */
    omit?: AnalysisPhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisPhaseInclude<ExtArgs> | null
    /**
     * The data needed to update a AnalysisPhase.
     */
    data: XOR<AnalysisPhaseUpdateInput, AnalysisPhaseUncheckedUpdateInput>
    /**
     * Choose, which AnalysisPhase to update.
     */
    where: AnalysisPhaseWhereUniqueInput
  }

  /**
   * AnalysisPhase updateMany
   */
  export type AnalysisPhaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalysisPhases.
     */
    data: XOR<AnalysisPhaseUpdateManyMutationInput, AnalysisPhaseUncheckedUpdateManyInput>
    /**
     * Filter which AnalysisPhases to update
     */
    where?: AnalysisPhaseWhereInput
  }

  /**
   * AnalysisPhase upsert
   */
  export type AnalysisPhaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisPhase
     */
    select?: AnalysisPhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisPhase
     */
    omit?: AnalysisPhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisPhaseInclude<ExtArgs> | null
    /**
     * The filter to search for the AnalysisPhase to update in case it exists.
     */
    where: AnalysisPhaseWhereUniqueInput
    /**
     * In case the AnalysisPhase found by the `where` argument doesn't exist, create a new AnalysisPhase with this data.
     */
    create: XOR<AnalysisPhaseCreateInput, AnalysisPhaseUncheckedCreateInput>
    /**
     * In case the AnalysisPhase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalysisPhaseUpdateInput, AnalysisPhaseUncheckedUpdateInput>
  }

  /**
   * AnalysisPhase delete
   */
  export type AnalysisPhaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisPhase
     */
    select?: AnalysisPhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisPhase
     */
    omit?: AnalysisPhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisPhaseInclude<ExtArgs> | null
    /**
     * Filter which AnalysisPhase to delete.
     */
    where: AnalysisPhaseWhereUniqueInput
  }

  /**
   * AnalysisPhase deleteMany
   */
  export type AnalysisPhaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalysisPhases to delete
     */
    where?: AnalysisPhaseWhereInput
  }

  /**
   * AnalysisPhase.domain
   */
  export type AnalysisPhase$domainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    where?: DomainWhereInput
  }

  /**
   * AnalysisPhase without action
   */
  export type AnalysisPhaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisPhase
     */
    select?: AnalysisPhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisPhase
     */
    omit?: AnalysisPhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisPhaseInclude<ExtArgs> | null
  }


  /**
   * Model SemanticAnalysis
   */

  export type AggregateSemanticAnalysis = {
    _count: SemanticAnalysisCountAggregateOutputType | null
    _avg: SemanticAnalysisAvgAggregateOutputType | null
    _sum: SemanticAnalysisSumAggregateOutputType | null
    _min: SemanticAnalysisMinAggregateOutputType | null
    _max: SemanticAnalysisMaxAggregateOutputType | null
  }

  export type SemanticAnalysisAvgAggregateOutputType = {
    id: number | null
    domainId: number | null
    tokenUsage: number | null
  }

  export type SemanticAnalysisSumAggregateOutputType = {
    id: number | null
    domainId: number | null
    tokenUsage: number | null
  }

  export type SemanticAnalysisMinAggregateOutputType = {
    id: number | null
    domainId: number | null
    contentSummary: string | null
    brandVoice: string | null
    tokenUsage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SemanticAnalysisMaxAggregateOutputType = {
    id: number | null
    domainId: number | null
    contentSummary: string | null
    brandVoice: string | null
    tokenUsage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SemanticAnalysisCountAggregateOutputType = {
    id: number
    domainId: number
    contentSummary: number
    keyThemes: number
    brandVoice: number
    targetAudience: number
    contentGaps: number
    tokenUsage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SemanticAnalysisAvgAggregateInputType = {
    id?: true
    domainId?: true
    tokenUsage?: true
  }

  export type SemanticAnalysisSumAggregateInputType = {
    id?: true
    domainId?: true
    tokenUsage?: true
  }

  export type SemanticAnalysisMinAggregateInputType = {
    id?: true
    domainId?: true
    contentSummary?: true
    brandVoice?: true
    tokenUsage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SemanticAnalysisMaxAggregateInputType = {
    id?: true
    domainId?: true
    contentSummary?: true
    brandVoice?: true
    tokenUsage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SemanticAnalysisCountAggregateInputType = {
    id?: true
    domainId?: true
    contentSummary?: true
    keyThemes?: true
    brandVoice?: true
    targetAudience?: true
    contentGaps?: true
    tokenUsage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SemanticAnalysisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SemanticAnalysis to aggregate.
     */
    where?: SemanticAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SemanticAnalyses to fetch.
     */
    orderBy?: SemanticAnalysisOrderByWithRelationInput | SemanticAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SemanticAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SemanticAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SemanticAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SemanticAnalyses
    **/
    _count?: true | SemanticAnalysisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SemanticAnalysisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SemanticAnalysisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SemanticAnalysisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SemanticAnalysisMaxAggregateInputType
  }

  export type GetSemanticAnalysisAggregateType<T extends SemanticAnalysisAggregateArgs> = {
        [P in keyof T & keyof AggregateSemanticAnalysis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSemanticAnalysis[P]>
      : GetScalarType<T[P], AggregateSemanticAnalysis[P]>
  }




  export type SemanticAnalysisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SemanticAnalysisWhereInput
    orderBy?: SemanticAnalysisOrderByWithAggregationInput | SemanticAnalysisOrderByWithAggregationInput[]
    by: SemanticAnalysisScalarFieldEnum[] | SemanticAnalysisScalarFieldEnum
    having?: SemanticAnalysisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SemanticAnalysisCountAggregateInputType | true
    _avg?: SemanticAnalysisAvgAggregateInputType
    _sum?: SemanticAnalysisSumAggregateInputType
    _min?: SemanticAnalysisMinAggregateInputType
    _max?: SemanticAnalysisMaxAggregateInputType
  }

  export type SemanticAnalysisGroupByOutputType = {
    id: number
    domainId: number | null
    contentSummary: string
    keyThemes: JsonValue
    brandVoice: string
    targetAudience: JsonValue
    contentGaps: JsonValue
    tokenUsage: number | null
    createdAt: Date
    updatedAt: Date
    _count: SemanticAnalysisCountAggregateOutputType | null
    _avg: SemanticAnalysisAvgAggregateOutputType | null
    _sum: SemanticAnalysisSumAggregateOutputType | null
    _min: SemanticAnalysisMinAggregateOutputType | null
    _max: SemanticAnalysisMaxAggregateOutputType | null
  }

  type GetSemanticAnalysisGroupByPayload<T extends SemanticAnalysisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SemanticAnalysisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SemanticAnalysisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SemanticAnalysisGroupByOutputType[P]>
            : GetScalarType<T[P], SemanticAnalysisGroupByOutputType[P]>
        }
      >
    >


  export type SemanticAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    contentSummary?: boolean
    keyThemes?: boolean
    brandVoice?: boolean
    targetAudience?: boolean
    contentGaps?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domain?: boolean | SemanticAnalysis$domainArgs<ExtArgs>
  }, ExtArgs["result"]["semanticAnalysis"]>

  export type SemanticAnalysisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    contentSummary?: boolean
    keyThemes?: boolean
    brandVoice?: boolean
    targetAudience?: boolean
    contentGaps?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domain?: boolean | SemanticAnalysis$domainArgs<ExtArgs>
  }, ExtArgs["result"]["semanticAnalysis"]>


  export type SemanticAnalysisSelectScalar = {
    id?: boolean
    domainId?: boolean
    contentSummary?: boolean
    keyThemes?: boolean
    brandVoice?: boolean
    targetAudience?: boolean
    contentGaps?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SemanticAnalysisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "domainId" | "contentSummary" | "keyThemes" | "brandVoice" | "targetAudience" | "contentGaps" | "tokenUsage" | "createdAt" | "updatedAt", ExtArgs["result"]["semanticAnalysis"]>
  export type SemanticAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | SemanticAnalysis$domainArgs<ExtArgs>
  }
  export type SemanticAnalysisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | SemanticAnalysis$domainArgs<ExtArgs>
  }

  export type $SemanticAnalysisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SemanticAnalysis"
    objects: {
      domain: Prisma.$DomainPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      domainId: number | null
      contentSummary: string
      keyThemes: Prisma.JsonValue
      brandVoice: string
      targetAudience: Prisma.JsonValue
      contentGaps: Prisma.JsonValue
      tokenUsage: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["semanticAnalysis"]>
    composites: {}
  }

  type SemanticAnalysisGetPayload<S extends boolean | null | undefined | SemanticAnalysisDefaultArgs> = $Result.GetResult<Prisma.$SemanticAnalysisPayload, S>

  type SemanticAnalysisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SemanticAnalysisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SemanticAnalysisCountAggregateInputType | true
    }

  export interface SemanticAnalysisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SemanticAnalysis'], meta: { name: 'SemanticAnalysis' } }
    /**
     * Find zero or one SemanticAnalysis that matches the filter.
     * @param {SemanticAnalysisFindUniqueArgs} args - Arguments to find a SemanticAnalysis
     * @example
     * // Get one SemanticAnalysis
     * const semanticAnalysis = await prisma.semanticAnalysis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SemanticAnalysisFindUniqueArgs>(args: SelectSubset<T, SemanticAnalysisFindUniqueArgs<ExtArgs>>): Prisma__SemanticAnalysisClient<$Result.GetResult<Prisma.$SemanticAnalysisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SemanticAnalysis that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SemanticAnalysisFindUniqueOrThrowArgs} args - Arguments to find a SemanticAnalysis
     * @example
     * // Get one SemanticAnalysis
     * const semanticAnalysis = await prisma.semanticAnalysis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SemanticAnalysisFindUniqueOrThrowArgs>(args: SelectSubset<T, SemanticAnalysisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SemanticAnalysisClient<$Result.GetResult<Prisma.$SemanticAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SemanticAnalysis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemanticAnalysisFindFirstArgs} args - Arguments to find a SemanticAnalysis
     * @example
     * // Get one SemanticAnalysis
     * const semanticAnalysis = await prisma.semanticAnalysis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SemanticAnalysisFindFirstArgs>(args?: SelectSubset<T, SemanticAnalysisFindFirstArgs<ExtArgs>>): Prisma__SemanticAnalysisClient<$Result.GetResult<Prisma.$SemanticAnalysisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SemanticAnalysis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemanticAnalysisFindFirstOrThrowArgs} args - Arguments to find a SemanticAnalysis
     * @example
     * // Get one SemanticAnalysis
     * const semanticAnalysis = await prisma.semanticAnalysis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SemanticAnalysisFindFirstOrThrowArgs>(args?: SelectSubset<T, SemanticAnalysisFindFirstOrThrowArgs<ExtArgs>>): Prisma__SemanticAnalysisClient<$Result.GetResult<Prisma.$SemanticAnalysisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SemanticAnalyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemanticAnalysisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SemanticAnalyses
     * const semanticAnalyses = await prisma.semanticAnalysis.findMany()
     * 
     * // Get first 10 SemanticAnalyses
     * const semanticAnalyses = await prisma.semanticAnalysis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const semanticAnalysisWithIdOnly = await prisma.semanticAnalysis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SemanticAnalysisFindManyArgs>(args?: SelectSubset<T, SemanticAnalysisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SemanticAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SemanticAnalysis.
     * @param {SemanticAnalysisCreateArgs} args - Arguments to create a SemanticAnalysis.
     * @example
     * // Create one SemanticAnalysis
     * const SemanticAnalysis = await prisma.semanticAnalysis.create({
     *   data: {
     *     // ... data to create a SemanticAnalysis
     *   }
     * })
     * 
     */
    create<T extends SemanticAnalysisCreateArgs>(args: SelectSubset<T, SemanticAnalysisCreateArgs<ExtArgs>>): Prisma__SemanticAnalysisClient<$Result.GetResult<Prisma.$SemanticAnalysisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SemanticAnalyses.
     * @param {SemanticAnalysisCreateManyArgs} args - Arguments to create many SemanticAnalyses.
     * @example
     * // Create many SemanticAnalyses
     * const semanticAnalysis = await prisma.semanticAnalysis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SemanticAnalysisCreateManyArgs>(args?: SelectSubset<T, SemanticAnalysisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SemanticAnalyses and returns the data saved in the database.
     * @param {SemanticAnalysisCreateManyAndReturnArgs} args - Arguments to create many SemanticAnalyses.
     * @example
     * // Create many SemanticAnalyses
     * const semanticAnalysis = await prisma.semanticAnalysis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SemanticAnalyses and only return the `id`
     * const semanticAnalysisWithIdOnly = await prisma.semanticAnalysis.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SemanticAnalysisCreateManyAndReturnArgs>(args?: SelectSubset<T, SemanticAnalysisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SemanticAnalysisPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SemanticAnalysis.
     * @param {SemanticAnalysisDeleteArgs} args - Arguments to delete one SemanticAnalysis.
     * @example
     * // Delete one SemanticAnalysis
     * const SemanticAnalysis = await prisma.semanticAnalysis.delete({
     *   where: {
     *     // ... filter to delete one SemanticAnalysis
     *   }
     * })
     * 
     */
    delete<T extends SemanticAnalysisDeleteArgs>(args: SelectSubset<T, SemanticAnalysisDeleteArgs<ExtArgs>>): Prisma__SemanticAnalysisClient<$Result.GetResult<Prisma.$SemanticAnalysisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SemanticAnalysis.
     * @param {SemanticAnalysisUpdateArgs} args - Arguments to update one SemanticAnalysis.
     * @example
     * // Update one SemanticAnalysis
     * const semanticAnalysis = await prisma.semanticAnalysis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SemanticAnalysisUpdateArgs>(args: SelectSubset<T, SemanticAnalysisUpdateArgs<ExtArgs>>): Prisma__SemanticAnalysisClient<$Result.GetResult<Prisma.$SemanticAnalysisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SemanticAnalyses.
     * @param {SemanticAnalysisDeleteManyArgs} args - Arguments to filter SemanticAnalyses to delete.
     * @example
     * // Delete a few SemanticAnalyses
     * const { count } = await prisma.semanticAnalysis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SemanticAnalysisDeleteManyArgs>(args?: SelectSubset<T, SemanticAnalysisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SemanticAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemanticAnalysisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SemanticAnalyses
     * const semanticAnalysis = await prisma.semanticAnalysis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SemanticAnalysisUpdateManyArgs>(args: SelectSubset<T, SemanticAnalysisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SemanticAnalysis.
     * @param {SemanticAnalysisUpsertArgs} args - Arguments to update or create a SemanticAnalysis.
     * @example
     * // Update or create a SemanticAnalysis
     * const semanticAnalysis = await prisma.semanticAnalysis.upsert({
     *   create: {
     *     // ... data to create a SemanticAnalysis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SemanticAnalysis we want to update
     *   }
     * })
     */
    upsert<T extends SemanticAnalysisUpsertArgs>(args: SelectSubset<T, SemanticAnalysisUpsertArgs<ExtArgs>>): Prisma__SemanticAnalysisClient<$Result.GetResult<Prisma.$SemanticAnalysisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SemanticAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemanticAnalysisCountArgs} args - Arguments to filter SemanticAnalyses to count.
     * @example
     * // Count the number of SemanticAnalyses
     * const count = await prisma.semanticAnalysis.count({
     *   where: {
     *     // ... the filter for the SemanticAnalyses we want to count
     *   }
     * })
    **/
    count<T extends SemanticAnalysisCountArgs>(
      args?: Subset<T, SemanticAnalysisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SemanticAnalysisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SemanticAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemanticAnalysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SemanticAnalysisAggregateArgs>(args: Subset<T, SemanticAnalysisAggregateArgs>): Prisma.PrismaPromise<GetSemanticAnalysisAggregateType<T>>

    /**
     * Group by SemanticAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemanticAnalysisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SemanticAnalysisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SemanticAnalysisGroupByArgs['orderBy'] }
        : { orderBy?: SemanticAnalysisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SemanticAnalysisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSemanticAnalysisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SemanticAnalysis model
   */
  readonly fields: SemanticAnalysisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SemanticAnalysis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SemanticAnalysisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domain<T extends SemanticAnalysis$domainArgs<ExtArgs> = {}>(args?: Subset<T, SemanticAnalysis$domainArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SemanticAnalysis model
   */
  interface SemanticAnalysisFieldRefs {
    readonly id: FieldRef<"SemanticAnalysis", 'Int'>
    readonly domainId: FieldRef<"SemanticAnalysis", 'Int'>
    readonly contentSummary: FieldRef<"SemanticAnalysis", 'String'>
    readonly keyThemes: FieldRef<"SemanticAnalysis", 'Json'>
    readonly brandVoice: FieldRef<"SemanticAnalysis", 'String'>
    readonly targetAudience: FieldRef<"SemanticAnalysis", 'Json'>
    readonly contentGaps: FieldRef<"SemanticAnalysis", 'Json'>
    readonly tokenUsage: FieldRef<"SemanticAnalysis", 'Int'>
    readonly createdAt: FieldRef<"SemanticAnalysis", 'DateTime'>
    readonly updatedAt: FieldRef<"SemanticAnalysis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SemanticAnalysis findUnique
   */
  export type SemanticAnalysisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticAnalysis
     */
    select?: SemanticAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemanticAnalysis
     */
    omit?: SemanticAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemanticAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which SemanticAnalysis to fetch.
     */
    where: SemanticAnalysisWhereUniqueInput
  }

  /**
   * SemanticAnalysis findUniqueOrThrow
   */
  export type SemanticAnalysisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticAnalysis
     */
    select?: SemanticAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemanticAnalysis
     */
    omit?: SemanticAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemanticAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which SemanticAnalysis to fetch.
     */
    where: SemanticAnalysisWhereUniqueInput
  }

  /**
   * SemanticAnalysis findFirst
   */
  export type SemanticAnalysisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticAnalysis
     */
    select?: SemanticAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemanticAnalysis
     */
    omit?: SemanticAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemanticAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which SemanticAnalysis to fetch.
     */
    where?: SemanticAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SemanticAnalyses to fetch.
     */
    orderBy?: SemanticAnalysisOrderByWithRelationInput | SemanticAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SemanticAnalyses.
     */
    cursor?: SemanticAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SemanticAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SemanticAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SemanticAnalyses.
     */
    distinct?: SemanticAnalysisScalarFieldEnum | SemanticAnalysisScalarFieldEnum[]
  }

  /**
   * SemanticAnalysis findFirstOrThrow
   */
  export type SemanticAnalysisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticAnalysis
     */
    select?: SemanticAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemanticAnalysis
     */
    omit?: SemanticAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemanticAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which SemanticAnalysis to fetch.
     */
    where?: SemanticAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SemanticAnalyses to fetch.
     */
    orderBy?: SemanticAnalysisOrderByWithRelationInput | SemanticAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SemanticAnalyses.
     */
    cursor?: SemanticAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SemanticAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SemanticAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SemanticAnalyses.
     */
    distinct?: SemanticAnalysisScalarFieldEnum | SemanticAnalysisScalarFieldEnum[]
  }

  /**
   * SemanticAnalysis findMany
   */
  export type SemanticAnalysisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticAnalysis
     */
    select?: SemanticAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemanticAnalysis
     */
    omit?: SemanticAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemanticAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which SemanticAnalyses to fetch.
     */
    where?: SemanticAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SemanticAnalyses to fetch.
     */
    orderBy?: SemanticAnalysisOrderByWithRelationInput | SemanticAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SemanticAnalyses.
     */
    cursor?: SemanticAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SemanticAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SemanticAnalyses.
     */
    skip?: number
    distinct?: SemanticAnalysisScalarFieldEnum | SemanticAnalysisScalarFieldEnum[]
  }

  /**
   * SemanticAnalysis create
   */
  export type SemanticAnalysisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticAnalysis
     */
    select?: SemanticAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemanticAnalysis
     */
    omit?: SemanticAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemanticAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to create a SemanticAnalysis.
     */
    data: XOR<SemanticAnalysisCreateInput, SemanticAnalysisUncheckedCreateInput>
  }

  /**
   * SemanticAnalysis createMany
   */
  export type SemanticAnalysisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SemanticAnalyses.
     */
    data: SemanticAnalysisCreateManyInput | SemanticAnalysisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SemanticAnalysis createManyAndReturn
   */
  export type SemanticAnalysisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticAnalysis
     */
    select?: SemanticAnalysisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SemanticAnalysis
     */
    omit?: SemanticAnalysisOmit<ExtArgs> | null
    /**
     * The data used to create many SemanticAnalyses.
     */
    data: SemanticAnalysisCreateManyInput | SemanticAnalysisCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemanticAnalysisIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SemanticAnalysis update
   */
  export type SemanticAnalysisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticAnalysis
     */
    select?: SemanticAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemanticAnalysis
     */
    omit?: SemanticAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemanticAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to update a SemanticAnalysis.
     */
    data: XOR<SemanticAnalysisUpdateInput, SemanticAnalysisUncheckedUpdateInput>
    /**
     * Choose, which SemanticAnalysis to update.
     */
    where: SemanticAnalysisWhereUniqueInput
  }

  /**
   * SemanticAnalysis updateMany
   */
  export type SemanticAnalysisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SemanticAnalyses.
     */
    data: XOR<SemanticAnalysisUpdateManyMutationInput, SemanticAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which SemanticAnalyses to update
     */
    where?: SemanticAnalysisWhereInput
  }

  /**
   * SemanticAnalysis upsert
   */
  export type SemanticAnalysisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticAnalysis
     */
    select?: SemanticAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemanticAnalysis
     */
    omit?: SemanticAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemanticAnalysisInclude<ExtArgs> | null
    /**
     * The filter to search for the SemanticAnalysis to update in case it exists.
     */
    where: SemanticAnalysisWhereUniqueInput
    /**
     * In case the SemanticAnalysis found by the `where` argument doesn't exist, create a new SemanticAnalysis with this data.
     */
    create: XOR<SemanticAnalysisCreateInput, SemanticAnalysisUncheckedCreateInput>
    /**
     * In case the SemanticAnalysis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SemanticAnalysisUpdateInput, SemanticAnalysisUncheckedUpdateInput>
  }

  /**
   * SemanticAnalysis delete
   */
  export type SemanticAnalysisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticAnalysis
     */
    select?: SemanticAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemanticAnalysis
     */
    omit?: SemanticAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemanticAnalysisInclude<ExtArgs> | null
    /**
     * Filter which SemanticAnalysis to delete.
     */
    where: SemanticAnalysisWhereUniqueInput
  }

  /**
   * SemanticAnalysis deleteMany
   */
  export type SemanticAnalysisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SemanticAnalyses to delete
     */
    where?: SemanticAnalysisWhereInput
  }

  /**
   * SemanticAnalysis.domain
   */
  export type SemanticAnalysis$domainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    where?: DomainWhereInput
  }

  /**
   * SemanticAnalysis without action
   */
  export type SemanticAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticAnalysis
     */
    select?: SemanticAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemanticAnalysis
     */
    omit?: SemanticAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemanticAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model KeywordAnalysis
   */

  export type AggregateKeywordAnalysis = {
    _count: KeywordAnalysisCountAggregateOutputType | null
    _avg: KeywordAnalysisAvgAggregateOutputType | null
    _sum: KeywordAnalysisSumAggregateOutputType | null
    _min: KeywordAnalysisMinAggregateOutputType | null
    _max: KeywordAnalysisMaxAggregateOutputType | null
  }

  export type KeywordAnalysisAvgAggregateOutputType = {
    id: number | null
    domainId: number | null
    tokenUsage: number | null
  }

  export type KeywordAnalysisSumAggregateOutputType = {
    id: number | null
    domainId: number | null
    tokenUsage: number | null
  }

  export type KeywordAnalysisMinAggregateOutputType = {
    id: number | null
    domainId: number | null
    tokenUsage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KeywordAnalysisMaxAggregateOutputType = {
    id: number | null
    domainId: number | null
    tokenUsage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KeywordAnalysisCountAggregateOutputType = {
    id: number
    domainId: number
    keywords: number
    searchVolumeData: number
    intentClassification: number
    competitiveAnalysis: number
    tokenUsage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KeywordAnalysisAvgAggregateInputType = {
    id?: true
    domainId?: true
    tokenUsage?: true
  }

  export type KeywordAnalysisSumAggregateInputType = {
    id?: true
    domainId?: true
    tokenUsage?: true
  }

  export type KeywordAnalysisMinAggregateInputType = {
    id?: true
    domainId?: true
    tokenUsage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KeywordAnalysisMaxAggregateInputType = {
    id?: true
    domainId?: true
    tokenUsage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KeywordAnalysisCountAggregateInputType = {
    id?: true
    domainId?: true
    keywords?: true
    searchVolumeData?: true
    intentClassification?: true
    competitiveAnalysis?: true
    tokenUsage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KeywordAnalysisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KeywordAnalysis to aggregate.
     */
    where?: KeywordAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeywordAnalyses to fetch.
     */
    orderBy?: KeywordAnalysisOrderByWithRelationInput | KeywordAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KeywordAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeywordAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeywordAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KeywordAnalyses
    **/
    _count?: true | KeywordAnalysisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KeywordAnalysisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KeywordAnalysisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KeywordAnalysisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KeywordAnalysisMaxAggregateInputType
  }

  export type GetKeywordAnalysisAggregateType<T extends KeywordAnalysisAggregateArgs> = {
        [P in keyof T & keyof AggregateKeywordAnalysis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKeywordAnalysis[P]>
      : GetScalarType<T[P], AggregateKeywordAnalysis[P]>
  }




  export type KeywordAnalysisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeywordAnalysisWhereInput
    orderBy?: KeywordAnalysisOrderByWithAggregationInput | KeywordAnalysisOrderByWithAggregationInput[]
    by: KeywordAnalysisScalarFieldEnum[] | KeywordAnalysisScalarFieldEnum
    having?: KeywordAnalysisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KeywordAnalysisCountAggregateInputType | true
    _avg?: KeywordAnalysisAvgAggregateInputType
    _sum?: KeywordAnalysisSumAggregateInputType
    _min?: KeywordAnalysisMinAggregateInputType
    _max?: KeywordAnalysisMaxAggregateInputType
  }

  export type KeywordAnalysisGroupByOutputType = {
    id: number
    domainId: number | null
    keywords: JsonValue
    searchVolumeData: JsonValue
    intentClassification: JsonValue
    competitiveAnalysis: JsonValue
    tokenUsage: number | null
    createdAt: Date
    updatedAt: Date
    _count: KeywordAnalysisCountAggregateOutputType | null
    _avg: KeywordAnalysisAvgAggregateOutputType | null
    _sum: KeywordAnalysisSumAggregateOutputType | null
    _min: KeywordAnalysisMinAggregateOutputType | null
    _max: KeywordAnalysisMaxAggregateOutputType | null
  }

  type GetKeywordAnalysisGroupByPayload<T extends KeywordAnalysisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KeywordAnalysisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KeywordAnalysisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KeywordAnalysisGroupByOutputType[P]>
            : GetScalarType<T[P], KeywordAnalysisGroupByOutputType[P]>
        }
      >
    >


  export type KeywordAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    keywords?: boolean
    searchVolumeData?: boolean
    intentClassification?: boolean
    competitiveAnalysis?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domain?: boolean | KeywordAnalysis$domainArgs<ExtArgs>
  }, ExtArgs["result"]["keywordAnalysis"]>

  export type KeywordAnalysisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    keywords?: boolean
    searchVolumeData?: boolean
    intentClassification?: boolean
    competitiveAnalysis?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domain?: boolean | KeywordAnalysis$domainArgs<ExtArgs>
  }, ExtArgs["result"]["keywordAnalysis"]>


  export type KeywordAnalysisSelectScalar = {
    id?: boolean
    domainId?: boolean
    keywords?: boolean
    searchVolumeData?: boolean
    intentClassification?: boolean
    competitiveAnalysis?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KeywordAnalysisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "domainId" | "keywords" | "searchVolumeData" | "intentClassification" | "competitiveAnalysis" | "tokenUsage" | "createdAt" | "updatedAt", ExtArgs["result"]["keywordAnalysis"]>
  export type KeywordAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | KeywordAnalysis$domainArgs<ExtArgs>
  }
  export type KeywordAnalysisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | KeywordAnalysis$domainArgs<ExtArgs>
  }

  export type $KeywordAnalysisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KeywordAnalysis"
    objects: {
      domain: Prisma.$DomainPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      domainId: number | null
      keywords: Prisma.JsonValue
      searchVolumeData: Prisma.JsonValue
      intentClassification: Prisma.JsonValue
      competitiveAnalysis: Prisma.JsonValue
      tokenUsage: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["keywordAnalysis"]>
    composites: {}
  }

  type KeywordAnalysisGetPayload<S extends boolean | null | undefined | KeywordAnalysisDefaultArgs> = $Result.GetResult<Prisma.$KeywordAnalysisPayload, S>

  type KeywordAnalysisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KeywordAnalysisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KeywordAnalysisCountAggregateInputType | true
    }

  export interface KeywordAnalysisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KeywordAnalysis'], meta: { name: 'KeywordAnalysis' } }
    /**
     * Find zero or one KeywordAnalysis that matches the filter.
     * @param {KeywordAnalysisFindUniqueArgs} args - Arguments to find a KeywordAnalysis
     * @example
     * // Get one KeywordAnalysis
     * const keywordAnalysis = await prisma.keywordAnalysis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KeywordAnalysisFindUniqueArgs>(args: SelectSubset<T, KeywordAnalysisFindUniqueArgs<ExtArgs>>): Prisma__KeywordAnalysisClient<$Result.GetResult<Prisma.$KeywordAnalysisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KeywordAnalysis that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KeywordAnalysisFindUniqueOrThrowArgs} args - Arguments to find a KeywordAnalysis
     * @example
     * // Get one KeywordAnalysis
     * const keywordAnalysis = await prisma.keywordAnalysis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KeywordAnalysisFindUniqueOrThrowArgs>(args: SelectSubset<T, KeywordAnalysisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KeywordAnalysisClient<$Result.GetResult<Prisma.$KeywordAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KeywordAnalysis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordAnalysisFindFirstArgs} args - Arguments to find a KeywordAnalysis
     * @example
     * // Get one KeywordAnalysis
     * const keywordAnalysis = await prisma.keywordAnalysis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KeywordAnalysisFindFirstArgs>(args?: SelectSubset<T, KeywordAnalysisFindFirstArgs<ExtArgs>>): Prisma__KeywordAnalysisClient<$Result.GetResult<Prisma.$KeywordAnalysisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KeywordAnalysis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordAnalysisFindFirstOrThrowArgs} args - Arguments to find a KeywordAnalysis
     * @example
     * // Get one KeywordAnalysis
     * const keywordAnalysis = await prisma.keywordAnalysis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KeywordAnalysisFindFirstOrThrowArgs>(args?: SelectSubset<T, KeywordAnalysisFindFirstOrThrowArgs<ExtArgs>>): Prisma__KeywordAnalysisClient<$Result.GetResult<Prisma.$KeywordAnalysisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KeywordAnalyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordAnalysisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KeywordAnalyses
     * const keywordAnalyses = await prisma.keywordAnalysis.findMany()
     * 
     * // Get first 10 KeywordAnalyses
     * const keywordAnalyses = await prisma.keywordAnalysis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const keywordAnalysisWithIdOnly = await prisma.keywordAnalysis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KeywordAnalysisFindManyArgs>(args?: SelectSubset<T, KeywordAnalysisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeywordAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KeywordAnalysis.
     * @param {KeywordAnalysisCreateArgs} args - Arguments to create a KeywordAnalysis.
     * @example
     * // Create one KeywordAnalysis
     * const KeywordAnalysis = await prisma.keywordAnalysis.create({
     *   data: {
     *     // ... data to create a KeywordAnalysis
     *   }
     * })
     * 
     */
    create<T extends KeywordAnalysisCreateArgs>(args: SelectSubset<T, KeywordAnalysisCreateArgs<ExtArgs>>): Prisma__KeywordAnalysisClient<$Result.GetResult<Prisma.$KeywordAnalysisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KeywordAnalyses.
     * @param {KeywordAnalysisCreateManyArgs} args - Arguments to create many KeywordAnalyses.
     * @example
     * // Create many KeywordAnalyses
     * const keywordAnalysis = await prisma.keywordAnalysis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KeywordAnalysisCreateManyArgs>(args?: SelectSubset<T, KeywordAnalysisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KeywordAnalyses and returns the data saved in the database.
     * @param {KeywordAnalysisCreateManyAndReturnArgs} args - Arguments to create many KeywordAnalyses.
     * @example
     * // Create many KeywordAnalyses
     * const keywordAnalysis = await prisma.keywordAnalysis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KeywordAnalyses and only return the `id`
     * const keywordAnalysisWithIdOnly = await prisma.keywordAnalysis.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KeywordAnalysisCreateManyAndReturnArgs>(args?: SelectSubset<T, KeywordAnalysisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeywordAnalysisPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KeywordAnalysis.
     * @param {KeywordAnalysisDeleteArgs} args - Arguments to delete one KeywordAnalysis.
     * @example
     * // Delete one KeywordAnalysis
     * const KeywordAnalysis = await prisma.keywordAnalysis.delete({
     *   where: {
     *     // ... filter to delete one KeywordAnalysis
     *   }
     * })
     * 
     */
    delete<T extends KeywordAnalysisDeleteArgs>(args: SelectSubset<T, KeywordAnalysisDeleteArgs<ExtArgs>>): Prisma__KeywordAnalysisClient<$Result.GetResult<Prisma.$KeywordAnalysisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KeywordAnalysis.
     * @param {KeywordAnalysisUpdateArgs} args - Arguments to update one KeywordAnalysis.
     * @example
     * // Update one KeywordAnalysis
     * const keywordAnalysis = await prisma.keywordAnalysis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KeywordAnalysisUpdateArgs>(args: SelectSubset<T, KeywordAnalysisUpdateArgs<ExtArgs>>): Prisma__KeywordAnalysisClient<$Result.GetResult<Prisma.$KeywordAnalysisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KeywordAnalyses.
     * @param {KeywordAnalysisDeleteManyArgs} args - Arguments to filter KeywordAnalyses to delete.
     * @example
     * // Delete a few KeywordAnalyses
     * const { count } = await prisma.keywordAnalysis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KeywordAnalysisDeleteManyArgs>(args?: SelectSubset<T, KeywordAnalysisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KeywordAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordAnalysisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KeywordAnalyses
     * const keywordAnalysis = await prisma.keywordAnalysis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KeywordAnalysisUpdateManyArgs>(args: SelectSubset<T, KeywordAnalysisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KeywordAnalysis.
     * @param {KeywordAnalysisUpsertArgs} args - Arguments to update or create a KeywordAnalysis.
     * @example
     * // Update or create a KeywordAnalysis
     * const keywordAnalysis = await prisma.keywordAnalysis.upsert({
     *   create: {
     *     // ... data to create a KeywordAnalysis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KeywordAnalysis we want to update
     *   }
     * })
     */
    upsert<T extends KeywordAnalysisUpsertArgs>(args: SelectSubset<T, KeywordAnalysisUpsertArgs<ExtArgs>>): Prisma__KeywordAnalysisClient<$Result.GetResult<Prisma.$KeywordAnalysisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KeywordAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordAnalysisCountArgs} args - Arguments to filter KeywordAnalyses to count.
     * @example
     * // Count the number of KeywordAnalyses
     * const count = await prisma.keywordAnalysis.count({
     *   where: {
     *     // ... the filter for the KeywordAnalyses we want to count
     *   }
     * })
    **/
    count<T extends KeywordAnalysisCountArgs>(
      args?: Subset<T, KeywordAnalysisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KeywordAnalysisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KeywordAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordAnalysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KeywordAnalysisAggregateArgs>(args: Subset<T, KeywordAnalysisAggregateArgs>): Prisma.PrismaPromise<GetKeywordAnalysisAggregateType<T>>

    /**
     * Group by KeywordAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordAnalysisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KeywordAnalysisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KeywordAnalysisGroupByArgs['orderBy'] }
        : { orderBy?: KeywordAnalysisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KeywordAnalysisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKeywordAnalysisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KeywordAnalysis model
   */
  readonly fields: KeywordAnalysisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KeywordAnalysis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KeywordAnalysisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domain<T extends KeywordAnalysis$domainArgs<ExtArgs> = {}>(args?: Subset<T, KeywordAnalysis$domainArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KeywordAnalysis model
   */
  interface KeywordAnalysisFieldRefs {
    readonly id: FieldRef<"KeywordAnalysis", 'Int'>
    readonly domainId: FieldRef<"KeywordAnalysis", 'Int'>
    readonly keywords: FieldRef<"KeywordAnalysis", 'Json'>
    readonly searchVolumeData: FieldRef<"KeywordAnalysis", 'Json'>
    readonly intentClassification: FieldRef<"KeywordAnalysis", 'Json'>
    readonly competitiveAnalysis: FieldRef<"KeywordAnalysis", 'Json'>
    readonly tokenUsage: FieldRef<"KeywordAnalysis", 'Int'>
    readonly createdAt: FieldRef<"KeywordAnalysis", 'DateTime'>
    readonly updatedAt: FieldRef<"KeywordAnalysis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KeywordAnalysis findUnique
   */
  export type KeywordAnalysisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordAnalysis
     */
    select?: KeywordAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordAnalysis
     */
    omit?: KeywordAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which KeywordAnalysis to fetch.
     */
    where: KeywordAnalysisWhereUniqueInput
  }

  /**
   * KeywordAnalysis findUniqueOrThrow
   */
  export type KeywordAnalysisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordAnalysis
     */
    select?: KeywordAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordAnalysis
     */
    omit?: KeywordAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which KeywordAnalysis to fetch.
     */
    where: KeywordAnalysisWhereUniqueInput
  }

  /**
   * KeywordAnalysis findFirst
   */
  export type KeywordAnalysisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordAnalysis
     */
    select?: KeywordAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordAnalysis
     */
    omit?: KeywordAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which KeywordAnalysis to fetch.
     */
    where?: KeywordAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeywordAnalyses to fetch.
     */
    orderBy?: KeywordAnalysisOrderByWithRelationInput | KeywordAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KeywordAnalyses.
     */
    cursor?: KeywordAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeywordAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeywordAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KeywordAnalyses.
     */
    distinct?: KeywordAnalysisScalarFieldEnum | KeywordAnalysisScalarFieldEnum[]
  }

  /**
   * KeywordAnalysis findFirstOrThrow
   */
  export type KeywordAnalysisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordAnalysis
     */
    select?: KeywordAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordAnalysis
     */
    omit?: KeywordAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which KeywordAnalysis to fetch.
     */
    where?: KeywordAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeywordAnalyses to fetch.
     */
    orderBy?: KeywordAnalysisOrderByWithRelationInput | KeywordAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KeywordAnalyses.
     */
    cursor?: KeywordAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeywordAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeywordAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KeywordAnalyses.
     */
    distinct?: KeywordAnalysisScalarFieldEnum | KeywordAnalysisScalarFieldEnum[]
  }

  /**
   * KeywordAnalysis findMany
   */
  export type KeywordAnalysisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordAnalysis
     */
    select?: KeywordAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordAnalysis
     */
    omit?: KeywordAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which KeywordAnalyses to fetch.
     */
    where?: KeywordAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeywordAnalyses to fetch.
     */
    orderBy?: KeywordAnalysisOrderByWithRelationInput | KeywordAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KeywordAnalyses.
     */
    cursor?: KeywordAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeywordAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeywordAnalyses.
     */
    skip?: number
    distinct?: KeywordAnalysisScalarFieldEnum | KeywordAnalysisScalarFieldEnum[]
  }

  /**
   * KeywordAnalysis create
   */
  export type KeywordAnalysisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordAnalysis
     */
    select?: KeywordAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordAnalysis
     */
    omit?: KeywordAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to create a KeywordAnalysis.
     */
    data: XOR<KeywordAnalysisCreateInput, KeywordAnalysisUncheckedCreateInput>
  }

  /**
   * KeywordAnalysis createMany
   */
  export type KeywordAnalysisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KeywordAnalyses.
     */
    data: KeywordAnalysisCreateManyInput | KeywordAnalysisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KeywordAnalysis createManyAndReturn
   */
  export type KeywordAnalysisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordAnalysis
     */
    select?: KeywordAnalysisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordAnalysis
     */
    omit?: KeywordAnalysisOmit<ExtArgs> | null
    /**
     * The data used to create many KeywordAnalyses.
     */
    data: KeywordAnalysisCreateManyInput | KeywordAnalysisCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordAnalysisIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KeywordAnalysis update
   */
  export type KeywordAnalysisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordAnalysis
     */
    select?: KeywordAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordAnalysis
     */
    omit?: KeywordAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to update a KeywordAnalysis.
     */
    data: XOR<KeywordAnalysisUpdateInput, KeywordAnalysisUncheckedUpdateInput>
    /**
     * Choose, which KeywordAnalysis to update.
     */
    where: KeywordAnalysisWhereUniqueInput
  }

  /**
   * KeywordAnalysis updateMany
   */
  export type KeywordAnalysisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KeywordAnalyses.
     */
    data: XOR<KeywordAnalysisUpdateManyMutationInput, KeywordAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which KeywordAnalyses to update
     */
    where?: KeywordAnalysisWhereInput
  }

  /**
   * KeywordAnalysis upsert
   */
  export type KeywordAnalysisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordAnalysis
     */
    select?: KeywordAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordAnalysis
     */
    omit?: KeywordAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordAnalysisInclude<ExtArgs> | null
    /**
     * The filter to search for the KeywordAnalysis to update in case it exists.
     */
    where: KeywordAnalysisWhereUniqueInput
    /**
     * In case the KeywordAnalysis found by the `where` argument doesn't exist, create a new KeywordAnalysis with this data.
     */
    create: XOR<KeywordAnalysisCreateInput, KeywordAnalysisUncheckedCreateInput>
    /**
     * In case the KeywordAnalysis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KeywordAnalysisUpdateInput, KeywordAnalysisUncheckedUpdateInput>
  }

  /**
   * KeywordAnalysis delete
   */
  export type KeywordAnalysisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordAnalysis
     */
    select?: KeywordAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordAnalysis
     */
    omit?: KeywordAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordAnalysisInclude<ExtArgs> | null
    /**
     * Filter which KeywordAnalysis to delete.
     */
    where: KeywordAnalysisWhereUniqueInput
  }

  /**
   * KeywordAnalysis deleteMany
   */
  export type KeywordAnalysisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KeywordAnalyses to delete
     */
    where?: KeywordAnalysisWhereInput
  }

  /**
   * KeywordAnalysis.domain
   */
  export type KeywordAnalysis$domainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    where?: DomainWhereInput
  }

  /**
   * KeywordAnalysis without action
   */
  export type KeywordAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordAnalysis
     */
    select?: KeywordAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordAnalysis
     */
    omit?: KeywordAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model SearchVolumeClassification
   */

  export type AggregateSearchVolumeClassification = {
    _count: SearchVolumeClassificationCountAggregateOutputType | null
    _avg: SearchVolumeClassificationAvgAggregateOutputType | null
    _sum: SearchVolumeClassificationSumAggregateOutputType | null
    _min: SearchVolumeClassificationMinAggregateOutputType | null
    _max: SearchVolumeClassificationMaxAggregateOutputType | null
  }

  export type SearchVolumeClassificationAvgAggregateOutputType = {
    id: number | null
    domainId: number | null
    tokenUsage: number | null
  }

  export type SearchVolumeClassificationSumAggregateOutputType = {
    id: number | null
    domainId: number | null
    tokenUsage: number | null
  }

  export type SearchVolumeClassificationMinAggregateOutputType = {
    id: number | null
    domainId: number | null
    tokenUsage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SearchVolumeClassificationMaxAggregateOutputType = {
    id: number | null
    domainId: number | null
    tokenUsage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SearchVolumeClassificationCountAggregateOutputType = {
    id: number
    domainId: number
    highVolumeKeywords: number
    mediumVolumeKeywords: number
    lowVolumeKeywords: number
    volumeTrends: number
    seasonalPatterns: number
    tokenUsage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SearchVolumeClassificationAvgAggregateInputType = {
    id?: true
    domainId?: true
    tokenUsage?: true
  }

  export type SearchVolumeClassificationSumAggregateInputType = {
    id?: true
    domainId?: true
    tokenUsage?: true
  }

  export type SearchVolumeClassificationMinAggregateInputType = {
    id?: true
    domainId?: true
    tokenUsage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SearchVolumeClassificationMaxAggregateInputType = {
    id?: true
    domainId?: true
    tokenUsage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SearchVolumeClassificationCountAggregateInputType = {
    id?: true
    domainId?: true
    highVolumeKeywords?: true
    mediumVolumeKeywords?: true
    lowVolumeKeywords?: true
    volumeTrends?: true
    seasonalPatterns?: true
    tokenUsage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SearchVolumeClassificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchVolumeClassification to aggregate.
     */
    where?: SearchVolumeClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchVolumeClassifications to fetch.
     */
    orderBy?: SearchVolumeClassificationOrderByWithRelationInput | SearchVolumeClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SearchVolumeClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchVolumeClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchVolumeClassifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SearchVolumeClassifications
    **/
    _count?: true | SearchVolumeClassificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SearchVolumeClassificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SearchVolumeClassificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SearchVolumeClassificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SearchVolumeClassificationMaxAggregateInputType
  }

  export type GetSearchVolumeClassificationAggregateType<T extends SearchVolumeClassificationAggregateArgs> = {
        [P in keyof T & keyof AggregateSearchVolumeClassification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSearchVolumeClassification[P]>
      : GetScalarType<T[P], AggregateSearchVolumeClassification[P]>
  }




  export type SearchVolumeClassificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchVolumeClassificationWhereInput
    orderBy?: SearchVolumeClassificationOrderByWithAggregationInput | SearchVolumeClassificationOrderByWithAggregationInput[]
    by: SearchVolumeClassificationScalarFieldEnum[] | SearchVolumeClassificationScalarFieldEnum
    having?: SearchVolumeClassificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SearchVolumeClassificationCountAggregateInputType | true
    _avg?: SearchVolumeClassificationAvgAggregateInputType
    _sum?: SearchVolumeClassificationSumAggregateInputType
    _min?: SearchVolumeClassificationMinAggregateInputType
    _max?: SearchVolumeClassificationMaxAggregateInputType
  }

  export type SearchVolumeClassificationGroupByOutputType = {
    id: number
    domainId: number | null
    highVolumeKeywords: JsonValue
    mediumVolumeKeywords: JsonValue
    lowVolumeKeywords: JsonValue
    volumeTrends: JsonValue
    seasonalPatterns: JsonValue
    tokenUsage: number | null
    createdAt: Date
    updatedAt: Date
    _count: SearchVolumeClassificationCountAggregateOutputType | null
    _avg: SearchVolumeClassificationAvgAggregateOutputType | null
    _sum: SearchVolumeClassificationSumAggregateOutputType | null
    _min: SearchVolumeClassificationMinAggregateOutputType | null
    _max: SearchVolumeClassificationMaxAggregateOutputType | null
  }

  type GetSearchVolumeClassificationGroupByPayload<T extends SearchVolumeClassificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SearchVolumeClassificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SearchVolumeClassificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SearchVolumeClassificationGroupByOutputType[P]>
            : GetScalarType<T[P], SearchVolumeClassificationGroupByOutputType[P]>
        }
      >
    >


  export type SearchVolumeClassificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    highVolumeKeywords?: boolean
    mediumVolumeKeywords?: boolean
    lowVolumeKeywords?: boolean
    volumeTrends?: boolean
    seasonalPatterns?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domain?: boolean | SearchVolumeClassification$domainArgs<ExtArgs>
  }, ExtArgs["result"]["searchVolumeClassification"]>

  export type SearchVolumeClassificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    highVolumeKeywords?: boolean
    mediumVolumeKeywords?: boolean
    lowVolumeKeywords?: boolean
    volumeTrends?: boolean
    seasonalPatterns?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domain?: boolean | SearchVolumeClassification$domainArgs<ExtArgs>
  }, ExtArgs["result"]["searchVolumeClassification"]>


  export type SearchVolumeClassificationSelectScalar = {
    id?: boolean
    domainId?: boolean
    highVolumeKeywords?: boolean
    mediumVolumeKeywords?: boolean
    lowVolumeKeywords?: boolean
    volumeTrends?: boolean
    seasonalPatterns?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SearchVolumeClassificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "domainId" | "highVolumeKeywords" | "mediumVolumeKeywords" | "lowVolumeKeywords" | "volumeTrends" | "seasonalPatterns" | "tokenUsage" | "createdAt" | "updatedAt", ExtArgs["result"]["searchVolumeClassification"]>
  export type SearchVolumeClassificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | SearchVolumeClassification$domainArgs<ExtArgs>
  }
  export type SearchVolumeClassificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | SearchVolumeClassification$domainArgs<ExtArgs>
  }

  export type $SearchVolumeClassificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SearchVolumeClassification"
    objects: {
      domain: Prisma.$DomainPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      domainId: number | null
      highVolumeKeywords: Prisma.JsonValue
      mediumVolumeKeywords: Prisma.JsonValue
      lowVolumeKeywords: Prisma.JsonValue
      volumeTrends: Prisma.JsonValue
      seasonalPatterns: Prisma.JsonValue
      tokenUsage: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["searchVolumeClassification"]>
    composites: {}
  }

  type SearchVolumeClassificationGetPayload<S extends boolean | null | undefined | SearchVolumeClassificationDefaultArgs> = $Result.GetResult<Prisma.$SearchVolumeClassificationPayload, S>

  type SearchVolumeClassificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SearchVolumeClassificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SearchVolumeClassificationCountAggregateInputType | true
    }

  export interface SearchVolumeClassificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SearchVolumeClassification'], meta: { name: 'SearchVolumeClassification' } }
    /**
     * Find zero or one SearchVolumeClassification that matches the filter.
     * @param {SearchVolumeClassificationFindUniqueArgs} args - Arguments to find a SearchVolumeClassification
     * @example
     * // Get one SearchVolumeClassification
     * const searchVolumeClassification = await prisma.searchVolumeClassification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SearchVolumeClassificationFindUniqueArgs>(args: SelectSubset<T, SearchVolumeClassificationFindUniqueArgs<ExtArgs>>): Prisma__SearchVolumeClassificationClient<$Result.GetResult<Prisma.$SearchVolumeClassificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SearchVolumeClassification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SearchVolumeClassificationFindUniqueOrThrowArgs} args - Arguments to find a SearchVolumeClassification
     * @example
     * // Get one SearchVolumeClassification
     * const searchVolumeClassification = await prisma.searchVolumeClassification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SearchVolumeClassificationFindUniqueOrThrowArgs>(args: SelectSubset<T, SearchVolumeClassificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SearchVolumeClassificationClient<$Result.GetResult<Prisma.$SearchVolumeClassificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchVolumeClassification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchVolumeClassificationFindFirstArgs} args - Arguments to find a SearchVolumeClassification
     * @example
     * // Get one SearchVolumeClassification
     * const searchVolumeClassification = await prisma.searchVolumeClassification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SearchVolumeClassificationFindFirstArgs>(args?: SelectSubset<T, SearchVolumeClassificationFindFirstArgs<ExtArgs>>): Prisma__SearchVolumeClassificationClient<$Result.GetResult<Prisma.$SearchVolumeClassificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchVolumeClassification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchVolumeClassificationFindFirstOrThrowArgs} args - Arguments to find a SearchVolumeClassification
     * @example
     * // Get one SearchVolumeClassification
     * const searchVolumeClassification = await prisma.searchVolumeClassification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SearchVolumeClassificationFindFirstOrThrowArgs>(args?: SelectSubset<T, SearchVolumeClassificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SearchVolumeClassificationClient<$Result.GetResult<Prisma.$SearchVolumeClassificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SearchVolumeClassifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchVolumeClassificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SearchVolumeClassifications
     * const searchVolumeClassifications = await prisma.searchVolumeClassification.findMany()
     * 
     * // Get first 10 SearchVolumeClassifications
     * const searchVolumeClassifications = await prisma.searchVolumeClassification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const searchVolumeClassificationWithIdOnly = await prisma.searchVolumeClassification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SearchVolumeClassificationFindManyArgs>(args?: SelectSubset<T, SearchVolumeClassificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchVolumeClassificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SearchVolumeClassification.
     * @param {SearchVolumeClassificationCreateArgs} args - Arguments to create a SearchVolumeClassification.
     * @example
     * // Create one SearchVolumeClassification
     * const SearchVolumeClassification = await prisma.searchVolumeClassification.create({
     *   data: {
     *     // ... data to create a SearchVolumeClassification
     *   }
     * })
     * 
     */
    create<T extends SearchVolumeClassificationCreateArgs>(args: SelectSubset<T, SearchVolumeClassificationCreateArgs<ExtArgs>>): Prisma__SearchVolumeClassificationClient<$Result.GetResult<Prisma.$SearchVolumeClassificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SearchVolumeClassifications.
     * @param {SearchVolumeClassificationCreateManyArgs} args - Arguments to create many SearchVolumeClassifications.
     * @example
     * // Create many SearchVolumeClassifications
     * const searchVolumeClassification = await prisma.searchVolumeClassification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SearchVolumeClassificationCreateManyArgs>(args?: SelectSubset<T, SearchVolumeClassificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SearchVolumeClassifications and returns the data saved in the database.
     * @param {SearchVolumeClassificationCreateManyAndReturnArgs} args - Arguments to create many SearchVolumeClassifications.
     * @example
     * // Create many SearchVolumeClassifications
     * const searchVolumeClassification = await prisma.searchVolumeClassification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SearchVolumeClassifications and only return the `id`
     * const searchVolumeClassificationWithIdOnly = await prisma.searchVolumeClassification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SearchVolumeClassificationCreateManyAndReturnArgs>(args?: SelectSubset<T, SearchVolumeClassificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchVolumeClassificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SearchVolumeClassification.
     * @param {SearchVolumeClassificationDeleteArgs} args - Arguments to delete one SearchVolumeClassification.
     * @example
     * // Delete one SearchVolumeClassification
     * const SearchVolumeClassification = await prisma.searchVolumeClassification.delete({
     *   where: {
     *     // ... filter to delete one SearchVolumeClassification
     *   }
     * })
     * 
     */
    delete<T extends SearchVolumeClassificationDeleteArgs>(args: SelectSubset<T, SearchVolumeClassificationDeleteArgs<ExtArgs>>): Prisma__SearchVolumeClassificationClient<$Result.GetResult<Prisma.$SearchVolumeClassificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SearchVolumeClassification.
     * @param {SearchVolumeClassificationUpdateArgs} args - Arguments to update one SearchVolumeClassification.
     * @example
     * // Update one SearchVolumeClassification
     * const searchVolumeClassification = await prisma.searchVolumeClassification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SearchVolumeClassificationUpdateArgs>(args: SelectSubset<T, SearchVolumeClassificationUpdateArgs<ExtArgs>>): Prisma__SearchVolumeClassificationClient<$Result.GetResult<Prisma.$SearchVolumeClassificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SearchVolumeClassifications.
     * @param {SearchVolumeClassificationDeleteManyArgs} args - Arguments to filter SearchVolumeClassifications to delete.
     * @example
     * // Delete a few SearchVolumeClassifications
     * const { count } = await prisma.searchVolumeClassification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SearchVolumeClassificationDeleteManyArgs>(args?: SelectSubset<T, SearchVolumeClassificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchVolumeClassifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchVolumeClassificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SearchVolumeClassifications
     * const searchVolumeClassification = await prisma.searchVolumeClassification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SearchVolumeClassificationUpdateManyArgs>(args: SelectSubset<T, SearchVolumeClassificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SearchVolumeClassification.
     * @param {SearchVolumeClassificationUpsertArgs} args - Arguments to update or create a SearchVolumeClassification.
     * @example
     * // Update or create a SearchVolumeClassification
     * const searchVolumeClassification = await prisma.searchVolumeClassification.upsert({
     *   create: {
     *     // ... data to create a SearchVolumeClassification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SearchVolumeClassification we want to update
     *   }
     * })
     */
    upsert<T extends SearchVolumeClassificationUpsertArgs>(args: SelectSubset<T, SearchVolumeClassificationUpsertArgs<ExtArgs>>): Prisma__SearchVolumeClassificationClient<$Result.GetResult<Prisma.$SearchVolumeClassificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SearchVolumeClassifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchVolumeClassificationCountArgs} args - Arguments to filter SearchVolumeClassifications to count.
     * @example
     * // Count the number of SearchVolumeClassifications
     * const count = await prisma.searchVolumeClassification.count({
     *   where: {
     *     // ... the filter for the SearchVolumeClassifications we want to count
     *   }
     * })
    **/
    count<T extends SearchVolumeClassificationCountArgs>(
      args?: Subset<T, SearchVolumeClassificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SearchVolumeClassificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SearchVolumeClassification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchVolumeClassificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SearchVolumeClassificationAggregateArgs>(args: Subset<T, SearchVolumeClassificationAggregateArgs>): Prisma.PrismaPromise<GetSearchVolumeClassificationAggregateType<T>>

    /**
     * Group by SearchVolumeClassification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchVolumeClassificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SearchVolumeClassificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SearchVolumeClassificationGroupByArgs['orderBy'] }
        : { orderBy?: SearchVolumeClassificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SearchVolumeClassificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSearchVolumeClassificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SearchVolumeClassification model
   */
  readonly fields: SearchVolumeClassificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SearchVolumeClassification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SearchVolumeClassificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domain<T extends SearchVolumeClassification$domainArgs<ExtArgs> = {}>(args?: Subset<T, SearchVolumeClassification$domainArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SearchVolumeClassification model
   */
  interface SearchVolumeClassificationFieldRefs {
    readonly id: FieldRef<"SearchVolumeClassification", 'Int'>
    readonly domainId: FieldRef<"SearchVolumeClassification", 'Int'>
    readonly highVolumeKeywords: FieldRef<"SearchVolumeClassification", 'Json'>
    readonly mediumVolumeKeywords: FieldRef<"SearchVolumeClassification", 'Json'>
    readonly lowVolumeKeywords: FieldRef<"SearchVolumeClassification", 'Json'>
    readonly volumeTrends: FieldRef<"SearchVolumeClassification", 'Json'>
    readonly seasonalPatterns: FieldRef<"SearchVolumeClassification", 'Json'>
    readonly tokenUsage: FieldRef<"SearchVolumeClassification", 'Int'>
    readonly createdAt: FieldRef<"SearchVolumeClassification", 'DateTime'>
    readonly updatedAt: FieldRef<"SearchVolumeClassification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SearchVolumeClassification findUnique
   */
  export type SearchVolumeClassificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchVolumeClassification
     */
    select?: SearchVolumeClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchVolumeClassification
     */
    omit?: SearchVolumeClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchVolumeClassificationInclude<ExtArgs> | null
    /**
     * Filter, which SearchVolumeClassification to fetch.
     */
    where: SearchVolumeClassificationWhereUniqueInput
  }

  /**
   * SearchVolumeClassification findUniqueOrThrow
   */
  export type SearchVolumeClassificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchVolumeClassification
     */
    select?: SearchVolumeClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchVolumeClassification
     */
    omit?: SearchVolumeClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchVolumeClassificationInclude<ExtArgs> | null
    /**
     * Filter, which SearchVolumeClassification to fetch.
     */
    where: SearchVolumeClassificationWhereUniqueInput
  }

  /**
   * SearchVolumeClassification findFirst
   */
  export type SearchVolumeClassificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchVolumeClassification
     */
    select?: SearchVolumeClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchVolumeClassification
     */
    omit?: SearchVolumeClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchVolumeClassificationInclude<ExtArgs> | null
    /**
     * Filter, which SearchVolumeClassification to fetch.
     */
    where?: SearchVolumeClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchVolumeClassifications to fetch.
     */
    orderBy?: SearchVolumeClassificationOrderByWithRelationInput | SearchVolumeClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchVolumeClassifications.
     */
    cursor?: SearchVolumeClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchVolumeClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchVolumeClassifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchVolumeClassifications.
     */
    distinct?: SearchVolumeClassificationScalarFieldEnum | SearchVolumeClassificationScalarFieldEnum[]
  }

  /**
   * SearchVolumeClassification findFirstOrThrow
   */
  export type SearchVolumeClassificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchVolumeClassification
     */
    select?: SearchVolumeClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchVolumeClassification
     */
    omit?: SearchVolumeClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchVolumeClassificationInclude<ExtArgs> | null
    /**
     * Filter, which SearchVolumeClassification to fetch.
     */
    where?: SearchVolumeClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchVolumeClassifications to fetch.
     */
    orderBy?: SearchVolumeClassificationOrderByWithRelationInput | SearchVolumeClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchVolumeClassifications.
     */
    cursor?: SearchVolumeClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchVolumeClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchVolumeClassifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchVolumeClassifications.
     */
    distinct?: SearchVolumeClassificationScalarFieldEnum | SearchVolumeClassificationScalarFieldEnum[]
  }

  /**
   * SearchVolumeClassification findMany
   */
  export type SearchVolumeClassificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchVolumeClassification
     */
    select?: SearchVolumeClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchVolumeClassification
     */
    omit?: SearchVolumeClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchVolumeClassificationInclude<ExtArgs> | null
    /**
     * Filter, which SearchVolumeClassifications to fetch.
     */
    where?: SearchVolumeClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchVolumeClassifications to fetch.
     */
    orderBy?: SearchVolumeClassificationOrderByWithRelationInput | SearchVolumeClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SearchVolumeClassifications.
     */
    cursor?: SearchVolumeClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchVolumeClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchVolumeClassifications.
     */
    skip?: number
    distinct?: SearchVolumeClassificationScalarFieldEnum | SearchVolumeClassificationScalarFieldEnum[]
  }

  /**
   * SearchVolumeClassification create
   */
  export type SearchVolumeClassificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchVolumeClassification
     */
    select?: SearchVolumeClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchVolumeClassification
     */
    omit?: SearchVolumeClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchVolumeClassificationInclude<ExtArgs> | null
    /**
     * The data needed to create a SearchVolumeClassification.
     */
    data: XOR<SearchVolumeClassificationCreateInput, SearchVolumeClassificationUncheckedCreateInput>
  }

  /**
   * SearchVolumeClassification createMany
   */
  export type SearchVolumeClassificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SearchVolumeClassifications.
     */
    data: SearchVolumeClassificationCreateManyInput | SearchVolumeClassificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SearchVolumeClassification createManyAndReturn
   */
  export type SearchVolumeClassificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchVolumeClassification
     */
    select?: SearchVolumeClassificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SearchVolumeClassification
     */
    omit?: SearchVolumeClassificationOmit<ExtArgs> | null
    /**
     * The data used to create many SearchVolumeClassifications.
     */
    data: SearchVolumeClassificationCreateManyInput | SearchVolumeClassificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchVolumeClassificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SearchVolumeClassification update
   */
  export type SearchVolumeClassificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchVolumeClassification
     */
    select?: SearchVolumeClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchVolumeClassification
     */
    omit?: SearchVolumeClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchVolumeClassificationInclude<ExtArgs> | null
    /**
     * The data needed to update a SearchVolumeClassification.
     */
    data: XOR<SearchVolumeClassificationUpdateInput, SearchVolumeClassificationUncheckedUpdateInput>
    /**
     * Choose, which SearchVolumeClassification to update.
     */
    where: SearchVolumeClassificationWhereUniqueInput
  }

  /**
   * SearchVolumeClassification updateMany
   */
  export type SearchVolumeClassificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SearchVolumeClassifications.
     */
    data: XOR<SearchVolumeClassificationUpdateManyMutationInput, SearchVolumeClassificationUncheckedUpdateManyInput>
    /**
     * Filter which SearchVolumeClassifications to update
     */
    where?: SearchVolumeClassificationWhereInput
  }

  /**
   * SearchVolumeClassification upsert
   */
  export type SearchVolumeClassificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchVolumeClassification
     */
    select?: SearchVolumeClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchVolumeClassification
     */
    omit?: SearchVolumeClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchVolumeClassificationInclude<ExtArgs> | null
    /**
     * The filter to search for the SearchVolumeClassification to update in case it exists.
     */
    where: SearchVolumeClassificationWhereUniqueInput
    /**
     * In case the SearchVolumeClassification found by the `where` argument doesn't exist, create a new SearchVolumeClassification with this data.
     */
    create: XOR<SearchVolumeClassificationCreateInput, SearchVolumeClassificationUncheckedCreateInput>
    /**
     * In case the SearchVolumeClassification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SearchVolumeClassificationUpdateInput, SearchVolumeClassificationUncheckedUpdateInput>
  }

  /**
   * SearchVolumeClassification delete
   */
  export type SearchVolumeClassificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchVolumeClassification
     */
    select?: SearchVolumeClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchVolumeClassification
     */
    omit?: SearchVolumeClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchVolumeClassificationInclude<ExtArgs> | null
    /**
     * Filter which SearchVolumeClassification to delete.
     */
    where: SearchVolumeClassificationWhereUniqueInput
  }

  /**
   * SearchVolumeClassification deleteMany
   */
  export type SearchVolumeClassificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchVolumeClassifications to delete
     */
    where?: SearchVolumeClassificationWhereInput
  }

  /**
   * SearchVolumeClassification.domain
   */
  export type SearchVolumeClassification$domainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    where?: DomainWhereInput
  }

  /**
   * SearchVolumeClassification without action
   */
  export type SearchVolumeClassificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchVolumeClassification
     */
    select?: SearchVolumeClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchVolumeClassification
     */
    omit?: SearchVolumeClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchVolumeClassificationInclude<ExtArgs> | null
  }


  /**
   * Model IntentClassification
   */

  export type AggregateIntentClassification = {
    _count: IntentClassificationCountAggregateOutputType | null
    _avg: IntentClassificationAvgAggregateOutputType | null
    _sum: IntentClassificationSumAggregateOutputType | null
    _min: IntentClassificationMinAggregateOutputType | null
    _max: IntentClassificationMaxAggregateOutputType | null
  }

  export type IntentClassificationAvgAggregateOutputType = {
    id: number | null
    domainId: number | null
    tokenUsage: number | null
  }

  export type IntentClassificationSumAggregateOutputType = {
    id: number | null
    domainId: number | null
    tokenUsage: number | null
  }

  export type IntentClassificationMinAggregateOutputType = {
    id: number | null
    domainId: number | null
    tokenUsage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntentClassificationMaxAggregateOutputType = {
    id: number | null
    domainId: number | null
    tokenUsage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntentClassificationCountAggregateOutputType = {
    id: number
    domainId: number
    informationalKeywords: number
    navigationalKeywords: number
    transactionalKeywords: number
    commercialKeywords: number
    intentDistribution: number
    tokenUsage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntentClassificationAvgAggregateInputType = {
    id?: true
    domainId?: true
    tokenUsage?: true
  }

  export type IntentClassificationSumAggregateInputType = {
    id?: true
    domainId?: true
    tokenUsage?: true
  }

  export type IntentClassificationMinAggregateInputType = {
    id?: true
    domainId?: true
    tokenUsage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntentClassificationMaxAggregateInputType = {
    id?: true
    domainId?: true
    tokenUsage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntentClassificationCountAggregateInputType = {
    id?: true
    domainId?: true
    informationalKeywords?: true
    navigationalKeywords?: true
    transactionalKeywords?: true
    commercialKeywords?: true
    intentDistribution?: true
    tokenUsage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntentClassificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntentClassification to aggregate.
     */
    where?: IntentClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntentClassifications to fetch.
     */
    orderBy?: IntentClassificationOrderByWithRelationInput | IntentClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntentClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntentClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntentClassifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntentClassifications
    **/
    _count?: true | IntentClassificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntentClassificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntentClassificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntentClassificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntentClassificationMaxAggregateInputType
  }

  export type GetIntentClassificationAggregateType<T extends IntentClassificationAggregateArgs> = {
        [P in keyof T & keyof AggregateIntentClassification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntentClassification[P]>
      : GetScalarType<T[P], AggregateIntentClassification[P]>
  }




  export type IntentClassificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntentClassificationWhereInput
    orderBy?: IntentClassificationOrderByWithAggregationInput | IntentClassificationOrderByWithAggregationInput[]
    by: IntentClassificationScalarFieldEnum[] | IntentClassificationScalarFieldEnum
    having?: IntentClassificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntentClassificationCountAggregateInputType | true
    _avg?: IntentClassificationAvgAggregateInputType
    _sum?: IntentClassificationSumAggregateInputType
    _min?: IntentClassificationMinAggregateInputType
    _max?: IntentClassificationMaxAggregateInputType
  }

  export type IntentClassificationGroupByOutputType = {
    id: number
    domainId: number | null
    informationalKeywords: JsonValue
    navigationalKeywords: JsonValue
    transactionalKeywords: JsonValue
    commercialKeywords: JsonValue
    intentDistribution: JsonValue
    tokenUsage: number | null
    createdAt: Date
    updatedAt: Date
    _count: IntentClassificationCountAggregateOutputType | null
    _avg: IntentClassificationAvgAggregateOutputType | null
    _sum: IntentClassificationSumAggregateOutputType | null
    _min: IntentClassificationMinAggregateOutputType | null
    _max: IntentClassificationMaxAggregateOutputType | null
  }

  type GetIntentClassificationGroupByPayload<T extends IntentClassificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntentClassificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntentClassificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntentClassificationGroupByOutputType[P]>
            : GetScalarType<T[P], IntentClassificationGroupByOutputType[P]>
        }
      >
    >


  export type IntentClassificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    informationalKeywords?: boolean
    navigationalKeywords?: boolean
    transactionalKeywords?: boolean
    commercialKeywords?: boolean
    intentDistribution?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domain?: boolean | IntentClassification$domainArgs<ExtArgs>
  }, ExtArgs["result"]["intentClassification"]>

  export type IntentClassificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    informationalKeywords?: boolean
    navigationalKeywords?: boolean
    transactionalKeywords?: boolean
    commercialKeywords?: boolean
    intentDistribution?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domain?: boolean | IntentClassification$domainArgs<ExtArgs>
  }, ExtArgs["result"]["intentClassification"]>


  export type IntentClassificationSelectScalar = {
    id?: boolean
    domainId?: boolean
    informationalKeywords?: boolean
    navigationalKeywords?: boolean
    transactionalKeywords?: boolean
    commercialKeywords?: boolean
    intentDistribution?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntentClassificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "domainId" | "informationalKeywords" | "navigationalKeywords" | "transactionalKeywords" | "commercialKeywords" | "intentDistribution" | "tokenUsage" | "createdAt" | "updatedAt", ExtArgs["result"]["intentClassification"]>
  export type IntentClassificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | IntentClassification$domainArgs<ExtArgs>
  }
  export type IntentClassificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | IntentClassification$domainArgs<ExtArgs>
  }

  export type $IntentClassificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IntentClassification"
    objects: {
      domain: Prisma.$DomainPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      domainId: number | null
      informationalKeywords: Prisma.JsonValue
      navigationalKeywords: Prisma.JsonValue
      transactionalKeywords: Prisma.JsonValue
      commercialKeywords: Prisma.JsonValue
      intentDistribution: Prisma.JsonValue
      tokenUsage: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["intentClassification"]>
    composites: {}
  }

  type IntentClassificationGetPayload<S extends boolean | null | undefined | IntentClassificationDefaultArgs> = $Result.GetResult<Prisma.$IntentClassificationPayload, S>

  type IntentClassificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IntentClassificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IntentClassificationCountAggregateInputType | true
    }

  export interface IntentClassificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IntentClassification'], meta: { name: 'IntentClassification' } }
    /**
     * Find zero or one IntentClassification that matches the filter.
     * @param {IntentClassificationFindUniqueArgs} args - Arguments to find a IntentClassification
     * @example
     * // Get one IntentClassification
     * const intentClassification = await prisma.intentClassification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntentClassificationFindUniqueArgs>(args: SelectSubset<T, IntentClassificationFindUniqueArgs<ExtArgs>>): Prisma__IntentClassificationClient<$Result.GetResult<Prisma.$IntentClassificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IntentClassification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IntentClassificationFindUniqueOrThrowArgs} args - Arguments to find a IntentClassification
     * @example
     * // Get one IntentClassification
     * const intentClassification = await prisma.intentClassification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntentClassificationFindUniqueOrThrowArgs>(args: SelectSubset<T, IntentClassificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntentClassificationClient<$Result.GetResult<Prisma.$IntentClassificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IntentClassification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentClassificationFindFirstArgs} args - Arguments to find a IntentClassification
     * @example
     * // Get one IntentClassification
     * const intentClassification = await prisma.intentClassification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntentClassificationFindFirstArgs>(args?: SelectSubset<T, IntentClassificationFindFirstArgs<ExtArgs>>): Prisma__IntentClassificationClient<$Result.GetResult<Prisma.$IntentClassificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IntentClassification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentClassificationFindFirstOrThrowArgs} args - Arguments to find a IntentClassification
     * @example
     * // Get one IntentClassification
     * const intentClassification = await prisma.intentClassification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntentClassificationFindFirstOrThrowArgs>(args?: SelectSubset<T, IntentClassificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntentClassificationClient<$Result.GetResult<Prisma.$IntentClassificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IntentClassifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentClassificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntentClassifications
     * const intentClassifications = await prisma.intentClassification.findMany()
     * 
     * // Get first 10 IntentClassifications
     * const intentClassifications = await prisma.intentClassification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const intentClassificationWithIdOnly = await prisma.intentClassification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntentClassificationFindManyArgs>(args?: SelectSubset<T, IntentClassificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntentClassificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IntentClassification.
     * @param {IntentClassificationCreateArgs} args - Arguments to create a IntentClassification.
     * @example
     * // Create one IntentClassification
     * const IntentClassification = await prisma.intentClassification.create({
     *   data: {
     *     // ... data to create a IntentClassification
     *   }
     * })
     * 
     */
    create<T extends IntentClassificationCreateArgs>(args: SelectSubset<T, IntentClassificationCreateArgs<ExtArgs>>): Prisma__IntentClassificationClient<$Result.GetResult<Prisma.$IntentClassificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IntentClassifications.
     * @param {IntentClassificationCreateManyArgs} args - Arguments to create many IntentClassifications.
     * @example
     * // Create many IntentClassifications
     * const intentClassification = await prisma.intentClassification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntentClassificationCreateManyArgs>(args?: SelectSubset<T, IntentClassificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IntentClassifications and returns the data saved in the database.
     * @param {IntentClassificationCreateManyAndReturnArgs} args - Arguments to create many IntentClassifications.
     * @example
     * // Create many IntentClassifications
     * const intentClassification = await prisma.intentClassification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IntentClassifications and only return the `id`
     * const intentClassificationWithIdOnly = await prisma.intentClassification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntentClassificationCreateManyAndReturnArgs>(args?: SelectSubset<T, IntentClassificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntentClassificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IntentClassification.
     * @param {IntentClassificationDeleteArgs} args - Arguments to delete one IntentClassification.
     * @example
     * // Delete one IntentClassification
     * const IntentClassification = await prisma.intentClassification.delete({
     *   where: {
     *     // ... filter to delete one IntentClassification
     *   }
     * })
     * 
     */
    delete<T extends IntentClassificationDeleteArgs>(args: SelectSubset<T, IntentClassificationDeleteArgs<ExtArgs>>): Prisma__IntentClassificationClient<$Result.GetResult<Prisma.$IntentClassificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IntentClassification.
     * @param {IntentClassificationUpdateArgs} args - Arguments to update one IntentClassification.
     * @example
     * // Update one IntentClassification
     * const intentClassification = await prisma.intentClassification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntentClassificationUpdateArgs>(args: SelectSubset<T, IntentClassificationUpdateArgs<ExtArgs>>): Prisma__IntentClassificationClient<$Result.GetResult<Prisma.$IntentClassificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IntentClassifications.
     * @param {IntentClassificationDeleteManyArgs} args - Arguments to filter IntentClassifications to delete.
     * @example
     * // Delete a few IntentClassifications
     * const { count } = await prisma.intentClassification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntentClassificationDeleteManyArgs>(args?: SelectSubset<T, IntentClassificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntentClassifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentClassificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntentClassifications
     * const intentClassification = await prisma.intentClassification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntentClassificationUpdateManyArgs>(args: SelectSubset<T, IntentClassificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IntentClassification.
     * @param {IntentClassificationUpsertArgs} args - Arguments to update or create a IntentClassification.
     * @example
     * // Update or create a IntentClassification
     * const intentClassification = await prisma.intentClassification.upsert({
     *   create: {
     *     // ... data to create a IntentClassification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntentClassification we want to update
     *   }
     * })
     */
    upsert<T extends IntentClassificationUpsertArgs>(args: SelectSubset<T, IntentClassificationUpsertArgs<ExtArgs>>): Prisma__IntentClassificationClient<$Result.GetResult<Prisma.$IntentClassificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IntentClassifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentClassificationCountArgs} args - Arguments to filter IntentClassifications to count.
     * @example
     * // Count the number of IntentClassifications
     * const count = await prisma.intentClassification.count({
     *   where: {
     *     // ... the filter for the IntentClassifications we want to count
     *   }
     * })
    **/
    count<T extends IntentClassificationCountArgs>(
      args?: Subset<T, IntentClassificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntentClassificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntentClassification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentClassificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntentClassificationAggregateArgs>(args: Subset<T, IntentClassificationAggregateArgs>): Prisma.PrismaPromise<GetIntentClassificationAggregateType<T>>

    /**
     * Group by IntentClassification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentClassificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntentClassificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntentClassificationGroupByArgs['orderBy'] }
        : { orderBy?: IntentClassificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntentClassificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntentClassificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IntentClassification model
   */
  readonly fields: IntentClassificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntentClassification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntentClassificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domain<T extends IntentClassification$domainArgs<ExtArgs> = {}>(args?: Subset<T, IntentClassification$domainArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IntentClassification model
   */
  interface IntentClassificationFieldRefs {
    readonly id: FieldRef<"IntentClassification", 'Int'>
    readonly domainId: FieldRef<"IntentClassification", 'Int'>
    readonly informationalKeywords: FieldRef<"IntentClassification", 'Json'>
    readonly navigationalKeywords: FieldRef<"IntentClassification", 'Json'>
    readonly transactionalKeywords: FieldRef<"IntentClassification", 'Json'>
    readonly commercialKeywords: FieldRef<"IntentClassification", 'Json'>
    readonly intentDistribution: FieldRef<"IntentClassification", 'Json'>
    readonly tokenUsage: FieldRef<"IntentClassification", 'Int'>
    readonly createdAt: FieldRef<"IntentClassification", 'DateTime'>
    readonly updatedAt: FieldRef<"IntentClassification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IntentClassification findUnique
   */
  export type IntentClassificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentClassification
     */
    select?: IntentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentClassification
     */
    omit?: IntentClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentClassificationInclude<ExtArgs> | null
    /**
     * Filter, which IntentClassification to fetch.
     */
    where: IntentClassificationWhereUniqueInput
  }

  /**
   * IntentClassification findUniqueOrThrow
   */
  export type IntentClassificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentClassification
     */
    select?: IntentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentClassification
     */
    omit?: IntentClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentClassificationInclude<ExtArgs> | null
    /**
     * Filter, which IntentClassification to fetch.
     */
    where: IntentClassificationWhereUniqueInput
  }

  /**
   * IntentClassification findFirst
   */
  export type IntentClassificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentClassification
     */
    select?: IntentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentClassification
     */
    omit?: IntentClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentClassificationInclude<ExtArgs> | null
    /**
     * Filter, which IntentClassification to fetch.
     */
    where?: IntentClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntentClassifications to fetch.
     */
    orderBy?: IntentClassificationOrderByWithRelationInput | IntentClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntentClassifications.
     */
    cursor?: IntentClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntentClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntentClassifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntentClassifications.
     */
    distinct?: IntentClassificationScalarFieldEnum | IntentClassificationScalarFieldEnum[]
  }

  /**
   * IntentClassification findFirstOrThrow
   */
  export type IntentClassificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentClassification
     */
    select?: IntentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentClassification
     */
    omit?: IntentClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentClassificationInclude<ExtArgs> | null
    /**
     * Filter, which IntentClassification to fetch.
     */
    where?: IntentClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntentClassifications to fetch.
     */
    orderBy?: IntentClassificationOrderByWithRelationInput | IntentClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntentClassifications.
     */
    cursor?: IntentClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntentClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntentClassifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntentClassifications.
     */
    distinct?: IntentClassificationScalarFieldEnum | IntentClassificationScalarFieldEnum[]
  }

  /**
   * IntentClassification findMany
   */
  export type IntentClassificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentClassification
     */
    select?: IntentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentClassification
     */
    omit?: IntentClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentClassificationInclude<ExtArgs> | null
    /**
     * Filter, which IntentClassifications to fetch.
     */
    where?: IntentClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntentClassifications to fetch.
     */
    orderBy?: IntentClassificationOrderByWithRelationInput | IntentClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntentClassifications.
     */
    cursor?: IntentClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntentClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntentClassifications.
     */
    skip?: number
    distinct?: IntentClassificationScalarFieldEnum | IntentClassificationScalarFieldEnum[]
  }

  /**
   * IntentClassification create
   */
  export type IntentClassificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentClassification
     */
    select?: IntentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentClassification
     */
    omit?: IntentClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentClassificationInclude<ExtArgs> | null
    /**
     * The data needed to create a IntentClassification.
     */
    data: XOR<IntentClassificationCreateInput, IntentClassificationUncheckedCreateInput>
  }

  /**
   * IntentClassification createMany
   */
  export type IntentClassificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IntentClassifications.
     */
    data: IntentClassificationCreateManyInput | IntentClassificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IntentClassification createManyAndReturn
   */
  export type IntentClassificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentClassification
     */
    select?: IntentClassificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IntentClassification
     */
    omit?: IntentClassificationOmit<ExtArgs> | null
    /**
     * The data used to create many IntentClassifications.
     */
    data: IntentClassificationCreateManyInput | IntentClassificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentClassificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IntentClassification update
   */
  export type IntentClassificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentClassification
     */
    select?: IntentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentClassification
     */
    omit?: IntentClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentClassificationInclude<ExtArgs> | null
    /**
     * The data needed to update a IntentClassification.
     */
    data: XOR<IntentClassificationUpdateInput, IntentClassificationUncheckedUpdateInput>
    /**
     * Choose, which IntentClassification to update.
     */
    where: IntentClassificationWhereUniqueInput
  }

  /**
   * IntentClassification updateMany
   */
  export type IntentClassificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IntentClassifications.
     */
    data: XOR<IntentClassificationUpdateManyMutationInput, IntentClassificationUncheckedUpdateManyInput>
    /**
     * Filter which IntentClassifications to update
     */
    where?: IntentClassificationWhereInput
  }

  /**
   * IntentClassification upsert
   */
  export type IntentClassificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentClassification
     */
    select?: IntentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentClassification
     */
    omit?: IntentClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentClassificationInclude<ExtArgs> | null
    /**
     * The filter to search for the IntentClassification to update in case it exists.
     */
    where: IntentClassificationWhereUniqueInput
    /**
     * In case the IntentClassification found by the `where` argument doesn't exist, create a new IntentClassification with this data.
     */
    create: XOR<IntentClassificationCreateInput, IntentClassificationUncheckedCreateInput>
    /**
     * In case the IntentClassification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntentClassificationUpdateInput, IntentClassificationUncheckedUpdateInput>
  }

  /**
   * IntentClassification delete
   */
  export type IntentClassificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentClassification
     */
    select?: IntentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentClassification
     */
    omit?: IntentClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentClassificationInclude<ExtArgs> | null
    /**
     * Filter which IntentClassification to delete.
     */
    where: IntentClassificationWhereUniqueInput
  }

  /**
   * IntentClassification deleteMany
   */
  export type IntentClassificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntentClassifications to delete
     */
    where?: IntentClassificationWhereInput
  }

  /**
   * IntentClassification.domain
   */
  export type IntentClassification$domainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    where?: DomainWhereInput
  }

  /**
   * IntentClassification without action
   */
  export type IntentClassificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentClassification
     */
    select?: IntentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentClassification
     */
    omit?: IntentClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentClassificationInclude<ExtArgs> | null
  }


  /**
   * Model CommunityInsight
   */

  export type AggregateCommunityInsight = {
    _count: CommunityInsightCountAggregateOutputType | null
    _avg: CommunityInsightAvgAggregateOutputType | null
    _sum: CommunityInsightSumAggregateOutputType | null
    _min: CommunityInsightMinAggregateOutputType | null
    _max: CommunityInsightMaxAggregateOutputType | null
  }

  export type CommunityInsightAvgAggregateOutputType = {
    id: number | null
    domainId: number | null
    keywordId: number | null
    tokenUsage: number | null
  }

  export type CommunityInsightSumAggregateOutputType = {
    id: number | null
    domainId: number | null
    keywordId: number | null
    tokenUsage: number | null
  }

  export type CommunityInsightMinAggregateOutputType = {
    id: number | null
    domainId: number | null
    keywordId: number | null
    summary: string | null
    tokenUsage: number | null
    createdAt: Date | null
  }

  export type CommunityInsightMaxAggregateOutputType = {
    id: number | null
    domainId: number | null
    keywordId: number | null
    summary: string | null
    tokenUsage: number | null
    createdAt: Date | null
  }

  export type CommunityInsightCountAggregateOutputType = {
    id: number
    domainId: number
    keywordId: number
    sources: number
    summary: number
    tokenUsage: number
    createdAt: number
    _all: number
  }


  export type CommunityInsightAvgAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    tokenUsage?: true
  }

  export type CommunityInsightSumAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    tokenUsage?: true
  }

  export type CommunityInsightMinAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    summary?: true
    tokenUsage?: true
    createdAt?: true
  }

  export type CommunityInsightMaxAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    summary?: true
    tokenUsage?: true
    createdAt?: true
  }

  export type CommunityInsightCountAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    sources?: true
    summary?: true
    tokenUsage?: true
    createdAt?: true
    _all?: true
  }

  export type CommunityInsightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityInsight to aggregate.
     */
    where?: CommunityInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityInsights to fetch.
     */
    orderBy?: CommunityInsightOrderByWithRelationInput | CommunityInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityInsights
    **/
    _count?: true | CommunityInsightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityInsightAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunityInsightSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityInsightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityInsightMaxAggregateInputType
  }

  export type GetCommunityInsightAggregateType<T extends CommunityInsightAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunityInsight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityInsight[P]>
      : GetScalarType<T[P], AggregateCommunityInsight[P]>
  }




  export type CommunityInsightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityInsightWhereInput
    orderBy?: CommunityInsightOrderByWithAggregationInput | CommunityInsightOrderByWithAggregationInput[]
    by: CommunityInsightScalarFieldEnum[] | CommunityInsightScalarFieldEnum
    having?: CommunityInsightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityInsightCountAggregateInputType | true
    _avg?: CommunityInsightAvgAggregateInputType
    _sum?: CommunityInsightSumAggregateInputType
    _min?: CommunityInsightMinAggregateInputType
    _max?: CommunityInsightMaxAggregateInputType
  }

  export type CommunityInsightGroupByOutputType = {
    id: number
    domainId: number | null
    keywordId: number | null
    sources: JsonValue
    summary: string
    tokenUsage: number | null
    createdAt: Date
    _count: CommunityInsightCountAggregateOutputType | null
    _avg: CommunityInsightAvgAggregateOutputType | null
    _sum: CommunityInsightSumAggregateOutputType | null
    _min: CommunityInsightMinAggregateOutputType | null
    _max: CommunityInsightMaxAggregateOutputType | null
  }

  type GetCommunityInsightGroupByPayload<T extends CommunityInsightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityInsightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityInsightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityInsightGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityInsightGroupByOutputType[P]>
        }
      >
    >


  export type CommunityInsightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    keywordId?: boolean
    sources?: boolean
    summary?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    domain?: boolean | CommunityInsight$domainArgs<ExtArgs>
    keyword?: boolean | CommunityInsight$keywordArgs<ExtArgs>
  }, ExtArgs["result"]["communityInsight"]>

  export type CommunityInsightSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    keywordId?: boolean
    sources?: boolean
    summary?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    domain?: boolean | CommunityInsight$domainArgs<ExtArgs>
    keyword?: boolean | CommunityInsight$keywordArgs<ExtArgs>
  }, ExtArgs["result"]["communityInsight"]>


  export type CommunityInsightSelectScalar = {
    id?: boolean
    domainId?: boolean
    keywordId?: boolean
    sources?: boolean
    summary?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
  }

  export type CommunityInsightOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "domainId" | "keywordId" | "sources" | "summary" | "tokenUsage" | "createdAt", ExtArgs["result"]["communityInsight"]>
  export type CommunityInsightInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | CommunityInsight$domainArgs<ExtArgs>
    keyword?: boolean | CommunityInsight$keywordArgs<ExtArgs>
  }
  export type CommunityInsightIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | CommunityInsight$domainArgs<ExtArgs>
    keyword?: boolean | CommunityInsight$keywordArgs<ExtArgs>
  }

  export type $CommunityInsightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommunityInsight"
    objects: {
      domain: Prisma.$DomainPayload<ExtArgs> | null
      keyword: Prisma.$KeywordPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      domainId: number | null
      keywordId: number | null
      sources: Prisma.JsonValue
      summary: string
      tokenUsage: number | null
      createdAt: Date
    }, ExtArgs["result"]["communityInsight"]>
    composites: {}
  }

  type CommunityInsightGetPayload<S extends boolean | null | undefined | CommunityInsightDefaultArgs> = $Result.GetResult<Prisma.$CommunityInsightPayload, S>

  type CommunityInsightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommunityInsightFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommunityInsightCountAggregateInputType | true
    }

  export interface CommunityInsightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunityInsight'], meta: { name: 'CommunityInsight' } }
    /**
     * Find zero or one CommunityInsight that matches the filter.
     * @param {CommunityInsightFindUniqueArgs} args - Arguments to find a CommunityInsight
     * @example
     * // Get one CommunityInsight
     * const communityInsight = await prisma.communityInsight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunityInsightFindUniqueArgs>(args: SelectSubset<T, CommunityInsightFindUniqueArgs<ExtArgs>>): Prisma__CommunityInsightClient<$Result.GetResult<Prisma.$CommunityInsightPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommunityInsight that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommunityInsightFindUniqueOrThrowArgs} args - Arguments to find a CommunityInsight
     * @example
     * // Get one CommunityInsight
     * const communityInsight = await prisma.communityInsight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunityInsightFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunityInsightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunityInsightClient<$Result.GetResult<Prisma.$CommunityInsightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommunityInsight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityInsightFindFirstArgs} args - Arguments to find a CommunityInsight
     * @example
     * // Get one CommunityInsight
     * const communityInsight = await prisma.communityInsight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunityInsightFindFirstArgs>(args?: SelectSubset<T, CommunityInsightFindFirstArgs<ExtArgs>>): Prisma__CommunityInsightClient<$Result.GetResult<Prisma.$CommunityInsightPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommunityInsight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityInsightFindFirstOrThrowArgs} args - Arguments to find a CommunityInsight
     * @example
     * // Get one CommunityInsight
     * const communityInsight = await prisma.communityInsight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunityInsightFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunityInsightFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunityInsightClient<$Result.GetResult<Prisma.$CommunityInsightPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommunityInsights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityInsightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityInsights
     * const communityInsights = await prisma.communityInsight.findMany()
     * 
     * // Get first 10 CommunityInsights
     * const communityInsights = await prisma.communityInsight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityInsightWithIdOnly = await prisma.communityInsight.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunityInsightFindManyArgs>(args?: SelectSubset<T, CommunityInsightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityInsightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommunityInsight.
     * @param {CommunityInsightCreateArgs} args - Arguments to create a CommunityInsight.
     * @example
     * // Create one CommunityInsight
     * const CommunityInsight = await prisma.communityInsight.create({
     *   data: {
     *     // ... data to create a CommunityInsight
     *   }
     * })
     * 
     */
    create<T extends CommunityInsightCreateArgs>(args: SelectSubset<T, CommunityInsightCreateArgs<ExtArgs>>): Prisma__CommunityInsightClient<$Result.GetResult<Prisma.$CommunityInsightPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommunityInsights.
     * @param {CommunityInsightCreateManyArgs} args - Arguments to create many CommunityInsights.
     * @example
     * // Create many CommunityInsights
     * const communityInsight = await prisma.communityInsight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunityInsightCreateManyArgs>(args?: SelectSubset<T, CommunityInsightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommunityInsights and returns the data saved in the database.
     * @param {CommunityInsightCreateManyAndReturnArgs} args - Arguments to create many CommunityInsights.
     * @example
     * // Create many CommunityInsights
     * const communityInsight = await prisma.communityInsight.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommunityInsights and only return the `id`
     * const communityInsightWithIdOnly = await prisma.communityInsight.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommunityInsightCreateManyAndReturnArgs>(args?: SelectSubset<T, CommunityInsightCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityInsightPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CommunityInsight.
     * @param {CommunityInsightDeleteArgs} args - Arguments to delete one CommunityInsight.
     * @example
     * // Delete one CommunityInsight
     * const CommunityInsight = await prisma.communityInsight.delete({
     *   where: {
     *     // ... filter to delete one CommunityInsight
     *   }
     * })
     * 
     */
    delete<T extends CommunityInsightDeleteArgs>(args: SelectSubset<T, CommunityInsightDeleteArgs<ExtArgs>>): Prisma__CommunityInsightClient<$Result.GetResult<Prisma.$CommunityInsightPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommunityInsight.
     * @param {CommunityInsightUpdateArgs} args - Arguments to update one CommunityInsight.
     * @example
     * // Update one CommunityInsight
     * const communityInsight = await prisma.communityInsight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunityInsightUpdateArgs>(args: SelectSubset<T, CommunityInsightUpdateArgs<ExtArgs>>): Prisma__CommunityInsightClient<$Result.GetResult<Prisma.$CommunityInsightPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommunityInsights.
     * @param {CommunityInsightDeleteManyArgs} args - Arguments to filter CommunityInsights to delete.
     * @example
     * // Delete a few CommunityInsights
     * const { count } = await prisma.communityInsight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunityInsightDeleteManyArgs>(args?: SelectSubset<T, CommunityInsightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityInsightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityInsights
     * const communityInsight = await prisma.communityInsight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunityInsightUpdateManyArgs>(args: SelectSubset<T, CommunityInsightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunityInsight.
     * @param {CommunityInsightUpsertArgs} args - Arguments to update or create a CommunityInsight.
     * @example
     * // Update or create a CommunityInsight
     * const communityInsight = await prisma.communityInsight.upsert({
     *   create: {
     *     // ... data to create a CommunityInsight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityInsight we want to update
     *   }
     * })
     */
    upsert<T extends CommunityInsightUpsertArgs>(args: SelectSubset<T, CommunityInsightUpsertArgs<ExtArgs>>): Prisma__CommunityInsightClient<$Result.GetResult<Prisma.$CommunityInsightPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CommunityInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityInsightCountArgs} args - Arguments to filter CommunityInsights to count.
     * @example
     * // Count the number of CommunityInsights
     * const count = await prisma.communityInsight.count({
     *   where: {
     *     // ... the filter for the CommunityInsights we want to count
     *   }
     * })
    **/
    count<T extends CommunityInsightCountArgs>(
      args?: Subset<T, CommunityInsightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityInsightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityInsight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityInsightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityInsightAggregateArgs>(args: Subset<T, CommunityInsightAggregateArgs>): Prisma.PrismaPromise<GetCommunityInsightAggregateType<T>>

    /**
     * Group by CommunityInsight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityInsightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityInsightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityInsightGroupByArgs['orderBy'] }
        : { orderBy?: CommunityInsightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityInsightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityInsightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommunityInsight model
   */
  readonly fields: CommunityInsightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityInsight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityInsightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domain<T extends CommunityInsight$domainArgs<ExtArgs> = {}>(args?: Subset<T, CommunityInsight$domainArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    keyword<T extends CommunityInsight$keywordArgs<ExtArgs> = {}>(args?: Subset<T, CommunityInsight$keywordArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommunityInsight model
   */
  interface CommunityInsightFieldRefs {
    readonly id: FieldRef<"CommunityInsight", 'Int'>
    readonly domainId: FieldRef<"CommunityInsight", 'Int'>
    readonly keywordId: FieldRef<"CommunityInsight", 'Int'>
    readonly sources: FieldRef<"CommunityInsight", 'Json'>
    readonly summary: FieldRef<"CommunityInsight", 'String'>
    readonly tokenUsage: FieldRef<"CommunityInsight", 'Int'>
    readonly createdAt: FieldRef<"CommunityInsight", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommunityInsight findUnique
   */
  export type CommunityInsightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityInsight
     */
    select?: CommunityInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityInsight
     */
    omit?: CommunityInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInsightInclude<ExtArgs> | null
    /**
     * Filter, which CommunityInsight to fetch.
     */
    where: CommunityInsightWhereUniqueInput
  }

  /**
   * CommunityInsight findUniqueOrThrow
   */
  export type CommunityInsightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityInsight
     */
    select?: CommunityInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityInsight
     */
    omit?: CommunityInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInsightInclude<ExtArgs> | null
    /**
     * Filter, which CommunityInsight to fetch.
     */
    where: CommunityInsightWhereUniqueInput
  }

  /**
   * CommunityInsight findFirst
   */
  export type CommunityInsightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityInsight
     */
    select?: CommunityInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityInsight
     */
    omit?: CommunityInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInsightInclude<ExtArgs> | null
    /**
     * Filter, which CommunityInsight to fetch.
     */
    where?: CommunityInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityInsights to fetch.
     */
    orderBy?: CommunityInsightOrderByWithRelationInput | CommunityInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityInsights.
     */
    cursor?: CommunityInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityInsights.
     */
    distinct?: CommunityInsightScalarFieldEnum | CommunityInsightScalarFieldEnum[]
  }

  /**
   * CommunityInsight findFirstOrThrow
   */
  export type CommunityInsightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityInsight
     */
    select?: CommunityInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityInsight
     */
    omit?: CommunityInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInsightInclude<ExtArgs> | null
    /**
     * Filter, which CommunityInsight to fetch.
     */
    where?: CommunityInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityInsights to fetch.
     */
    orderBy?: CommunityInsightOrderByWithRelationInput | CommunityInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityInsights.
     */
    cursor?: CommunityInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityInsights.
     */
    distinct?: CommunityInsightScalarFieldEnum | CommunityInsightScalarFieldEnum[]
  }

  /**
   * CommunityInsight findMany
   */
  export type CommunityInsightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityInsight
     */
    select?: CommunityInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityInsight
     */
    omit?: CommunityInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInsightInclude<ExtArgs> | null
    /**
     * Filter, which CommunityInsights to fetch.
     */
    where?: CommunityInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityInsights to fetch.
     */
    orderBy?: CommunityInsightOrderByWithRelationInput | CommunityInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityInsights.
     */
    cursor?: CommunityInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityInsights.
     */
    skip?: number
    distinct?: CommunityInsightScalarFieldEnum | CommunityInsightScalarFieldEnum[]
  }

  /**
   * CommunityInsight create
   */
  export type CommunityInsightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityInsight
     */
    select?: CommunityInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityInsight
     */
    omit?: CommunityInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInsightInclude<ExtArgs> | null
    /**
     * The data needed to create a CommunityInsight.
     */
    data: XOR<CommunityInsightCreateInput, CommunityInsightUncheckedCreateInput>
  }

  /**
   * CommunityInsight createMany
   */
  export type CommunityInsightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommunityInsights.
     */
    data: CommunityInsightCreateManyInput | CommunityInsightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommunityInsight createManyAndReturn
   */
  export type CommunityInsightCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityInsight
     */
    select?: CommunityInsightSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityInsight
     */
    omit?: CommunityInsightOmit<ExtArgs> | null
    /**
     * The data used to create many CommunityInsights.
     */
    data: CommunityInsightCreateManyInput | CommunityInsightCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInsightIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommunityInsight update
   */
  export type CommunityInsightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityInsight
     */
    select?: CommunityInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityInsight
     */
    omit?: CommunityInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInsightInclude<ExtArgs> | null
    /**
     * The data needed to update a CommunityInsight.
     */
    data: XOR<CommunityInsightUpdateInput, CommunityInsightUncheckedUpdateInput>
    /**
     * Choose, which CommunityInsight to update.
     */
    where: CommunityInsightWhereUniqueInput
  }

  /**
   * CommunityInsight updateMany
   */
  export type CommunityInsightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommunityInsights.
     */
    data: XOR<CommunityInsightUpdateManyMutationInput, CommunityInsightUncheckedUpdateManyInput>
    /**
     * Filter which CommunityInsights to update
     */
    where?: CommunityInsightWhereInput
  }

  /**
   * CommunityInsight upsert
   */
  export type CommunityInsightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityInsight
     */
    select?: CommunityInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityInsight
     */
    omit?: CommunityInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInsightInclude<ExtArgs> | null
    /**
     * The filter to search for the CommunityInsight to update in case it exists.
     */
    where: CommunityInsightWhereUniqueInput
    /**
     * In case the CommunityInsight found by the `where` argument doesn't exist, create a new CommunityInsight with this data.
     */
    create: XOR<CommunityInsightCreateInput, CommunityInsightUncheckedCreateInput>
    /**
     * In case the CommunityInsight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityInsightUpdateInput, CommunityInsightUncheckedUpdateInput>
  }

  /**
   * CommunityInsight delete
   */
  export type CommunityInsightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityInsight
     */
    select?: CommunityInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityInsight
     */
    omit?: CommunityInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInsightInclude<ExtArgs> | null
    /**
     * Filter which CommunityInsight to delete.
     */
    where: CommunityInsightWhereUniqueInput
  }

  /**
   * CommunityInsight deleteMany
   */
  export type CommunityInsightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityInsights to delete
     */
    where?: CommunityInsightWhereInput
  }

  /**
   * CommunityInsight.domain
   */
  export type CommunityInsight$domainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    where?: DomainWhereInput
  }

  /**
   * CommunityInsight.keyword
   */
  export type CommunityInsight$keywordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    where?: KeywordWhereInput
  }

  /**
   * CommunityInsight without action
   */
  export type CommunityInsightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityInsight
     */
    select?: CommunityInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityInsight
     */
    omit?: CommunityInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInsightInclude<ExtArgs> | null
  }


  /**
   * Model SearchPattern
   */

  export type AggregateSearchPattern = {
    _count: SearchPatternCountAggregateOutputType | null
    _avg: SearchPatternAvgAggregateOutputType | null
    _sum: SearchPatternSumAggregateOutputType | null
    _min: SearchPatternMinAggregateOutputType | null
    _max: SearchPatternMaxAggregateOutputType | null
  }

  export type SearchPatternAvgAggregateOutputType = {
    id: number | null
    domainId: number | null
    keywordId: number | null
    tokenUsage: number | null
  }

  export type SearchPatternSumAggregateOutputType = {
    id: number | null
    domainId: number | null
    keywordId: number | null
    tokenUsage: number | null
  }

  export type SearchPatternMinAggregateOutputType = {
    id: number | null
    domainId: number | null
    keywordId: number | null
    summary: string | null
    tokenUsage: number | null
    createdAt: Date | null
  }

  export type SearchPatternMaxAggregateOutputType = {
    id: number | null
    domainId: number | null
    keywordId: number | null
    summary: string | null
    tokenUsage: number | null
    createdAt: Date | null
  }

  export type SearchPatternCountAggregateOutputType = {
    id: number
    domainId: number
    keywordId: number
    patterns: number
    summary: number
    tokenUsage: number
    createdAt: number
    _all: number
  }


  export type SearchPatternAvgAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    tokenUsage?: true
  }

  export type SearchPatternSumAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    tokenUsage?: true
  }

  export type SearchPatternMinAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    summary?: true
    tokenUsage?: true
    createdAt?: true
  }

  export type SearchPatternMaxAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    summary?: true
    tokenUsage?: true
    createdAt?: true
  }

  export type SearchPatternCountAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    patterns?: true
    summary?: true
    tokenUsage?: true
    createdAt?: true
    _all?: true
  }

  export type SearchPatternAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchPattern to aggregate.
     */
    where?: SearchPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchPatterns to fetch.
     */
    orderBy?: SearchPatternOrderByWithRelationInput | SearchPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SearchPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SearchPatterns
    **/
    _count?: true | SearchPatternCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SearchPatternAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SearchPatternSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SearchPatternMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SearchPatternMaxAggregateInputType
  }

  export type GetSearchPatternAggregateType<T extends SearchPatternAggregateArgs> = {
        [P in keyof T & keyof AggregateSearchPattern]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSearchPattern[P]>
      : GetScalarType<T[P], AggregateSearchPattern[P]>
  }




  export type SearchPatternGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchPatternWhereInput
    orderBy?: SearchPatternOrderByWithAggregationInput | SearchPatternOrderByWithAggregationInput[]
    by: SearchPatternScalarFieldEnum[] | SearchPatternScalarFieldEnum
    having?: SearchPatternScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SearchPatternCountAggregateInputType | true
    _avg?: SearchPatternAvgAggregateInputType
    _sum?: SearchPatternSumAggregateInputType
    _min?: SearchPatternMinAggregateInputType
    _max?: SearchPatternMaxAggregateInputType
  }

  export type SearchPatternGroupByOutputType = {
    id: number
    domainId: number | null
    keywordId: number | null
    patterns: JsonValue
    summary: string
    tokenUsage: number | null
    createdAt: Date
    _count: SearchPatternCountAggregateOutputType | null
    _avg: SearchPatternAvgAggregateOutputType | null
    _sum: SearchPatternSumAggregateOutputType | null
    _min: SearchPatternMinAggregateOutputType | null
    _max: SearchPatternMaxAggregateOutputType | null
  }

  type GetSearchPatternGroupByPayload<T extends SearchPatternGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SearchPatternGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SearchPatternGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SearchPatternGroupByOutputType[P]>
            : GetScalarType<T[P], SearchPatternGroupByOutputType[P]>
        }
      >
    >


  export type SearchPatternSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    keywordId?: boolean
    patterns?: boolean
    summary?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    domain?: boolean | SearchPattern$domainArgs<ExtArgs>
    keyword?: boolean | SearchPattern$keywordArgs<ExtArgs>
  }, ExtArgs["result"]["searchPattern"]>

  export type SearchPatternSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    keywordId?: boolean
    patterns?: boolean
    summary?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    domain?: boolean | SearchPattern$domainArgs<ExtArgs>
    keyword?: boolean | SearchPattern$keywordArgs<ExtArgs>
  }, ExtArgs["result"]["searchPattern"]>


  export type SearchPatternSelectScalar = {
    id?: boolean
    domainId?: boolean
    keywordId?: boolean
    patterns?: boolean
    summary?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
  }

  export type SearchPatternOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "domainId" | "keywordId" | "patterns" | "summary" | "tokenUsage" | "createdAt", ExtArgs["result"]["searchPattern"]>
  export type SearchPatternInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | SearchPattern$domainArgs<ExtArgs>
    keyword?: boolean | SearchPattern$keywordArgs<ExtArgs>
  }
  export type SearchPatternIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | SearchPattern$domainArgs<ExtArgs>
    keyword?: boolean | SearchPattern$keywordArgs<ExtArgs>
  }

  export type $SearchPatternPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SearchPattern"
    objects: {
      domain: Prisma.$DomainPayload<ExtArgs> | null
      keyword: Prisma.$KeywordPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      domainId: number | null
      keywordId: number | null
      patterns: Prisma.JsonValue
      summary: string
      tokenUsage: number | null
      createdAt: Date
    }, ExtArgs["result"]["searchPattern"]>
    composites: {}
  }

  type SearchPatternGetPayload<S extends boolean | null | undefined | SearchPatternDefaultArgs> = $Result.GetResult<Prisma.$SearchPatternPayload, S>

  type SearchPatternCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SearchPatternFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SearchPatternCountAggregateInputType | true
    }

  export interface SearchPatternDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SearchPattern'], meta: { name: 'SearchPattern' } }
    /**
     * Find zero or one SearchPattern that matches the filter.
     * @param {SearchPatternFindUniqueArgs} args - Arguments to find a SearchPattern
     * @example
     * // Get one SearchPattern
     * const searchPattern = await prisma.searchPattern.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SearchPatternFindUniqueArgs>(args: SelectSubset<T, SearchPatternFindUniqueArgs<ExtArgs>>): Prisma__SearchPatternClient<$Result.GetResult<Prisma.$SearchPatternPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SearchPattern that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SearchPatternFindUniqueOrThrowArgs} args - Arguments to find a SearchPattern
     * @example
     * // Get one SearchPattern
     * const searchPattern = await prisma.searchPattern.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SearchPatternFindUniqueOrThrowArgs>(args: SelectSubset<T, SearchPatternFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SearchPatternClient<$Result.GetResult<Prisma.$SearchPatternPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchPattern that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchPatternFindFirstArgs} args - Arguments to find a SearchPattern
     * @example
     * // Get one SearchPattern
     * const searchPattern = await prisma.searchPattern.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SearchPatternFindFirstArgs>(args?: SelectSubset<T, SearchPatternFindFirstArgs<ExtArgs>>): Prisma__SearchPatternClient<$Result.GetResult<Prisma.$SearchPatternPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchPattern that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchPatternFindFirstOrThrowArgs} args - Arguments to find a SearchPattern
     * @example
     * // Get one SearchPattern
     * const searchPattern = await prisma.searchPattern.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SearchPatternFindFirstOrThrowArgs>(args?: SelectSubset<T, SearchPatternFindFirstOrThrowArgs<ExtArgs>>): Prisma__SearchPatternClient<$Result.GetResult<Prisma.$SearchPatternPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SearchPatterns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchPatternFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SearchPatterns
     * const searchPatterns = await prisma.searchPattern.findMany()
     * 
     * // Get first 10 SearchPatterns
     * const searchPatterns = await prisma.searchPattern.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const searchPatternWithIdOnly = await prisma.searchPattern.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SearchPatternFindManyArgs>(args?: SelectSubset<T, SearchPatternFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchPatternPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SearchPattern.
     * @param {SearchPatternCreateArgs} args - Arguments to create a SearchPattern.
     * @example
     * // Create one SearchPattern
     * const SearchPattern = await prisma.searchPattern.create({
     *   data: {
     *     // ... data to create a SearchPattern
     *   }
     * })
     * 
     */
    create<T extends SearchPatternCreateArgs>(args: SelectSubset<T, SearchPatternCreateArgs<ExtArgs>>): Prisma__SearchPatternClient<$Result.GetResult<Prisma.$SearchPatternPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SearchPatterns.
     * @param {SearchPatternCreateManyArgs} args - Arguments to create many SearchPatterns.
     * @example
     * // Create many SearchPatterns
     * const searchPattern = await prisma.searchPattern.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SearchPatternCreateManyArgs>(args?: SelectSubset<T, SearchPatternCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SearchPatterns and returns the data saved in the database.
     * @param {SearchPatternCreateManyAndReturnArgs} args - Arguments to create many SearchPatterns.
     * @example
     * // Create many SearchPatterns
     * const searchPattern = await prisma.searchPattern.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SearchPatterns and only return the `id`
     * const searchPatternWithIdOnly = await prisma.searchPattern.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SearchPatternCreateManyAndReturnArgs>(args?: SelectSubset<T, SearchPatternCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchPatternPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SearchPattern.
     * @param {SearchPatternDeleteArgs} args - Arguments to delete one SearchPattern.
     * @example
     * // Delete one SearchPattern
     * const SearchPattern = await prisma.searchPattern.delete({
     *   where: {
     *     // ... filter to delete one SearchPattern
     *   }
     * })
     * 
     */
    delete<T extends SearchPatternDeleteArgs>(args: SelectSubset<T, SearchPatternDeleteArgs<ExtArgs>>): Prisma__SearchPatternClient<$Result.GetResult<Prisma.$SearchPatternPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SearchPattern.
     * @param {SearchPatternUpdateArgs} args - Arguments to update one SearchPattern.
     * @example
     * // Update one SearchPattern
     * const searchPattern = await prisma.searchPattern.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SearchPatternUpdateArgs>(args: SelectSubset<T, SearchPatternUpdateArgs<ExtArgs>>): Prisma__SearchPatternClient<$Result.GetResult<Prisma.$SearchPatternPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SearchPatterns.
     * @param {SearchPatternDeleteManyArgs} args - Arguments to filter SearchPatterns to delete.
     * @example
     * // Delete a few SearchPatterns
     * const { count } = await prisma.searchPattern.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SearchPatternDeleteManyArgs>(args?: SelectSubset<T, SearchPatternDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchPatternUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SearchPatterns
     * const searchPattern = await prisma.searchPattern.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SearchPatternUpdateManyArgs>(args: SelectSubset<T, SearchPatternUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SearchPattern.
     * @param {SearchPatternUpsertArgs} args - Arguments to update or create a SearchPattern.
     * @example
     * // Update or create a SearchPattern
     * const searchPattern = await prisma.searchPattern.upsert({
     *   create: {
     *     // ... data to create a SearchPattern
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SearchPattern we want to update
     *   }
     * })
     */
    upsert<T extends SearchPatternUpsertArgs>(args: SelectSubset<T, SearchPatternUpsertArgs<ExtArgs>>): Prisma__SearchPatternClient<$Result.GetResult<Prisma.$SearchPatternPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SearchPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchPatternCountArgs} args - Arguments to filter SearchPatterns to count.
     * @example
     * // Count the number of SearchPatterns
     * const count = await prisma.searchPattern.count({
     *   where: {
     *     // ... the filter for the SearchPatterns we want to count
     *   }
     * })
    **/
    count<T extends SearchPatternCountArgs>(
      args?: Subset<T, SearchPatternCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SearchPatternCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SearchPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchPatternAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SearchPatternAggregateArgs>(args: Subset<T, SearchPatternAggregateArgs>): Prisma.PrismaPromise<GetSearchPatternAggregateType<T>>

    /**
     * Group by SearchPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchPatternGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SearchPatternGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SearchPatternGroupByArgs['orderBy'] }
        : { orderBy?: SearchPatternGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SearchPatternGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSearchPatternGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SearchPattern model
   */
  readonly fields: SearchPatternFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SearchPattern.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SearchPatternClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domain<T extends SearchPattern$domainArgs<ExtArgs> = {}>(args?: Subset<T, SearchPattern$domainArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    keyword<T extends SearchPattern$keywordArgs<ExtArgs> = {}>(args?: Subset<T, SearchPattern$keywordArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SearchPattern model
   */
  interface SearchPatternFieldRefs {
    readonly id: FieldRef<"SearchPattern", 'Int'>
    readonly domainId: FieldRef<"SearchPattern", 'Int'>
    readonly keywordId: FieldRef<"SearchPattern", 'Int'>
    readonly patterns: FieldRef<"SearchPattern", 'Json'>
    readonly summary: FieldRef<"SearchPattern", 'String'>
    readonly tokenUsage: FieldRef<"SearchPattern", 'Int'>
    readonly createdAt: FieldRef<"SearchPattern", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SearchPattern findUnique
   */
  export type SearchPatternFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPattern
     */
    select?: SearchPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPattern
     */
    omit?: SearchPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternInclude<ExtArgs> | null
    /**
     * Filter, which SearchPattern to fetch.
     */
    where: SearchPatternWhereUniqueInput
  }

  /**
   * SearchPattern findUniqueOrThrow
   */
  export type SearchPatternFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPattern
     */
    select?: SearchPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPattern
     */
    omit?: SearchPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternInclude<ExtArgs> | null
    /**
     * Filter, which SearchPattern to fetch.
     */
    where: SearchPatternWhereUniqueInput
  }

  /**
   * SearchPattern findFirst
   */
  export type SearchPatternFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPattern
     */
    select?: SearchPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPattern
     */
    omit?: SearchPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternInclude<ExtArgs> | null
    /**
     * Filter, which SearchPattern to fetch.
     */
    where?: SearchPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchPatterns to fetch.
     */
    orderBy?: SearchPatternOrderByWithRelationInput | SearchPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchPatterns.
     */
    cursor?: SearchPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchPatterns.
     */
    distinct?: SearchPatternScalarFieldEnum | SearchPatternScalarFieldEnum[]
  }

  /**
   * SearchPattern findFirstOrThrow
   */
  export type SearchPatternFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPattern
     */
    select?: SearchPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPattern
     */
    omit?: SearchPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternInclude<ExtArgs> | null
    /**
     * Filter, which SearchPattern to fetch.
     */
    where?: SearchPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchPatterns to fetch.
     */
    orderBy?: SearchPatternOrderByWithRelationInput | SearchPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchPatterns.
     */
    cursor?: SearchPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchPatterns.
     */
    distinct?: SearchPatternScalarFieldEnum | SearchPatternScalarFieldEnum[]
  }

  /**
   * SearchPattern findMany
   */
  export type SearchPatternFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPattern
     */
    select?: SearchPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPattern
     */
    omit?: SearchPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternInclude<ExtArgs> | null
    /**
     * Filter, which SearchPatterns to fetch.
     */
    where?: SearchPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchPatterns to fetch.
     */
    orderBy?: SearchPatternOrderByWithRelationInput | SearchPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SearchPatterns.
     */
    cursor?: SearchPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchPatterns.
     */
    skip?: number
    distinct?: SearchPatternScalarFieldEnum | SearchPatternScalarFieldEnum[]
  }

  /**
   * SearchPattern create
   */
  export type SearchPatternCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPattern
     */
    select?: SearchPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPattern
     */
    omit?: SearchPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternInclude<ExtArgs> | null
    /**
     * The data needed to create a SearchPattern.
     */
    data: XOR<SearchPatternCreateInput, SearchPatternUncheckedCreateInput>
  }

  /**
   * SearchPattern createMany
   */
  export type SearchPatternCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SearchPatterns.
     */
    data: SearchPatternCreateManyInput | SearchPatternCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SearchPattern createManyAndReturn
   */
  export type SearchPatternCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPattern
     */
    select?: SearchPatternSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPattern
     */
    omit?: SearchPatternOmit<ExtArgs> | null
    /**
     * The data used to create many SearchPatterns.
     */
    data: SearchPatternCreateManyInput | SearchPatternCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SearchPattern update
   */
  export type SearchPatternUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPattern
     */
    select?: SearchPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPattern
     */
    omit?: SearchPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternInclude<ExtArgs> | null
    /**
     * The data needed to update a SearchPattern.
     */
    data: XOR<SearchPatternUpdateInput, SearchPatternUncheckedUpdateInput>
    /**
     * Choose, which SearchPattern to update.
     */
    where: SearchPatternWhereUniqueInput
  }

  /**
   * SearchPattern updateMany
   */
  export type SearchPatternUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SearchPatterns.
     */
    data: XOR<SearchPatternUpdateManyMutationInput, SearchPatternUncheckedUpdateManyInput>
    /**
     * Filter which SearchPatterns to update
     */
    where?: SearchPatternWhereInput
  }

  /**
   * SearchPattern upsert
   */
  export type SearchPatternUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPattern
     */
    select?: SearchPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPattern
     */
    omit?: SearchPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternInclude<ExtArgs> | null
    /**
     * The filter to search for the SearchPattern to update in case it exists.
     */
    where: SearchPatternWhereUniqueInput
    /**
     * In case the SearchPattern found by the `where` argument doesn't exist, create a new SearchPattern with this data.
     */
    create: XOR<SearchPatternCreateInput, SearchPatternUncheckedCreateInput>
    /**
     * In case the SearchPattern was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SearchPatternUpdateInput, SearchPatternUncheckedUpdateInput>
  }

  /**
   * SearchPattern delete
   */
  export type SearchPatternDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPattern
     */
    select?: SearchPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPattern
     */
    omit?: SearchPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternInclude<ExtArgs> | null
    /**
     * Filter which SearchPattern to delete.
     */
    where: SearchPatternWhereUniqueInput
  }

  /**
   * SearchPattern deleteMany
   */
  export type SearchPatternDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchPatterns to delete
     */
    where?: SearchPatternWhereInput
  }

  /**
   * SearchPattern.domain
   */
  export type SearchPattern$domainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    where?: DomainWhereInput
  }

  /**
   * SearchPattern.keyword
   */
  export type SearchPattern$keywordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    where?: KeywordWhereInput
  }

  /**
   * SearchPattern without action
   */
  export type SearchPatternDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPattern
     */
    select?: SearchPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPattern
     */
    omit?: SearchPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternInclude<ExtArgs> | null
  }


  /**
   * Model PhraseIntentClassification
   */

  export type AggregatePhraseIntentClassification = {
    _count: PhraseIntentClassificationCountAggregateOutputType | null
    _avg: PhraseIntentClassificationAvgAggregateOutputType | null
    _sum: PhraseIntentClassificationSumAggregateOutputType | null
    _min: PhraseIntentClassificationMinAggregateOutputType | null
    _max: PhraseIntentClassificationMaxAggregateOutputType | null
  }

  export type PhraseIntentClassificationAvgAggregateOutputType = {
    id: number | null
    phraseId: number | null
    confidence: number | null
  }

  export type PhraseIntentClassificationSumAggregateOutputType = {
    id: number | null
    phraseId: number | null
    confidence: number | null
  }

  export type PhraseIntentClassificationMinAggregateOutputType = {
    id: number | null
    phraseId: number | null
    intent: string | null
    confidence: number | null
    createdAt: Date | null
  }

  export type PhraseIntentClassificationMaxAggregateOutputType = {
    id: number | null
    phraseId: number | null
    intent: string | null
    confidence: number | null
    createdAt: Date | null
  }

  export type PhraseIntentClassificationCountAggregateOutputType = {
    id: number
    phraseId: number
    intent: number
    confidence: number
    createdAt: number
    _all: number
  }


  export type PhraseIntentClassificationAvgAggregateInputType = {
    id?: true
    phraseId?: true
    confidence?: true
  }

  export type PhraseIntentClassificationSumAggregateInputType = {
    id?: true
    phraseId?: true
    confidence?: true
  }

  export type PhraseIntentClassificationMinAggregateInputType = {
    id?: true
    phraseId?: true
    intent?: true
    confidence?: true
    createdAt?: true
  }

  export type PhraseIntentClassificationMaxAggregateInputType = {
    id?: true
    phraseId?: true
    intent?: true
    confidence?: true
    createdAt?: true
  }

  export type PhraseIntentClassificationCountAggregateInputType = {
    id?: true
    phraseId?: true
    intent?: true
    confidence?: true
    createdAt?: true
    _all?: true
  }

  export type PhraseIntentClassificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhraseIntentClassification to aggregate.
     */
    where?: PhraseIntentClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhraseIntentClassifications to fetch.
     */
    orderBy?: PhraseIntentClassificationOrderByWithRelationInput | PhraseIntentClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhraseIntentClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhraseIntentClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhraseIntentClassifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PhraseIntentClassifications
    **/
    _count?: true | PhraseIntentClassificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PhraseIntentClassificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PhraseIntentClassificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhraseIntentClassificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhraseIntentClassificationMaxAggregateInputType
  }

  export type GetPhraseIntentClassificationAggregateType<T extends PhraseIntentClassificationAggregateArgs> = {
        [P in keyof T & keyof AggregatePhraseIntentClassification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhraseIntentClassification[P]>
      : GetScalarType<T[P], AggregatePhraseIntentClassification[P]>
  }




  export type PhraseIntentClassificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhraseIntentClassificationWhereInput
    orderBy?: PhraseIntentClassificationOrderByWithAggregationInput | PhraseIntentClassificationOrderByWithAggregationInput[]
    by: PhraseIntentClassificationScalarFieldEnum[] | PhraseIntentClassificationScalarFieldEnum
    having?: PhraseIntentClassificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhraseIntentClassificationCountAggregateInputType | true
    _avg?: PhraseIntentClassificationAvgAggregateInputType
    _sum?: PhraseIntentClassificationSumAggregateInputType
    _min?: PhraseIntentClassificationMinAggregateInputType
    _max?: PhraseIntentClassificationMaxAggregateInputType
  }

  export type PhraseIntentClassificationGroupByOutputType = {
    id: number
    phraseId: number
    intent: string
    confidence: number | null
    createdAt: Date
    _count: PhraseIntentClassificationCountAggregateOutputType | null
    _avg: PhraseIntentClassificationAvgAggregateOutputType | null
    _sum: PhraseIntentClassificationSumAggregateOutputType | null
    _min: PhraseIntentClassificationMinAggregateOutputType | null
    _max: PhraseIntentClassificationMaxAggregateOutputType | null
  }

  type GetPhraseIntentClassificationGroupByPayload<T extends PhraseIntentClassificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhraseIntentClassificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhraseIntentClassificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhraseIntentClassificationGroupByOutputType[P]>
            : GetScalarType<T[P], PhraseIntentClassificationGroupByOutputType[P]>
        }
      >
    >


  export type PhraseIntentClassificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phraseId?: boolean
    intent?: boolean
    confidence?: boolean
    createdAt?: boolean
    phrase?: boolean | PhraseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phraseIntentClassification"]>

  export type PhraseIntentClassificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phraseId?: boolean
    intent?: boolean
    confidence?: boolean
    createdAt?: boolean
    phrase?: boolean | PhraseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phraseIntentClassification"]>


  export type PhraseIntentClassificationSelectScalar = {
    id?: boolean
    phraseId?: boolean
    intent?: boolean
    confidence?: boolean
    createdAt?: boolean
  }

  export type PhraseIntentClassificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phraseId" | "intent" | "confidence" | "createdAt", ExtArgs["result"]["phraseIntentClassification"]>
  export type PhraseIntentClassificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phrase?: boolean | PhraseDefaultArgs<ExtArgs>
  }
  export type PhraseIntentClassificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phrase?: boolean | PhraseDefaultArgs<ExtArgs>
  }

  export type $PhraseIntentClassificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PhraseIntentClassification"
    objects: {
      phrase: Prisma.$PhrasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      phraseId: number
      intent: string
      confidence: number | null
      createdAt: Date
    }, ExtArgs["result"]["phraseIntentClassification"]>
    composites: {}
  }

  type PhraseIntentClassificationGetPayload<S extends boolean | null | undefined | PhraseIntentClassificationDefaultArgs> = $Result.GetResult<Prisma.$PhraseIntentClassificationPayload, S>

  type PhraseIntentClassificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PhraseIntentClassificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PhraseIntentClassificationCountAggregateInputType | true
    }

  export interface PhraseIntentClassificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PhraseIntentClassification'], meta: { name: 'PhraseIntentClassification' } }
    /**
     * Find zero or one PhraseIntentClassification that matches the filter.
     * @param {PhraseIntentClassificationFindUniqueArgs} args - Arguments to find a PhraseIntentClassification
     * @example
     * // Get one PhraseIntentClassification
     * const phraseIntentClassification = await prisma.phraseIntentClassification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhraseIntentClassificationFindUniqueArgs>(args: SelectSubset<T, PhraseIntentClassificationFindUniqueArgs<ExtArgs>>): Prisma__PhraseIntentClassificationClient<$Result.GetResult<Prisma.$PhraseIntentClassificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PhraseIntentClassification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PhraseIntentClassificationFindUniqueOrThrowArgs} args - Arguments to find a PhraseIntentClassification
     * @example
     * // Get one PhraseIntentClassification
     * const phraseIntentClassification = await prisma.phraseIntentClassification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhraseIntentClassificationFindUniqueOrThrowArgs>(args: SelectSubset<T, PhraseIntentClassificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhraseIntentClassificationClient<$Result.GetResult<Prisma.$PhraseIntentClassificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PhraseIntentClassification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseIntentClassificationFindFirstArgs} args - Arguments to find a PhraseIntentClassification
     * @example
     * // Get one PhraseIntentClassification
     * const phraseIntentClassification = await prisma.phraseIntentClassification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhraseIntentClassificationFindFirstArgs>(args?: SelectSubset<T, PhraseIntentClassificationFindFirstArgs<ExtArgs>>): Prisma__PhraseIntentClassificationClient<$Result.GetResult<Prisma.$PhraseIntentClassificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PhraseIntentClassification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseIntentClassificationFindFirstOrThrowArgs} args - Arguments to find a PhraseIntentClassification
     * @example
     * // Get one PhraseIntentClassification
     * const phraseIntentClassification = await prisma.phraseIntentClassification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhraseIntentClassificationFindFirstOrThrowArgs>(args?: SelectSubset<T, PhraseIntentClassificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhraseIntentClassificationClient<$Result.GetResult<Prisma.$PhraseIntentClassificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PhraseIntentClassifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseIntentClassificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhraseIntentClassifications
     * const phraseIntentClassifications = await prisma.phraseIntentClassification.findMany()
     * 
     * // Get first 10 PhraseIntentClassifications
     * const phraseIntentClassifications = await prisma.phraseIntentClassification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const phraseIntentClassificationWithIdOnly = await prisma.phraseIntentClassification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhraseIntentClassificationFindManyArgs>(args?: SelectSubset<T, PhraseIntentClassificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhraseIntentClassificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PhraseIntentClassification.
     * @param {PhraseIntentClassificationCreateArgs} args - Arguments to create a PhraseIntentClassification.
     * @example
     * // Create one PhraseIntentClassification
     * const PhraseIntentClassification = await prisma.phraseIntentClassification.create({
     *   data: {
     *     // ... data to create a PhraseIntentClassification
     *   }
     * })
     * 
     */
    create<T extends PhraseIntentClassificationCreateArgs>(args: SelectSubset<T, PhraseIntentClassificationCreateArgs<ExtArgs>>): Prisma__PhraseIntentClassificationClient<$Result.GetResult<Prisma.$PhraseIntentClassificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PhraseIntentClassifications.
     * @param {PhraseIntentClassificationCreateManyArgs} args - Arguments to create many PhraseIntentClassifications.
     * @example
     * // Create many PhraseIntentClassifications
     * const phraseIntentClassification = await prisma.phraseIntentClassification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhraseIntentClassificationCreateManyArgs>(args?: SelectSubset<T, PhraseIntentClassificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PhraseIntentClassifications and returns the data saved in the database.
     * @param {PhraseIntentClassificationCreateManyAndReturnArgs} args - Arguments to create many PhraseIntentClassifications.
     * @example
     * // Create many PhraseIntentClassifications
     * const phraseIntentClassification = await prisma.phraseIntentClassification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PhraseIntentClassifications and only return the `id`
     * const phraseIntentClassificationWithIdOnly = await prisma.phraseIntentClassification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PhraseIntentClassificationCreateManyAndReturnArgs>(args?: SelectSubset<T, PhraseIntentClassificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhraseIntentClassificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PhraseIntentClassification.
     * @param {PhraseIntentClassificationDeleteArgs} args - Arguments to delete one PhraseIntentClassification.
     * @example
     * // Delete one PhraseIntentClassification
     * const PhraseIntentClassification = await prisma.phraseIntentClassification.delete({
     *   where: {
     *     // ... filter to delete one PhraseIntentClassification
     *   }
     * })
     * 
     */
    delete<T extends PhraseIntentClassificationDeleteArgs>(args: SelectSubset<T, PhraseIntentClassificationDeleteArgs<ExtArgs>>): Prisma__PhraseIntentClassificationClient<$Result.GetResult<Prisma.$PhraseIntentClassificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PhraseIntentClassification.
     * @param {PhraseIntentClassificationUpdateArgs} args - Arguments to update one PhraseIntentClassification.
     * @example
     * // Update one PhraseIntentClassification
     * const phraseIntentClassification = await prisma.phraseIntentClassification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhraseIntentClassificationUpdateArgs>(args: SelectSubset<T, PhraseIntentClassificationUpdateArgs<ExtArgs>>): Prisma__PhraseIntentClassificationClient<$Result.GetResult<Prisma.$PhraseIntentClassificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PhraseIntentClassifications.
     * @param {PhraseIntentClassificationDeleteManyArgs} args - Arguments to filter PhraseIntentClassifications to delete.
     * @example
     * // Delete a few PhraseIntentClassifications
     * const { count } = await prisma.phraseIntentClassification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhraseIntentClassificationDeleteManyArgs>(args?: SelectSubset<T, PhraseIntentClassificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhraseIntentClassifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseIntentClassificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhraseIntentClassifications
     * const phraseIntentClassification = await prisma.phraseIntentClassification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhraseIntentClassificationUpdateManyArgs>(args: SelectSubset<T, PhraseIntentClassificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PhraseIntentClassification.
     * @param {PhraseIntentClassificationUpsertArgs} args - Arguments to update or create a PhraseIntentClassification.
     * @example
     * // Update or create a PhraseIntentClassification
     * const phraseIntentClassification = await prisma.phraseIntentClassification.upsert({
     *   create: {
     *     // ... data to create a PhraseIntentClassification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhraseIntentClassification we want to update
     *   }
     * })
     */
    upsert<T extends PhraseIntentClassificationUpsertArgs>(args: SelectSubset<T, PhraseIntentClassificationUpsertArgs<ExtArgs>>): Prisma__PhraseIntentClassificationClient<$Result.GetResult<Prisma.$PhraseIntentClassificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PhraseIntentClassifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseIntentClassificationCountArgs} args - Arguments to filter PhraseIntentClassifications to count.
     * @example
     * // Count the number of PhraseIntentClassifications
     * const count = await prisma.phraseIntentClassification.count({
     *   where: {
     *     // ... the filter for the PhraseIntentClassifications we want to count
     *   }
     * })
    **/
    count<T extends PhraseIntentClassificationCountArgs>(
      args?: Subset<T, PhraseIntentClassificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhraseIntentClassificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PhraseIntentClassification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseIntentClassificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhraseIntentClassificationAggregateArgs>(args: Subset<T, PhraseIntentClassificationAggregateArgs>): Prisma.PrismaPromise<GetPhraseIntentClassificationAggregateType<T>>

    /**
     * Group by PhraseIntentClassification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseIntentClassificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhraseIntentClassificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhraseIntentClassificationGroupByArgs['orderBy'] }
        : { orderBy?: PhraseIntentClassificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhraseIntentClassificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhraseIntentClassificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PhraseIntentClassification model
   */
  readonly fields: PhraseIntentClassificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PhraseIntentClassification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhraseIntentClassificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    phrase<T extends PhraseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PhraseDefaultArgs<ExtArgs>>): Prisma__PhraseClient<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PhraseIntentClassification model
   */
  interface PhraseIntentClassificationFieldRefs {
    readonly id: FieldRef<"PhraseIntentClassification", 'Int'>
    readonly phraseId: FieldRef<"PhraseIntentClassification", 'Int'>
    readonly intent: FieldRef<"PhraseIntentClassification", 'String'>
    readonly confidence: FieldRef<"PhraseIntentClassification", 'Int'>
    readonly createdAt: FieldRef<"PhraseIntentClassification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PhraseIntentClassification findUnique
   */
  export type PhraseIntentClassificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseIntentClassification
     */
    select?: PhraseIntentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhraseIntentClassification
     */
    omit?: PhraseIntentClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseIntentClassificationInclude<ExtArgs> | null
    /**
     * Filter, which PhraseIntentClassification to fetch.
     */
    where: PhraseIntentClassificationWhereUniqueInput
  }

  /**
   * PhraseIntentClassification findUniqueOrThrow
   */
  export type PhraseIntentClassificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseIntentClassification
     */
    select?: PhraseIntentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhraseIntentClassification
     */
    omit?: PhraseIntentClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseIntentClassificationInclude<ExtArgs> | null
    /**
     * Filter, which PhraseIntentClassification to fetch.
     */
    where: PhraseIntentClassificationWhereUniqueInput
  }

  /**
   * PhraseIntentClassification findFirst
   */
  export type PhraseIntentClassificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseIntentClassification
     */
    select?: PhraseIntentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhraseIntentClassification
     */
    omit?: PhraseIntentClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseIntentClassificationInclude<ExtArgs> | null
    /**
     * Filter, which PhraseIntentClassification to fetch.
     */
    where?: PhraseIntentClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhraseIntentClassifications to fetch.
     */
    orderBy?: PhraseIntentClassificationOrderByWithRelationInput | PhraseIntentClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhraseIntentClassifications.
     */
    cursor?: PhraseIntentClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhraseIntentClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhraseIntentClassifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhraseIntentClassifications.
     */
    distinct?: PhraseIntentClassificationScalarFieldEnum | PhraseIntentClassificationScalarFieldEnum[]
  }

  /**
   * PhraseIntentClassification findFirstOrThrow
   */
  export type PhraseIntentClassificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseIntentClassification
     */
    select?: PhraseIntentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhraseIntentClassification
     */
    omit?: PhraseIntentClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseIntentClassificationInclude<ExtArgs> | null
    /**
     * Filter, which PhraseIntentClassification to fetch.
     */
    where?: PhraseIntentClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhraseIntentClassifications to fetch.
     */
    orderBy?: PhraseIntentClassificationOrderByWithRelationInput | PhraseIntentClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhraseIntentClassifications.
     */
    cursor?: PhraseIntentClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhraseIntentClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhraseIntentClassifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhraseIntentClassifications.
     */
    distinct?: PhraseIntentClassificationScalarFieldEnum | PhraseIntentClassificationScalarFieldEnum[]
  }

  /**
   * PhraseIntentClassification findMany
   */
  export type PhraseIntentClassificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseIntentClassification
     */
    select?: PhraseIntentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhraseIntentClassification
     */
    omit?: PhraseIntentClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseIntentClassificationInclude<ExtArgs> | null
    /**
     * Filter, which PhraseIntentClassifications to fetch.
     */
    where?: PhraseIntentClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhraseIntentClassifications to fetch.
     */
    orderBy?: PhraseIntentClassificationOrderByWithRelationInput | PhraseIntentClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PhraseIntentClassifications.
     */
    cursor?: PhraseIntentClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhraseIntentClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhraseIntentClassifications.
     */
    skip?: number
    distinct?: PhraseIntentClassificationScalarFieldEnum | PhraseIntentClassificationScalarFieldEnum[]
  }

  /**
   * PhraseIntentClassification create
   */
  export type PhraseIntentClassificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseIntentClassification
     */
    select?: PhraseIntentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhraseIntentClassification
     */
    omit?: PhraseIntentClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseIntentClassificationInclude<ExtArgs> | null
    /**
     * The data needed to create a PhraseIntentClassification.
     */
    data: XOR<PhraseIntentClassificationCreateInput, PhraseIntentClassificationUncheckedCreateInput>
  }

  /**
   * PhraseIntentClassification createMany
   */
  export type PhraseIntentClassificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PhraseIntentClassifications.
     */
    data: PhraseIntentClassificationCreateManyInput | PhraseIntentClassificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PhraseIntentClassification createManyAndReturn
   */
  export type PhraseIntentClassificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseIntentClassification
     */
    select?: PhraseIntentClassificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PhraseIntentClassification
     */
    omit?: PhraseIntentClassificationOmit<ExtArgs> | null
    /**
     * The data used to create many PhraseIntentClassifications.
     */
    data: PhraseIntentClassificationCreateManyInput | PhraseIntentClassificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseIntentClassificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PhraseIntentClassification update
   */
  export type PhraseIntentClassificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseIntentClassification
     */
    select?: PhraseIntentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhraseIntentClassification
     */
    omit?: PhraseIntentClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseIntentClassificationInclude<ExtArgs> | null
    /**
     * The data needed to update a PhraseIntentClassification.
     */
    data: XOR<PhraseIntentClassificationUpdateInput, PhraseIntentClassificationUncheckedUpdateInput>
    /**
     * Choose, which PhraseIntentClassification to update.
     */
    where: PhraseIntentClassificationWhereUniqueInput
  }

  /**
   * PhraseIntentClassification updateMany
   */
  export type PhraseIntentClassificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PhraseIntentClassifications.
     */
    data: XOR<PhraseIntentClassificationUpdateManyMutationInput, PhraseIntentClassificationUncheckedUpdateManyInput>
    /**
     * Filter which PhraseIntentClassifications to update
     */
    where?: PhraseIntentClassificationWhereInput
  }

  /**
   * PhraseIntentClassification upsert
   */
  export type PhraseIntentClassificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseIntentClassification
     */
    select?: PhraseIntentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhraseIntentClassification
     */
    omit?: PhraseIntentClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseIntentClassificationInclude<ExtArgs> | null
    /**
     * The filter to search for the PhraseIntentClassification to update in case it exists.
     */
    where: PhraseIntentClassificationWhereUniqueInput
    /**
     * In case the PhraseIntentClassification found by the `where` argument doesn't exist, create a new PhraseIntentClassification with this data.
     */
    create: XOR<PhraseIntentClassificationCreateInput, PhraseIntentClassificationUncheckedCreateInput>
    /**
     * In case the PhraseIntentClassification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhraseIntentClassificationUpdateInput, PhraseIntentClassificationUncheckedUpdateInput>
  }

  /**
   * PhraseIntentClassification delete
   */
  export type PhraseIntentClassificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseIntentClassification
     */
    select?: PhraseIntentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhraseIntentClassification
     */
    omit?: PhraseIntentClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseIntentClassificationInclude<ExtArgs> | null
    /**
     * Filter which PhraseIntentClassification to delete.
     */
    where: PhraseIntentClassificationWhereUniqueInput
  }

  /**
   * PhraseIntentClassification deleteMany
   */
  export type PhraseIntentClassificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhraseIntentClassifications to delete
     */
    where?: PhraseIntentClassificationWhereInput
  }

  /**
   * PhraseIntentClassification without action
   */
  export type PhraseIntentClassificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseIntentClassification
     */
    select?: PhraseIntentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhraseIntentClassification
     */
    omit?: PhraseIntentClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseIntentClassificationInclude<ExtArgs> | null
  }


  /**
   * Model PhraseScore
   */

  export type AggregatePhraseScore = {
    _count: PhraseScoreCountAggregateOutputType | null
    _avg: PhraseScoreAvgAggregateOutputType | null
    _sum: PhraseScoreSumAggregateOutputType | null
    _min: PhraseScoreMinAggregateOutputType | null
    _max: PhraseScoreMaxAggregateOutputType | null
  }

  export type PhraseScoreAvgAggregateOutputType = {
    id: number | null
    phraseId: number | null
    score: number | null
  }

  export type PhraseScoreSumAggregateOutputType = {
    id: number | null
    phraseId: number | null
    score: number | null
  }

  export type PhraseScoreMinAggregateOutputType = {
    id: number | null
    phraseId: number | null
    score: number | null
    createdAt: Date | null
  }

  export type PhraseScoreMaxAggregateOutputType = {
    id: number | null
    phraseId: number | null
    score: number | null
    createdAt: Date | null
  }

  export type PhraseScoreCountAggregateOutputType = {
    id: number
    phraseId: number
    score: number
    breakdown: number
    createdAt: number
    _all: number
  }


  export type PhraseScoreAvgAggregateInputType = {
    id?: true
    phraseId?: true
    score?: true
  }

  export type PhraseScoreSumAggregateInputType = {
    id?: true
    phraseId?: true
    score?: true
  }

  export type PhraseScoreMinAggregateInputType = {
    id?: true
    phraseId?: true
    score?: true
    createdAt?: true
  }

  export type PhraseScoreMaxAggregateInputType = {
    id?: true
    phraseId?: true
    score?: true
    createdAt?: true
  }

  export type PhraseScoreCountAggregateInputType = {
    id?: true
    phraseId?: true
    score?: true
    breakdown?: true
    createdAt?: true
    _all?: true
  }

  export type PhraseScoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhraseScore to aggregate.
     */
    where?: PhraseScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhraseScores to fetch.
     */
    orderBy?: PhraseScoreOrderByWithRelationInput | PhraseScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhraseScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhraseScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhraseScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PhraseScores
    **/
    _count?: true | PhraseScoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PhraseScoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PhraseScoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhraseScoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhraseScoreMaxAggregateInputType
  }

  export type GetPhraseScoreAggregateType<T extends PhraseScoreAggregateArgs> = {
        [P in keyof T & keyof AggregatePhraseScore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhraseScore[P]>
      : GetScalarType<T[P], AggregatePhraseScore[P]>
  }




  export type PhraseScoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhraseScoreWhereInput
    orderBy?: PhraseScoreOrderByWithAggregationInput | PhraseScoreOrderByWithAggregationInput[]
    by: PhraseScoreScalarFieldEnum[] | PhraseScoreScalarFieldEnum
    having?: PhraseScoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhraseScoreCountAggregateInputType | true
    _avg?: PhraseScoreAvgAggregateInputType
    _sum?: PhraseScoreSumAggregateInputType
    _min?: PhraseScoreMinAggregateInputType
    _max?: PhraseScoreMaxAggregateInputType
  }

  export type PhraseScoreGroupByOutputType = {
    id: number
    phraseId: number
    score: number
    breakdown: JsonValue | null
    createdAt: Date
    _count: PhraseScoreCountAggregateOutputType | null
    _avg: PhraseScoreAvgAggregateOutputType | null
    _sum: PhraseScoreSumAggregateOutputType | null
    _min: PhraseScoreMinAggregateOutputType | null
    _max: PhraseScoreMaxAggregateOutputType | null
  }

  type GetPhraseScoreGroupByPayload<T extends PhraseScoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhraseScoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhraseScoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhraseScoreGroupByOutputType[P]>
            : GetScalarType<T[P], PhraseScoreGroupByOutputType[P]>
        }
      >
    >


  export type PhraseScoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phraseId?: boolean
    score?: boolean
    breakdown?: boolean
    createdAt?: boolean
    phrase?: boolean | PhraseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phraseScore"]>

  export type PhraseScoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phraseId?: boolean
    score?: boolean
    breakdown?: boolean
    createdAt?: boolean
    phrase?: boolean | PhraseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phraseScore"]>


  export type PhraseScoreSelectScalar = {
    id?: boolean
    phraseId?: boolean
    score?: boolean
    breakdown?: boolean
    createdAt?: boolean
  }

  export type PhraseScoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phraseId" | "score" | "breakdown" | "createdAt", ExtArgs["result"]["phraseScore"]>
  export type PhraseScoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phrase?: boolean | PhraseDefaultArgs<ExtArgs>
  }
  export type PhraseScoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phrase?: boolean | PhraseDefaultArgs<ExtArgs>
  }

  export type $PhraseScorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PhraseScore"
    objects: {
      phrase: Prisma.$PhrasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      phraseId: number
      score: number
      breakdown: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["phraseScore"]>
    composites: {}
  }

  type PhraseScoreGetPayload<S extends boolean | null | undefined | PhraseScoreDefaultArgs> = $Result.GetResult<Prisma.$PhraseScorePayload, S>

  type PhraseScoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PhraseScoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PhraseScoreCountAggregateInputType | true
    }

  export interface PhraseScoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PhraseScore'], meta: { name: 'PhraseScore' } }
    /**
     * Find zero or one PhraseScore that matches the filter.
     * @param {PhraseScoreFindUniqueArgs} args - Arguments to find a PhraseScore
     * @example
     * // Get one PhraseScore
     * const phraseScore = await prisma.phraseScore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhraseScoreFindUniqueArgs>(args: SelectSubset<T, PhraseScoreFindUniqueArgs<ExtArgs>>): Prisma__PhraseScoreClient<$Result.GetResult<Prisma.$PhraseScorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PhraseScore that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PhraseScoreFindUniqueOrThrowArgs} args - Arguments to find a PhraseScore
     * @example
     * // Get one PhraseScore
     * const phraseScore = await prisma.phraseScore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhraseScoreFindUniqueOrThrowArgs>(args: SelectSubset<T, PhraseScoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhraseScoreClient<$Result.GetResult<Prisma.$PhraseScorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PhraseScore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseScoreFindFirstArgs} args - Arguments to find a PhraseScore
     * @example
     * // Get one PhraseScore
     * const phraseScore = await prisma.phraseScore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhraseScoreFindFirstArgs>(args?: SelectSubset<T, PhraseScoreFindFirstArgs<ExtArgs>>): Prisma__PhraseScoreClient<$Result.GetResult<Prisma.$PhraseScorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PhraseScore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseScoreFindFirstOrThrowArgs} args - Arguments to find a PhraseScore
     * @example
     * // Get one PhraseScore
     * const phraseScore = await prisma.phraseScore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhraseScoreFindFirstOrThrowArgs>(args?: SelectSubset<T, PhraseScoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhraseScoreClient<$Result.GetResult<Prisma.$PhraseScorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PhraseScores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseScoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhraseScores
     * const phraseScores = await prisma.phraseScore.findMany()
     * 
     * // Get first 10 PhraseScores
     * const phraseScores = await prisma.phraseScore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const phraseScoreWithIdOnly = await prisma.phraseScore.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhraseScoreFindManyArgs>(args?: SelectSubset<T, PhraseScoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhraseScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PhraseScore.
     * @param {PhraseScoreCreateArgs} args - Arguments to create a PhraseScore.
     * @example
     * // Create one PhraseScore
     * const PhraseScore = await prisma.phraseScore.create({
     *   data: {
     *     // ... data to create a PhraseScore
     *   }
     * })
     * 
     */
    create<T extends PhraseScoreCreateArgs>(args: SelectSubset<T, PhraseScoreCreateArgs<ExtArgs>>): Prisma__PhraseScoreClient<$Result.GetResult<Prisma.$PhraseScorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PhraseScores.
     * @param {PhraseScoreCreateManyArgs} args - Arguments to create many PhraseScores.
     * @example
     * // Create many PhraseScores
     * const phraseScore = await prisma.phraseScore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhraseScoreCreateManyArgs>(args?: SelectSubset<T, PhraseScoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PhraseScores and returns the data saved in the database.
     * @param {PhraseScoreCreateManyAndReturnArgs} args - Arguments to create many PhraseScores.
     * @example
     * // Create many PhraseScores
     * const phraseScore = await prisma.phraseScore.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PhraseScores and only return the `id`
     * const phraseScoreWithIdOnly = await prisma.phraseScore.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PhraseScoreCreateManyAndReturnArgs>(args?: SelectSubset<T, PhraseScoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhraseScorePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PhraseScore.
     * @param {PhraseScoreDeleteArgs} args - Arguments to delete one PhraseScore.
     * @example
     * // Delete one PhraseScore
     * const PhraseScore = await prisma.phraseScore.delete({
     *   where: {
     *     // ... filter to delete one PhraseScore
     *   }
     * })
     * 
     */
    delete<T extends PhraseScoreDeleteArgs>(args: SelectSubset<T, PhraseScoreDeleteArgs<ExtArgs>>): Prisma__PhraseScoreClient<$Result.GetResult<Prisma.$PhraseScorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PhraseScore.
     * @param {PhraseScoreUpdateArgs} args - Arguments to update one PhraseScore.
     * @example
     * // Update one PhraseScore
     * const phraseScore = await prisma.phraseScore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhraseScoreUpdateArgs>(args: SelectSubset<T, PhraseScoreUpdateArgs<ExtArgs>>): Prisma__PhraseScoreClient<$Result.GetResult<Prisma.$PhraseScorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PhraseScores.
     * @param {PhraseScoreDeleteManyArgs} args - Arguments to filter PhraseScores to delete.
     * @example
     * // Delete a few PhraseScores
     * const { count } = await prisma.phraseScore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhraseScoreDeleteManyArgs>(args?: SelectSubset<T, PhraseScoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhraseScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseScoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhraseScores
     * const phraseScore = await prisma.phraseScore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhraseScoreUpdateManyArgs>(args: SelectSubset<T, PhraseScoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PhraseScore.
     * @param {PhraseScoreUpsertArgs} args - Arguments to update or create a PhraseScore.
     * @example
     * // Update or create a PhraseScore
     * const phraseScore = await prisma.phraseScore.upsert({
     *   create: {
     *     // ... data to create a PhraseScore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhraseScore we want to update
     *   }
     * })
     */
    upsert<T extends PhraseScoreUpsertArgs>(args: SelectSubset<T, PhraseScoreUpsertArgs<ExtArgs>>): Prisma__PhraseScoreClient<$Result.GetResult<Prisma.$PhraseScorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PhraseScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseScoreCountArgs} args - Arguments to filter PhraseScores to count.
     * @example
     * // Count the number of PhraseScores
     * const count = await prisma.phraseScore.count({
     *   where: {
     *     // ... the filter for the PhraseScores we want to count
     *   }
     * })
    **/
    count<T extends PhraseScoreCountArgs>(
      args?: Subset<T, PhraseScoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhraseScoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PhraseScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseScoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhraseScoreAggregateArgs>(args: Subset<T, PhraseScoreAggregateArgs>): Prisma.PrismaPromise<GetPhraseScoreAggregateType<T>>

    /**
     * Group by PhraseScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseScoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhraseScoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhraseScoreGroupByArgs['orderBy'] }
        : { orderBy?: PhraseScoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhraseScoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhraseScoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PhraseScore model
   */
  readonly fields: PhraseScoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PhraseScore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhraseScoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    phrase<T extends PhraseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PhraseDefaultArgs<ExtArgs>>): Prisma__PhraseClient<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PhraseScore model
   */
  interface PhraseScoreFieldRefs {
    readonly id: FieldRef<"PhraseScore", 'Int'>
    readonly phraseId: FieldRef<"PhraseScore", 'Int'>
    readonly score: FieldRef<"PhraseScore", 'Int'>
    readonly breakdown: FieldRef<"PhraseScore", 'Json'>
    readonly createdAt: FieldRef<"PhraseScore", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PhraseScore findUnique
   */
  export type PhraseScoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseScore
     */
    select?: PhraseScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhraseScore
     */
    omit?: PhraseScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseScoreInclude<ExtArgs> | null
    /**
     * Filter, which PhraseScore to fetch.
     */
    where: PhraseScoreWhereUniqueInput
  }

  /**
   * PhraseScore findUniqueOrThrow
   */
  export type PhraseScoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseScore
     */
    select?: PhraseScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhraseScore
     */
    omit?: PhraseScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseScoreInclude<ExtArgs> | null
    /**
     * Filter, which PhraseScore to fetch.
     */
    where: PhraseScoreWhereUniqueInput
  }

  /**
   * PhraseScore findFirst
   */
  export type PhraseScoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseScore
     */
    select?: PhraseScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhraseScore
     */
    omit?: PhraseScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseScoreInclude<ExtArgs> | null
    /**
     * Filter, which PhraseScore to fetch.
     */
    where?: PhraseScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhraseScores to fetch.
     */
    orderBy?: PhraseScoreOrderByWithRelationInput | PhraseScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhraseScores.
     */
    cursor?: PhraseScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhraseScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhraseScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhraseScores.
     */
    distinct?: PhraseScoreScalarFieldEnum | PhraseScoreScalarFieldEnum[]
  }

  /**
   * PhraseScore findFirstOrThrow
   */
  export type PhraseScoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseScore
     */
    select?: PhraseScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhraseScore
     */
    omit?: PhraseScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseScoreInclude<ExtArgs> | null
    /**
     * Filter, which PhraseScore to fetch.
     */
    where?: PhraseScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhraseScores to fetch.
     */
    orderBy?: PhraseScoreOrderByWithRelationInput | PhraseScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhraseScores.
     */
    cursor?: PhraseScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhraseScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhraseScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhraseScores.
     */
    distinct?: PhraseScoreScalarFieldEnum | PhraseScoreScalarFieldEnum[]
  }

  /**
   * PhraseScore findMany
   */
  export type PhraseScoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseScore
     */
    select?: PhraseScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhraseScore
     */
    omit?: PhraseScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseScoreInclude<ExtArgs> | null
    /**
     * Filter, which PhraseScores to fetch.
     */
    where?: PhraseScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhraseScores to fetch.
     */
    orderBy?: PhraseScoreOrderByWithRelationInput | PhraseScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PhraseScores.
     */
    cursor?: PhraseScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhraseScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhraseScores.
     */
    skip?: number
    distinct?: PhraseScoreScalarFieldEnum | PhraseScoreScalarFieldEnum[]
  }

  /**
   * PhraseScore create
   */
  export type PhraseScoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseScore
     */
    select?: PhraseScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhraseScore
     */
    omit?: PhraseScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseScoreInclude<ExtArgs> | null
    /**
     * The data needed to create a PhraseScore.
     */
    data: XOR<PhraseScoreCreateInput, PhraseScoreUncheckedCreateInput>
  }

  /**
   * PhraseScore createMany
   */
  export type PhraseScoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PhraseScores.
     */
    data: PhraseScoreCreateManyInput | PhraseScoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PhraseScore createManyAndReturn
   */
  export type PhraseScoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseScore
     */
    select?: PhraseScoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PhraseScore
     */
    omit?: PhraseScoreOmit<ExtArgs> | null
    /**
     * The data used to create many PhraseScores.
     */
    data: PhraseScoreCreateManyInput | PhraseScoreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseScoreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PhraseScore update
   */
  export type PhraseScoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseScore
     */
    select?: PhraseScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhraseScore
     */
    omit?: PhraseScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseScoreInclude<ExtArgs> | null
    /**
     * The data needed to update a PhraseScore.
     */
    data: XOR<PhraseScoreUpdateInput, PhraseScoreUncheckedUpdateInput>
    /**
     * Choose, which PhraseScore to update.
     */
    where: PhraseScoreWhereUniqueInput
  }

  /**
   * PhraseScore updateMany
   */
  export type PhraseScoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PhraseScores.
     */
    data: XOR<PhraseScoreUpdateManyMutationInput, PhraseScoreUncheckedUpdateManyInput>
    /**
     * Filter which PhraseScores to update
     */
    where?: PhraseScoreWhereInput
  }

  /**
   * PhraseScore upsert
   */
  export type PhraseScoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseScore
     */
    select?: PhraseScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhraseScore
     */
    omit?: PhraseScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseScoreInclude<ExtArgs> | null
    /**
     * The filter to search for the PhraseScore to update in case it exists.
     */
    where: PhraseScoreWhereUniqueInput
    /**
     * In case the PhraseScore found by the `where` argument doesn't exist, create a new PhraseScore with this data.
     */
    create: XOR<PhraseScoreCreateInput, PhraseScoreUncheckedCreateInput>
    /**
     * In case the PhraseScore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhraseScoreUpdateInput, PhraseScoreUncheckedUpdateInput>
  }

  /**
   * PhraseScore delete
   */
  export type PhraseScoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseScore
     */
    select?: PhraseScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhraseScore
     */
    omit?: PhraseScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseScoreInclude<ExtArgs> | null
    /**
     * Filter which PhraseScore to delete.
     */
    where: PhraseScoreWhereUniqueInput
  }

  /**
   * PhraseScore deleteMany
   */
  export type PhraseScoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhraseScores to delete
     */
    where?: PhraseScoreWhereInput
  }

  /**
   * PhraseScore without action
   */
  export type PhraseScoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseScore
     */
    select?: PhraseScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhraseScore
     */
    omit?: PhraseScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseScoreInclude<ExtArgs> | null
  }


  /**
   * Model IntentPhraseGeneration
   */

  export type AggregateIntentPhraseGeneration = {
    _count: IntentPhraseGenerationCountAggregateOutputType | null
    _avg: IntentPhraseGenerationAvgAggregateOutputType | null
    _sum: IntentPhraseGenerationSumAggregateOutputType | null
    _min: IntentPhraseGenerationMinAggregateOutputType | null
    _max: IntentPhraseGenerationMaxAggregateOutputType | null
  }

  export type IntentPhraseGenerationAvgAggregateOutputType = {
    id: number | null
    domainId: number | null
    progress: number | null
    tokenUsage: number | null
  }

  export type IntentPhraseGenerationSumAggregateOutputType = {
    id: number | null
    domainId: number | null
    progress: number | null
    tokenUsage: number | null
  }

  export type IntentPhraseGenerationMinAggregateOutputType = {
    id: number | null
    domainId: number | null
    status: string | null
    phase: string | null
    progress: number | null
    startTime: Date | null
    endTime: Date | null
    error: string | null
    tokenUsage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntentPhraseGenerationMaxAggregateOutputType = {
    id: number | null
    domainId: number | null
    status: string | null
    phase: string | null
    progress: number | null
    startTime: Date | null
    endTime: Date | null
    error: string | null
    tokenUsage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntentPhraseGenerationCountAggregateOutputType = {
    id: number
    domainId: number
    status: number
    phase: number
    progress: number
    startTime: number
    endTime: number
    result: number
    error: number
    tokenUsage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntentPhraseGenerationAvgAggregateInputType = {
    id?: true
    domainId?: true
    progress?: true
    tokenUsage?: true
  }

  export type IntentPhraseGenerationSumAggregateInputType = {
    id?: true
    domainId?: true
    progress?: true
    tokenUsage?: true
  }

  export type IntentPhraseGenerationMinAggregateInputType = {
    id?: true
    domainId?: true
    status?: true
    phase?: true
    progress?: true
    startTime?: true
    endTime?: true
    error?: true
    tokenUsage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntentPhraseGenerationMaxAggregateInputType = {
    id?: true
    domainId?: true
    status?: true
    phase?: true
    progress?: true
    startTime?: true
    endTime?: true
    error?: true
    tokenUsage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntentPhraseGenerationCountAggregateInputType = {
    id?: true
    domainId?: true
    status?: true
    phase?: true
    progress?: true
    startTime?: true
    endTime?: true
    result?: true
    error?: true
    tokenUsage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntentPhraseGenerationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntentPhraseGeneration to aggregate.
     */
    where?: IntentPhraseGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntentPhraseGenerations to fetch.
     */
    orderBy?: IntentPhraseGenerationOrderByWithRelationInput | IntentPhraseGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntentPhraseGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntentPhraseGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntentPhraseGenerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntentPhraseGenerations
    **/
    _count?: true | IntentPhraseGenerationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntentPhraseGenerationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntentPhraseGenerationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntentPhraseGenerationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntentPhraseGenerationMaxAggregateInputType
  }

  export type GetIntentPhraseGenerationAggregateType<T extends IntentPhraseGenerationAggregateArgs> = {
        [P in keyof T & keyof AggregateIntentPhraseGeneration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntentPhraseGeneration[P]>
      : GetScalarType<T[P], AggregateIntentPhraseGeneration[P]>
  }




  export type IntentPhraseGenerationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntentPhraseGenerationWhereInput
    orderBy?: IntentPhraseGenerationOrderByWithAggregationInput | IntentPhraseGenerationOrderByWithAggregationInput[]
    by: IntentPhraseGenerationScalarFieldEnum[] | IntentPhraseGenerationScalarFieldEnum
    having?: IntentPhraseGenerationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntentPhraseGenerationCountAggregateInputType | true
    _avg?: IntentPhraseGenerationAvgAggregateInputType
    _sum?: IntentPhraseGenerationSumAggregateInputType
    _min?: IntentPhraseGenerationMinAggregateInputType
    _max?: IntentPhraseGenerationMaxAggregateInputType
  }

  export type IntentPhraseGenerationGroupByOutputType = {
    id: number
    domainId: number
    status: string
    phase: string
    progress: number
    startTime: Date
    endTime: Date | null
    result: JsonValue | null
    error: string | null
    tokenUsage: number | null
    createdAt: Date
    updatedAt: Date
    _count: IntentPhraseGenerationCountAggregateOutputType | null
    _avg: IntentPhraseGenerationAvgAggregateOutputType | null
    _sum: IntentPhraseGenerationSumAggregateOutputType | null
    _min: IntentPhraseGenerationMinAggregateOutputType | null
    _max: IntentPhraseGenerationMaxAggregateOutputType | null
  }

  type GetIntentPhraseGenerationGroupByPayload<T extends IntentPhraseGenerationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntentPhraseGenerationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntentPhraseGenerationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntentPhraseGenerationGroupByOutputType[P]>
            : GetScalarType<T[P], IntentPhraseGenerationGroupByOutputType[P]>
        }
      >
    >


  export type IntentPhraseGenerationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    status?: boolean
    phase?: boolean
    progress?: boolean
    startTime?: boolean
    endTime?: boolean
    result?: boolean
    error?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domain?: boolean | IntentPhraseGeneration$domainArgs<ExtArgs>
  }, ExtArgs["result"]["intentPhraseGeneration"]>

  export type IntentPhraseGenerationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    status?: boolean
    phase?: boolean
    progress?: boolean
    startTime?: boolean
    endTime?: boolean
    result?: boolean
    error?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domain?: boolean | IntentPhraseGeneration$domainArgs<ExtArgs>
  }, ExtArgs["result"]["intentPhraseGeneration"]>


  export type IntentPhraseGenerationSelectScalar = {
    id?: boolean
    domainId?: boolean
    status?: boolean
    phase?: boolean
    progress?: boolean
    startTime?: boolean
    endTime?: boolean
    result?: boolean
    error?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntentPhraseGenerationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "domainId" | "status" | "phase" | "progress" | "startTime" | "endTime" | "result" | "error" | "tokenUsage" | "createdAt" | "updatedAt", ExtArgs["result"]["intentPhraseGeneration"]>
  export type IntentPhraseGenerationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | IntentPhraseGeneration$domainArgs<ExtArgs>
  }
  export type IntentPhraseGenerationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | IntentPhraseGeneration$domainArgs<ExtArgs>
  }

  export type $IntentPhraseGenerationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IntentPhraseGeneration"
    objects: {
      domain: Prisma.$DomainPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      domainId: number
      status: string
      phase: string
      progress: number
      startTime: Date
      endTime: Date | null
      result: Prisma.JsonValue | null
      error: string | null
      tokenUsage: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["intentPhraseGeneration"]>
    composites: {}
  }

  type IntentPhraseGenerationGetPayload<S extends boolean | null | undefined | IntentPhraseGenerationDefaultArgs> = $Result.GetResult<Prisma.$IntentPhraseGenerationPayload, S>

  type IntentPhraseGenerationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IntentPhraseGenerationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IntentPhraseGenerationCountAggregateInputType | true
    }

  export interface IntentPhraseGenerationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IntentPhraseGeneration'], meta: { name: 'IntentPhraseGeneration' } }
    /**
     * Find zero or one IntentPhraseGeneration that matches the filter.
     * @param {IntentPhraseGenerationFindUniqueArgs} args - Arguments to find a IntentPhraseGeneration
     * @example
     * // Get one IntentPhraseGeneration
     * const intentPhraseGeneration = await prisma.intentPhraseGeneration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntentPhraseGenerationFindUniqueArgs>(args: SelectSubset<T, IntentPhraseGenerationFindUniqueArgs<ExtArgs>>): Prisma__IntentPhraseGenerationClient<$Result.GetResult<Prisma.$IntentPhraseGenerationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IntentPhraseGeneration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IntentPhraseGenerationFindUniqueOrThrowArgs} args - Arguments to find a IntentPhraseGeneration
     * @example
     * // Get one IntentPhraseGeneration
     * const intentPhraseGeneration = await prisma.intentPhraseGeneration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntentPhraseGenerationFindUniqueOrThrowArgs>(args: SelectSubset<T, IntentPhraseGenerationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntentPhraseGenerationClient<$Result.GetResult<Prisma.$IntentPhraseGenerationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IntentPhraseGeneration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentPhraseGenerationFindFirstArgs} args - Arguments to find a IntentPhraseGeneration
     * @example
     * // Get one IntentPhraseGeneration
     * const intentPhraseGeneration = await prisma.intentPhraseGeneration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntentPhraseGenerationFindFirstArgs>(args?: SelectSubset<T, IntentPhraseGenerationFindFirstArgs<ExtArgs>>): Prisma__IntentPhraseGenerationClient<$Result.GetResult<Prisma.$IntentPhraseGenerationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IntentPhraseGeneration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentPhraseGenerationFindFirstOrThrowArgs} args - Arguments to find a IntentPhraseGeneration
     * @example
     * // Get one IntentPhraseGeneration
     * const intentPhraseGeneration = await prisma.intentPhraseGeneration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntentPhraseGenerationFindFirstOrThrowArgs>(args?: SelectSubset<T, IntentPhraseGenerationFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntentPhraseGenerationClient<$Result.GetResult<Prisma.$IntentPhraseGenerationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IntentPhraseGenerations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentPhraseGenerationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntentPhraseGenerations
     * const intentPhraseGenerations = await prisma.intentPhraseGeneration.findMany()
     * 
     * // Get first 10 IntentPhraseGenerations
     * const intentPhraseGenerations = await prisma.intentPhraseGeneration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const intentPhraseGenerationWithIdOnly = await prisma.intentPhraseGeneration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntentPhraseGenerationFindManyArgs>(args?: SelectSubset<T, IntentPhraseGenerationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntentPhraseGenerationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IntentPhraseGeneration.
     * @param {IntentPhraseGenerationCreateArgs} args - Arguments to create a IntentPhraseGeneration.
     * @example
     * // Create one IntentPhraseGeneration
     * const IntentPhraseGeneration = await prisma.intentPhraseGeneration.create({
     *   data: {
     *     // ... data to create a IntentPhraseGeneration
     *   }
     * })
     * 
     */
    create<T extends IntentPhraseGenerationCreateArgs>(args: SelectSubset<T, IntentPhraseGenerationCreateArgs<ExtArgs>>): Prisma__IntentPhraseGenerationClient<$Result.GetResult<Prisma.$IntentPhraseGenerationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IntentPhraseGenerations.
     * @param {IntentPhraseGenerationCreateManyArgs} args - Arguments to create many IntentPhraseGenerations.
     * @example
     * // Create many IntentPhraseGenerations
     * const intentPhraseGeneration = await prisma.intentPhraseGeneration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntentPhraseGenerationCreateManyArgs>(args?: SelectSubset<T, IntentPhraseGenerationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IntentPhraseGenerations and returns the data saved in the database.
     * @param {IntentPhraseGenerationCreateManyAndReturnArgs} args - Arguments to create many IntentPhraseGenerations.
     * @example
     * // Create many IntentPhraseGenerations
     * const intentPhraseGeneration = await prisma.intentPhraseGeneration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IntentPhraseGenerations and only return the `id`
     * const intentPhraseGenerationWithIdOnly = await prisma.intentPhraseGeneration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntentPhraseGenerationCreateManyAndReturnArgs>(args?: SelectSubset<T, IntentPhraseGenerationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntentPhraseGenerationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IntentPhraseGeneration.
     * @param {IntentPhraseGenerationDeleteArgs} args - Arguments to delete one IntentPhraseGeneration.
     * @example
     * // Delete one IntentPhraseGeneration
     * const IntentPhraseGeneration = await prisma.intentPhraseGeneration.delete({
     *   where: {
     *     // ... filter to delete one IntentPhraseGeneration
     *   }
     * })
     * 
     */
    delete<T extends IntentPhraseGenerationDeleteArgs>(args: SelectSubset<T, IntentPhraseGenerationDeleteArgs<ExtArgs>>): Prisma__IntentPhraseGenerationClient<$Result.GetResult<Prisma.$IntentPhraseGenerationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IntentPhraseGeneration.
     * @param {IntentPhraseGenerationUpdateArgs} args - Arguments to update one IntentPhraseGeneration.
     * @example
     * // Update one IntentPhraseGeneration
     * const intentPhraseGeneration = await prisma.intentPhraseGeneration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntentPhraseGenerationUpdateArgs>(args: SelectSubset<T, IntentPhraseGenerationUpdateArgs<ExtArgs>>): Prisma__IntentPhraseGenerationClient<$Result.GetResult<Prisma.$IntentPhraseGenerationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IntentPhraseGenerations.
     * @param {IntentPhraseGenerationDeleteManyArgs} args - Arguments to filter IntentPhraseGenerations to delete.
     * @example
     * // Delete a few IntentPhraseGenerations
     * const { count } = await prisma.intentPhraseGeneration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntentPhraseGenerationDeleteManyArgs>(args?: SelectSubset<T, IntentPhraseGenerationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntentPhraseGenerations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentPhraseGenerationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntentPhraseGenerations
     * const intentPhraseGeneration = await prisma.intentPhraseGeneration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntentPhraseGenerationUpdateManyArgs>(args: SelectSubset<T, IntentPhraseGenerationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IntentPhraseGeneration.
     * @param {IntentPhraseGenerationUpsertArgs} args - Arguments to update or create a IntentPhraseGeneration.
     * @example
     * // Update or create a IntentPhraseGeneration
     * const intentPhraseGeneration = await prisma.intentPhraseGeneration.upsert({
     *   create: {
     *     // ... data to create a IntentPhraseGeneration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntentPhraseGeneration we want to update
     *   }
     * })
     */
    upsert<T extends IntentPhraseGenerationUpsertArgs>(args: SelectSubset<T, IntentPhraseGenerationUpsertArgs<ExtArgs>>): Prisma__IntentPhraseGenerationClient<$Result.GetResult<Prisma.$IntentPhraseGenerationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IntentPhraseGenerations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentPhraseGenerationCountArgs} args - Arguments to filter IntentPhraseGenerations to count.
     * @example
     * // Count the number of IntentPhraseGenerations
     * const count = await prisma.intentPhraseGeneration.count({
     *   where: {
     *     // ... the filter for the IntentPhraseGenerations we want to count
     *   }
     * })
    **/
    count<T extends IntentPhraseGenerationCountArgs>(
      args?: Subset<T, IntentPhraseGenerationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntentPhraseGenerationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntentPhraseGeneration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentPhraseGenerationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntentPhraseGenerationAggregateArgs>(args: Subset<T, IntentPhraseGenerationAggregateArgs>): Prisma.PrismaPromise<GetIntentPhraseGenerationAggregateType<T>>

    /**
     * Group by IntentPhraseGeneration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentPhraseGenerationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntentPhraseGenerationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntentPhraseGenerationGroupByArgs['orderBy'] }
        : { orderBy?: IntentPhraseGenerationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntentPhraseGenerationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntentPhraseGenerationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IntentPhraseGeneration model
   */
  readonly fields: IntentPhraseGenerationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntentPhraseGeneration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntentPhraseGenerationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domain<T extends IntentPhraseGeneration$domainArgs<ExtArgs> = {}>(args?: Subset<T, IntentPhraseGeneration$domainArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IntentPhraseGeneration model
   */
  interface IntentPhraseGenerationFieldRefs {
    readonly id: FieldRef<"IntentPhraseGeneration", 'Int'>
    readonly domainId: FieldRef<"IntentPhraseGeneration", 'Int'>
    readonly status: FieldRef<"IntentPhraseGeneration", 'String'>
    readonly phase: FieldRef<"IntentPhraseGeneration", 'String'>
    readonly progress: FieldRef<"IntentPhraseGeneration", 'Int'>
    readonly startTime: FieldRef<"IntentPhraseGeneration", 'DateTime'>
    readonly endTime: FieldRef<"IntentPhraseGeneration", 'DateTime'>
    readonly result: FieldRef<"IntentPhraseGeneration", 'Json'>
    readonly error: FieldRef<"IntentPhraseGeneration", 'String'>
    readonly tokenUsage: FieldRef<"IntentPhraseGeneration", 'Int'>
    readonly createdAt: FieldRef<"IntentPhraseGeneration", 'DateTime'>
    readonly updatedAt: FieldRef<"IntentPhraseGeneration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IntentPhraseGeneration findUnique
   */
  export type IntentPhraseGenerationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentPhraseGeneration
     */
    select?: IntentPhraseGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentPhraseGeneration
     */
    omit?: IntentPhraseGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentPhraseGenerationInclude<ExtArgs> | null
    /**
     * Filter, which IntentPhraseGeneration to fetch.
     */
    where: IntentPhraseGenerationWhereUniqueInput
  }

  /**
   * IntentPhraseGeneration findUniqueOrThrow
   */
  export type IntentPhraseGenerationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentPhraseGeneration
     */
    select?: IntentPhraseGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentPhraseGeneration
     */
    omit?: IntentPhraseGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentPhraseGenerationInclude<ExtArgs> | null
    /**
     * Filter, which IntentPhraseGeneration to fetch.
     */
    where: IntentPhraseGenerationWhereUniqueInput
  }

  /**
   * IntentPhraseGeneration findFirst
   */
  export type IntentPhraseGenerationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentPhraseGeneration
     */
    select?: IntentPhraseGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentPhraseGeneration
     */
    omit?: IntentPhraseGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentPhraseGenerationInclude<ExtArgs> | null
    /**
     * Filter, which IntentPhraseGeneration to fetch.
     */
    where?: IntentPhraseGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntentPhraseGenerations to fetch.
     */
    orderBy?: IntentPhraseGenerationOrderByWithRelationInput | IntentPhraseGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntentPhraseGenerations.
     */
    cursor?: IntentPhraseGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntentPhraseGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntentPhraseGenerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntentPhraseGenerations.
     */
    distinct?: IntentPhraseGenerationScalarFieldEnum | IntentPhraseGenerationScalarFieldEnum[]
  }

  /**
   * IntentPhraseGeneration findFirstOrThrow
   */
  export type IntentPhraseGenerationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentPhraseGeneration
     */
    select?: IntentPhraseGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentPhraseGeneration
     */
    omit?: IntentPhraseGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentPhraseGenerationInclude<ExtArgs> | null
    /**
     * Filter, which IntentPhraseGeneration to fetch.
     */
    where?: IntentPhraseGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntentPhraseGenerations to fetch.
     */
    orderBy?: IntentPhraseGenerationOrderByWithRelationInput | IntentPhraseGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntentPhraseGenerations.
     */
    cursor?: IntentPhraseGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntentPhraseGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntentPhraseGenerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntentPhraseGenerations.
     */
    distinct?: IntentPhraseGenerationScalarFieldEnum | IntentPhraseGenerationScalarFieldEnum[]
  }

  /**
   * IntentPhraseGeneration findMany
   */
  export type IntentPhraseGenerationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentPhraseGeneration
     */
    select?: IntentPhraseGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentPhraseGeneration
     */
    omit?: IntentPhraseGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentPhraseGenerationInclude<ExtArgs> | null
    /**
     * Filter, which IntentPhraseGenerations to fetch.
     */
    where?: IntentPhraseGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntentPhraseGenerations to fetch.
     */
    orderBy?: IntentPhraseGenerationOrderByWithRelationInput | IntentPhraseGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntentPhraseGenerations.
     */
    cursor?: IntentPhraseGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntentPhraseGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntentPhraseGenerations.
     */
    skip?: number
    distinct?: IntentPhraseGenerationScalarFieldEnum | IntentPhraseGenerationScalarFieldEnum[]
  }

  /**
   * IntentPhraseGeneration create
   */
  export type IntentPhraseGenerationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentPhraseGeneration
     */
    select?: IntentPhraseGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentPhraseGeneration
     */
    omit?: IntentPhraseGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentPhraseGenerationInclude<ExtArgs> | null
    /**
     * The data needed to create a IntentPhraseGeneration.
     */
    data: XOR<IntentPhraseGenerationCreateInput, IntentPhraseGenerationUncheckedCreateInput>
  }

  /**
   * IntentPhraseGeneration createMany
   */
  export type IntentPhraseGenerationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IntentPhraseGenerations.
     */
    data: IntentPhraseGenerationCreateManyInput | IntentPhraseGenerationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IntentPhraseGeneration createManyAndReturn
   */
  export type IntentPhraseGenerationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentPhraseGeneration
     */
    select?: IntentPhraseGenerationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IntentPhraseGeneration
     */
    omit?: IntentPhraseGenerationOmit<ExtArgs> | null
    /**
     * The data used to create many IntentPhraseGenerations.
     */
    data: IntentPhraseGenerationCreateManyInput | IntentPhraseGenerationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentPhraseGenerationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IntentPhraseGeneration update
   */
  export type IntentPhraseGenerationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentPhraseGeneration
     */
    select?: IntentPhraseGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentPhraseGeneration
     */
    omit?: IntentPhraseGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentPhraseGenerationInclude<ExtArgs> | null
    /**
     * The data needed to update a IntentPhraseGeneration.
     */
    data: XOR<IntentPhraseGenerationUpdateInput, IntentPhraseGenerationUncheckedUpdateInput>
    /**
     * Choose, which IntentPhraseGeneration to update.
     */
    where: IntentPhraseGenerationWhereUniqueInput
  }

  /**
   * IntentPhraseGeneration updateMany
   */
  export type IntentPhraseGenerationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IntentPhraseGenerations.
     */
    data: XOR<IntentPhraseGenerationUpdateManyMutationInput, IntentPhraseGenerationUncheckedUpdateManyInput>
    /**
     * Filter which IntentPhraseGenerations to update
     */
    where?: IntentPhraseGenerationWhereInput
  }

  /**
   * IntentPhraseGeneration upsert
   */
  export type IntentPhraseGenerationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentPhraseGeneration
     */
    select?: IntentPhraseGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentPhraseGeneration
     */
    omit?: IntentPhraseGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentPhraseGenerationInclude<ExtArgs> | null
    /**
     * The filter to search for the IntentPhraseGeneration to update in case it exists.
     */
    where: IntentPhraseGenerationWhereUniqueInput
    /**
     * In case the IntentPhraseGeneration found by the `where` argument doesn't exist, create a new IntentPhraseGeneration with this data.
     */
    create: XOR<IntentPhraseGenerationCreateInput, IntentPhraseGenerationUncheckedCreateInput>
    /**
     * In case the IntentPhraseGeneration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntentPhraseGenerationUpdateInput, IntentPhraseGenerationUncheckedUpdateInput>
  }

  /**
   * IntentPhraseGeneration delete
   */
  export type IntentPhraseGenerationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentPhraseGeneration
     */
    select?: IntentPhraseGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentPhraseGeneration
     */
    omit?: IntentPhraseGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentPhraseGenerationInclude<ExtArgs> | null
    /**
     * Filter which IntentPhraseGeneration to delete.
     */
    where: IntentPhraseGenerationWhereUniqueInput
  }

  /**
   * IntentPhraseGeneration deleteMany
   */
  export type IntentPhraseGenerationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntentPhraseGenerations to delete
     */
    where?: IntentPhraseGenerationWhereInput
  }

  /**
   * IntentPhraseGeneration.domain
   */
  export type IntentPhraseGeneration$domainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    where?: DomainWhereInput
  }

  /**
   * IntentPhraseGeneration without action
   */
  export type IntentPhraseGenerationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentPhraseGeneration
     */
    select?: IntentPhraseGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentPhraseGeneration
     */
    omit?: IntentPhraseGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentPhraseGenerationInclude<ExtArgs> | null
  }


  /**
   * Model CommunityMiningResult
   */

  export type AggregateCommunityMiningResult = {
    _count: CommunityMiningResultCountAggregateOutputType | null
    _avg: CommunityMiningResultAvgAggregateOutputType | null
    _sum: CommunityMiningResultSumAggregateOutputType | null
    _min: CommunityMiningResultMinAggregateOutputType | null
    _max: CommunityMiningResultMaxAggregateOutputType | null
  }

  export type CommunityMiningResultAvgAggregateOutputType = {
    id: number | null
    domainId: number | null
    keywordId: number | null
    frequency: number | null
    tokenUsage: number | null
  }

  export type CommunityMiningResultSumAggregateOutputType = {
    id: number | null
    domainId: number | null
    keywordId: number | null
    frequency: number | null
    tokenUsage: number | null
  }

  export type CommunityMiningResultMinAggregateOutputType = {
    id: number | null
    domainId: number | null
    keywordId: number | null
    platform: string | null
    sentiment: string | null
    frequency: number | null
    tokenUsage: number | null
    createdAt: Date | null
  }

  export type CommunityMiningResultMaxAggregateOutputType = {
    id: number | null
    domainId: number | null
    keywordId: number | null
    platform: string | null
    sentiment: string | null
    frequency: number | null
    tokenUsage: number | null
    createdAt: Date | null
  }

  export type CommunityMiningResultCountAggregateOutputType = {
    id: number
    domainId: number
    keywordId: number
    platform: number
    insights: number
    sentiment: number
    frequency: number
    tokenUsage: number
    createdAt: number
    _all: number
  }


  export type CommunityMiningResultAvgAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    frequency?: true
    tokenUsage?: true
  }

  export type CommunityMiningResultSumAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    frequency?: true
    tokenUsage?: true
  }

  export type CommunityMiningResultMinAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    platform?: true
    sentiment?: true
    frequency?: true
    tokenUsage?: true
    createdAt?: true
  }

  export type CommunityMiningResultMaxAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    platform?: true
    sentiment?: true
    frequency?: true
    tokenUsage?: true
    createdAt?: true
  }

  export type CommunityMiningResultCountAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    platform?: true
    insights?: true
    sentiment?: true
    frequency?: true
    tokenUsage?: true
    createdAt?: true
    _all?: true
  }

  export type CommunityMiningResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityMiningResult to aggregate.
     */
    where?: CommunityMiningResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityMiningResults to fetch.
     */
    orderBy?: CommunityMiningResultOrderByWithRelationInput | CommunityMiningResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityMiningResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityMiningResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityMiningResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityMiningResults
    **/
    _count?: true | CommunityMiningResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityMiningResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunityMiningResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityMiningResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityMiningResultMaxAggregateInputType
  }

  export type GetCommunityMiningResultAggregateType<T extends CommunityMiningResultAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunityMiningResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityMiningResult[P]>
      : GetScalarType<T[P], AggregateCommunityMiningResult[P]>
  }




  export type CommunityMiningResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityMiningResultWhereInput
    orderBy?: CommunityMiningResultOrderByWithAggregationInput | CommunityMiningResultOrderByWithAggregationInput[]
    by: CommunityMiningResultScalarFieldEnum[] | CommunityMiningResultScalarFieldEnum
    having?: CommunityMiningResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityMiningResultCountAggregateInputType | true
    _avg?: CommunityMiningResultAvgAggregateInputType
    _sum?: CommunityMiningResultSumAggregateInputType
    _min?: CommunityMiningResultMinAggregateInputType
    _max?: CommunityMiningResultMaxAggregateInputType
  }

  export type CommunityMiningResultGroupByOutputType = {
    id: number
    domainId: number
    keywordId: number | null
    platform: string
    insights: JsonValue
    sentiment: string | null
    frequency: number | null
    tokenUsage: number | null
    createdAt: Date
    _count: CommunityMiningResultCountAggregateOutputType | null
    _avg: CommunityMiningResultAvgAggregateOutputType | null
    _sum: CommunityMiningResultSumAggregateOutputType | null
    _min: CommunityMiningResultMinAggregateOutputType | null
    _max: CommunityMiningResultMaxAggregateOutputType | null
  }

  type GetCommunityMiningResultGroupByPayload<T extends CommunityMiningResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityMiningResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityMiningResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityMiningResultGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityMiningResultGroupByOutputType[P]>
        }
      >
    >


  export type CommunityMiningResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    keywordId?: boolean
    platform?: boolean
    insights?: boolean
    sentiment?: boolean
    frequency?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    domain?: boolean | CommunityMiningResult$domainArgs<ExtArgs>
    keyword?: boolean | CommunityMiningResult$keywordArgs<ExtArgs>
  }, ExtArgs["result"]["communityMiningResult"]>

  export type CommunityMiningResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    keywordId?: boolean
    platform?: boolean
    insights?: boolean
    sentiment?: boolean
    frequency?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    domain?: boolean | CommunityMiningResult$domainArgs<ExtArgs>
    keyword?: boolean | CommunityMiningResult$keywordArgs<ExtArgs>
  }, ExtArgs["result"]["communityMiningResult"]>


  export type CommunityMiningResultSelectScalar = {
    id?: boolean
    domainId?: boolean
    keywordId?: boolean
    platform?: boolean
    insights?: boolean
    sentiment?: boolean
    frequency?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
  }

  export type CommunityMiningResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "domainId" | "keywordId" | "platform" | "insights" | "sentiment" | "frequency" | "tokenUsage" | "createdAt", ExtArgs["result"]["communityMiningResult"]>
  export type CommunityMiningResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | CommunityMiningResult$domainArgs<ExtArgs>
    keyword?: boolean | CommunityMiningResult$keywordArgs<ExtArgs>
  }
  export type CommunityMiningResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | CommunityMiningResult$domainArgs<ExtArgs>
    keyword?: boolean | CommunityMiningResult$keywordArgs<ExtArgs>
  }

  export type $CommunityMiningResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommunityMiningResult"
    objects: {
      domain: Prisma.$DomainPayload<ExtArgs> | null
      keyword: Prisma.$KeywordPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      domainId: number
      keywordId: number | null
      platform: string
      insights: Prisma.JsonValue
      sentiment: string | null
      frequency: number | null
      tokenUsage: number | null
      createdAt: Date
    }, ExtArgs["result"]["communityMiningResult"]>
    composites: {}
  }

  type CommunityMiningResultGetPayload<S extends boolean | null | undefined | CommunityMiningResultDefaultArgs> = $Result.GetResult<Prisma.$CommunityMiningResultPayload, S>

  type CommunityMiningResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommunityMiningResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommunityMiningResultCountAggregateInputType | true
    }

  export interface CommunityMiningResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunityMiningResult'], meta: { name: 'CommunityMiningResult' } }
    /**
     * Find zero or one CommunityMiningResult that matches the filter.
     * @param {CommunityMiningResultFindUniqueArgs} args - Arguments to find a CommunityMiningResult
     * @example
     * // Get one CommunityMiningResult
     * const communityMiningResult = await prisma.communityMiningResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunityMiningResultFindUniqueArgs>(args: SelectSubset<T, CommunityMiningResultFindUniqueArgs<ExtArgs>>): Prisma__CommunityMiningResultClient<$Result.GetResult<Prisma.$CommunityMiningResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommunityMiningResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommunityMiningResultFindUniqueOrThrowArgs} args - Arguments to find a CommunityMiningResult
     * @example
     * // Get one CommunityMiningResult
     * const communityMiningResult = await prisma.communityMiningResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunityMiningResultFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunityMiningResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunityMiningResultClient<$Result.GetResult<Prisma.$CommunityMiningResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommunityMiningResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityMiningResultFindFirstArgs} args - Arguments to find a CommunityMiningResult
     * @example
     * // Get one CommunityMiningResult
     * const communityMiningResult = await prisma.communityMiningResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunityMiningResultFindFirstArgs>(args?: SelectSubset<T, CommunityMiningResultFindFirstArgs<ExtArgs>>): Prisma__CommunityMiningResultClient<$Result.GetResult<Prisma.$CommunityMiningResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommunityMiningResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityMiningResultFindFirstOrThrowArgs} args - Arguments to find a CommunityMiningResult
     * @example
     * // Get one CommunityMiningResult
     * const communityMiningResult = await prisma.communityMiningResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunityMiningResultFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunityMiningResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunityMiningResultClient<$Result.GetResult<Prisma.$CommunityMiningResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommunityMiningResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityMiningResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityMiningResults
     * const communityMiningResults = await prisma.communityMiningResult.findMany()
     * 
     * // Get first 10 CommunityMiningResults
     * const communityMiningResults = await prisma.communityMiningResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityMiningResultWithIdOnly = await prisma.communityMiningResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunityMiningResultFindManyArgs>(args?: SelectSubset<T, CommunityMiningResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityMiningResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommunityMiningResult.
     * @param {CommunityMiningResultCreateArgs} args - Arguments to create a CommunityMiningResult.
     * @example
     * // Create one CommunityMiningResult
     * const CommunityMiningResult = await prisma.communityMiningResult.create({
     *   data: {
     *     // ... data to create a CommunityMiningResult
     *   }
     * })
     * 
     */
    create<T extends CommunityMiningResultCreateArgs>(args: SelectSubset<T, CommunityMiningResultCreateArgs<ExtArgs>>): Prisma__CommunityMiningResultClient<$Result.GetResult<Prisma.$CommunityMiningResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommunityMiningResults.
     * @param {CommunityMiningResultCreateManyArgs} args - Arguments to create many CommunityMiningResults.
     * @example
     * // Create many CommunityMiningResults
     * const communityMiningResult = await prisma.communityMiningResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunityMiningResultCreateManyArgs>(args?: SelectSubset<T, CommunityMiningResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommunityMiningResults and returns the data saved in the database.
     * @param {CommunityMiningResultCreateManyAndReturnArgs} args - Arguments to create many CommunityMiningResults.
     * @example
     * // Create many CommunityMiningResults
     * const communityMiningResult = await prisma.communityMiningResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommunityMiningResults and only return the `id`
     * const communityMiningResultWithIdOnly = await prisma.communityMiningResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommunityMiningResultCreateManyAndReturnArgs>(args?: SelectSubset<T, CommunityMiningResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityMiningResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CommunityMiningResult.
     * @param {CommunityMiningResultDeleteArgs} args - Arguments to delete one CommunityMiningResult.
     * @example
     * // Delete one CommunityMiningResult
     * const CommunityMiningResult = await prisma.communityMiningResult.delete({
     *   where: {
     *     // ... filter to delete one CommunityMiningResult
     *   }
     * })
     * 
     */
    delete<T extends CommunityMiningResultDeleteArgs>(args: SelectSubset<T, CommunityMiningResultDeleteArgs<ExtArgs>>): Prisma__CommunityMiningResultClient<$Result.GetResult<Prisma.$CommunityMiningResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommunityMiningResult.
     * @param {CommunityMiningResultUpdateArgs} args - Arguments to update one CommunityMiningResult.
     * @example
     * // Update one CommunityMiningResult
     * const communityMiningResult = await prisma.communityMiningResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunityMiningResultUpdateArgs>(args: SelectSubset<T, CommunityMiningResultUpdateArgs<ExtArgs>>): Prisma__CommunityMiningResultClient<$Result.GetResult<Prisma.$CommunityMiningResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommunityMiningResults.
     * @param {CommunityMiningResultDeleteManyArgs} args - Arguments to filter CommunityMiningResults to delete.
     * @example
     * // Delete a few CommunityMiningResults
     * const { count } = await prisma.communityMiningResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunityMiningResultDeleteManyArgs>(args?: SelectSubset<T, CommunityMiningResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityMiningResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityMiningResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityMiningResults
     * const communityMiningResult = await prisma.communityMiningResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunityMiningResultUpdateManyArgs>(args: SelectSubset<T, CommunityMiningResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunityMiningResult.
     * @param {CommunityMiningResultUpsertArgs} args - Arguments to update or create a CommunityMiningResult.
     * @example
     * // Update or create a CommunityMiningResult
     * const communityMiningResult = await prisma.communityMiningResult.upsert({
     *   create: {
     *     // ... data to create a CommunityMiningResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityMiningResult we want to update
     *   }
     * })
     */
    upsert<T extends CommunityMiningResultUpsertArgs>(args: SelectSubset<T, CommunityMiningResultUpsertArgs<ExtArgs>>): Prisma__CommunityMiningResultClient<$Result.GetResult<Prisma.$CommunityMiningResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CommunityMiningResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityMiningResultCountArgs} args - Arguments to filter CommunityMiningResults to count.
     * @example
     * // Count the number of CommunityMiningResults
     * const count = await prisma.communityMiningResult.count({
     *   where: {
     *     // ... the filter for the CommunityMiningResults we want to count
     *   }
     * })
    **/
    count<T extends CommunityMiningResultCountArgs>(
      args?: Subset<T, CommunityMiningResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityMiningResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityMiningResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityMiningResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityMiningResultAggregateArgs>(args: Subset<T, CommunityMiningResultAggregateArgs>): Prisma.PrismaPromise<GetCommunityMiningResultAggregateType<T>>

    /**
     * Group by CommunityMiningResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityMiningResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityMiningResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityMiningResultGroupByArgs['orderBy'] }
        : { orderBy?: CommunityMiningResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityMiningResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityMiningResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommunityMiningResult model
   */
  readonly fields: CommunityMiningResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityMiningResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityMiningResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domain<T extends CommunityMiningResult$domainArgs<ExtArgs> = {}>(args?: Subset<T, CommunityMiningResult$domainArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    keyword<T extends CommunityMiningResult$keywordArgs<ExtArgs> = {}>(args?: Subset<T, CommunityMiningResult$keywordArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommunityMiningResult model
   */
  interface CommunityMiningResultFieldRefs {
    readonly id: FieldRef<"CommunityMiningResult", 'Int'>
    readonly domainId: FieldRef<"CommunityMiningResult", 'Int'>
    readonly keywordId: FieldRef<"CommunityMiningResult", 'Int'>
    readonly platform: FieldRef<"CommunityMiningResult", 'String'>
    readonly insights: FieldRef<"CommunityMiningResult", 'Json'>
    readonly sentiment: FieldRef<"CommunityMiningResult", 'String'>
    readonly frequency: FieldRef<"CommunityMiningResult", 'Int'>
    readonly tokenUsage: FieldRef<"CommunityMiningResult", 'Int'>
    readonly createdAt: FieldRef<"CommunityMiningResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommunityMiningResult findUnique
   */
  export type CommunityMiningResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMiningResult
     */
    select?: CommunityMiningResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMiningResult
     */
    omit?: CommunityMiningResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMiningResultInclude<ExtArgs> | null
    /**
     * Filter, which CommunityMiningResult to fetch.
     */
    where: CommunityMiningResultWhereUniqueInput
  }

  /**
   * CommunityMiningResult findUniqueOrThrow
   */
  export type CommunityMiningResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMiningResult
     */
    select?: CommunityMiningResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMiningResult
     */
    omit?: CommunityMiningResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMiningResultInclude<ExtArgs> | null
    /**
     * Filter, which CommunityMiningResult to fetch.
     */
    where: CommunityMiningResultWhereUniqueInput
  }

  /**
   * CommunityMiningResult findFirst
   */
  export type CommunityMiningResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMiningResult
     */
    select?: CommunityMiningResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMiningResult
     */
    omit?: CommunityMiningResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMiningResultInclude<ExtArgs> | null
    /**
     * Filter, which CommunityMiningResult to fetch.
     */
    where?: CommunityMiningResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityMiningResults to fetch.
     */
    orderBy?: CommunityMiningResultOrderByWithRelationInput | CommunityMiningResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityMiningResults.
     */
    cursor?: CommunityMiningResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityMiningResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityMiningResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityMiningResults.
     */
    distinct?: CommunityMiningResultScalarFieldEnum | CommunityMiningResultScalarFieldEnum[]
  }

  /**
   * CommunityMiningResult findFirstOrThrow
   */
  export type CommunityMiningResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMiningResult
     */
    select?: CommunityMiningResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMiningResult
     */
    omit?: CommunityMiningResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMiningResultInclude<ExtArgs> | null
    /**
     * Filter, which CommunityMiningResult to fetch.
     */
    where?: CommunityMiningResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityMiningResults to fetch.
     */
    orderBy?: CommunityMiningResultOrderByWithRelationInput | CommunityMiningResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityMiningResults.
     */
    cursor?: CommunityMiningResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityMiningResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityMiningResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityMiningResults.
     */
    distinct?: CommunityMiningResultScalarFieldEnum | CommunityMiningResultScalarFieldEnum[]
  }

  /**
   * CommunityMiningResult findMany
   */
  export type CommunityMiningResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMiningResult
     */
    select?: CommunityMiningResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMiningResult
     */
    omit?: CommunityMiningResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMiningResultInclude<ExtArgs> | null
    /**
     * Filter, which CommunityMiningResults to fetch.
     */
    where?: CommunityMiningResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityMiningResults to fetch.
     */
    orderBy?: CommunityMiningResultOrderByWithRelationInput | CommunityMiningResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityMiningResults.
     */
    cursor?: CommunityMiningResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityMiningResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityMiningResults.
     */
    skip?: number
    distinct?: CommunityMiningResultScalarFieldEnum | CommunityMiningResultScalarFieldEnum[]
  }

  /**
   * CommunityMiningResult create
   */
  export type CommunityMiningResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMiningResult
     */
    select?: CommunityMiningResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMiningResult
     */
    omit?: CommunityMiningResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMiningResultInclude<ExtArgs> | null
    /**
     * The data needed to create a CommunityMiningResult.
     */
    data: XOR<CommunityMiningResultCreateInput, CommunityMiningResultUncheckedCreateInput>
  }

  /**
   * CommunityMiningResult createMany
   */
  export type CommunityMiningResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommunityMiningResults.
     */
    data: CommunityMiningResultCreateManyInput | CommunityMiningResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommunityMiningResult createManyAndReturn
   */
  export type CommunityMiningResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMiningResult
     */
    select?: CommunityMiningResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMiningResult
     */
    omit?: CommunityMiningResultOmit<ExtArgs> | null
    /**
     * The data used to create many CommunityMiningResults.
     */
    data: CommunityMiningResultCreateManyInput | CommunityMiningResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMiningResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommunityMiningResult update
   */
  export type CommunityMiningResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMiningResult
     */
    select?: CommunityMiningResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMiningResult
     */
    omit?: CommunityMiningResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMiningResultInclude<ExtArgs> | null
    /**
     * The data needed to update a CommunityMiningResult.
     */
    data: XOR<CommunityMiningResultUpdateInput, CommunityMiningResultUncheckedUpdateInput>
    /**
     * Choose, which CommunityMiningResult to update.
     */
    where: CommunityMiningResultWhereUniqueInput
  }

  /**
   * CommunityMiningResult updateMany
   */
  export type CommunityMiningResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommunityMiningResults.
     */
    data: XOR<CommunityMiningResultUpdateManyMutationInput, CommunityMiningResultUncheckedUpdateManyInput>
    /**
     * Filter which CommunityMiningResults to update
     */
    where?: CommunityMiningResultWhereInput
  }

  /**
   * CommunityMiningResult upsert
   */
  export type CommunityMiningResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMiningResult
     */
    select?: CommunityMiningResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMiningResult
     */
    omit?: CommunityMiningResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMiningResultInclude<ExtArgs> | null
    /**
     * The filter to search for the CommunityMiningResult to update in case it exists.
     */
    where: CommunityMiningResultWhereUniqueInput
    /**
     * In case the CommunityMiningResult found by the `where` argument doesn't exist, create a new CommunityMiningResult with this data.
     */
    create: XOR<CommunityMiningResultCreateInput, CommunityMiningResultUncheckedCreateInput>
    /**
     * In case the CommunityMiningResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityMiningResultUpdateInput, CommunityMiningResultUncheckedUpdateInput>
  }

  /**
   * CommunityMiningResult delete
   */
  export type CommunityMiningResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMiningResult
     */
    select?: CommunityMiningResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMiningResult
     */
    omit?: CommunityMiningResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMiningResultInclude<ExtArgs> | null
    /**
     * Filter which CommunityMiningResult to delete.
     */
    where: CommunityMiningResultWhereUniqueInput
  }

  /**
   * CommunityMiningResult deleteMany
   */
  export type CommunityMiningResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityMiningResults to delete
     */
    where?: CommunityMiningResultWhereInput
  }

  /**
   * CommunityMiningResult.domain
   */
  export type CommunityMiningResult$domainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    where?: DomainWhereInput
  }

  /**
   * CommunityMiningResult.keyword
   */
  export type CommunityMiningResult$keywordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    where?: KeywordWhereInput
  }

  /**
   * CommunityMiningResult without action
   */
  export type CommunityMiningResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMiningResult
     */
    select?: CommunityMiningResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMiningResult
     */
    omit?: CommunityMiningResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMiningResultInclude<ExtArgs> | null
  }


  /**
   * Model SearchPatternResult
   */

  export type AggregateSearchPatternResult = {
    _count: SearchPatternResultCountAggregateOutputType | null
    _avg: SearchPatternResultAvgAggregateOutputType | null
    _sum: SearchPatternResultSumAggregateOutputType | null
    _min: SearchPatternResultMinAggregateOutputType | null
    _max: SearchPatternResultMaxAggregateOutputType | null
  }

  export type SearchPatternResultAvgAggregateOutputType = {
    id: number | null
    domainId: number | null
    keywordId: number | null
    volume: number | null
    tokenUsage: number | null
  }

  export type SearchPatternResultSumAggregateOutputType = {
    id: number | null
    domainId: number | null
    keywordId: number | null
    volume: number | null
    tokenUsage: number | null
  }

  export type SearchPatternResultMinAggregateOutputType = {
    id: number | null
    domainId: number | null
    keywordId: number | null
    volume: number | null
    tokenUsage: number | null
    createdAt: Date | null
  }

  export type SearchPatternResultMaxAggregateOutputType = {
    id: number | null
    domainId: number | null
    keywordId: number | null
    volume: number | null
    tokenUsage: number | null
    createdAt: Date | null
  }

  export type SearchPatternResultCountAggregateOutputType = {
    id: number
    domainId: number
    keywordId: number
    patterns: number
    volume: number
    seasonality: number
    trends: number
    tokenUsage: number
    createdAt: number
    _all: number
  }


  export type SearchPatternResultAvgAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    volume?: true
    tokenUsage?: true
  }

  export type SearchPatternResultSumAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    volume?: true
    tokenUsage?: true
  }

  export type SearchPatternResultMinAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    volume?: true
    tokenUsage?: true
    createdAt?: true
  }

  export type SearchPatternResultMaxAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    volume?: true
    tokenUsage?: true
    createdAt?: true
  }

  export type SearchPatternResultCountAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    patterns?: true
    volume?: true
    seasonality?: true
    trends?: true
    tokenUsage?: true
    createdAt?: true
    _all?: true
  }

  export type SearchPatternResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchPatternResult to aggregate.
     */
    where?: SearchPatternResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchPatternResults to fetch.
     */
    orderBy?: SearchPatternResultOrderByWithRelationInput | SearchPatternResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SearchPatternResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchPatternResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchPatternResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SearchPatternResults
    **/
    _count?: true | SearchPatternResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SearchPatternResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SearchPatternResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SearchPatternResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SearchPatternResultMaxAggregateInputType
  }

  export type GetSearchPatternResultAggregateType<T extends SearchPatternResultAggregateArgs> = {
        [P in keyof T & keyof AggregateSearchPatternResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSearchPatternResult[P]>
      : GetScalarType<T[P], AggregateSearchPatternResult[P]>
  }




  export type SearchPatternResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchPatternResultWhereInput
    orderBy?: SearchPatternResultOrderByWithAggregationInput | SearchPatternResultOrderByWithAggregationInput[]
    by: SearchPatternResultScalarFieldEnum[] | SearchPatternResultScalarFieldEnum
    having?: SearchPatternResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SearchPatternResultCountAggregateInputType | true
    _avg?: SearchPatternResultAvgAggregateInputType
    _sum?: SearchPatternResultSumAggregateInputType
    _min?: SearchPatternResultMinAggregateInputType
    _max?: SearchPatternResultMaxAggregateInputType
  }

  export type SearchPatternResultGroupByOutputType = {
    id: number
    domainId: number
    keywordId: number | null
    patterns: JsonValue
    volume: number | null
    seasonality: JsonValue | null
    trends: JsonValue | null
    tokenUsage: number | null
    createdAt: Date
    _count: SearchPatternResultCountAggregateOutputType | null
    _avg: SearchPatternResultAvgAggregateOutputType | null
    _sum: SearchPatternResultSumAggregateOutputType | null
    _min: SearchPatternResultMinAggregateOutputType | null
    _max: SearchPatternResultMaxAggregateOutputType | null
  }

  type GetSearchPatternResultGroupByPayload<T extends SearchPatternResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SearchPatternResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SearchPatternResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SearchPatternResultGroupByOutputType[P]>
            : GetScalarType<T[P], SearchPatternResultGroupByOutputType[P]>
        }
      >
    >


  export type SearchPatternResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    keywordId?: boolean
    patterns?: boolean
    volume?: boolean
    seasonality?: boolean
    trends?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    domain?: boolean | SearchPatternResult$domainArgs<ExtArgs>
    keyword?: boolean | SearchPatternResult$keywordArgs<ExtArgs>
  }, ExtArgs["result"]["searchPatternResult"]>

  export type SearchPatternResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    keywordId?: boolean
    patterns?: boolean
    volume?: boolean
    seasonality?: boolean
    trends?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    domain?: boolean | SearchPatternResult$domainArgs<ExtArgs>
    keyword?: boolean | SearchPatternResult$keywordArgs<ExtArgs>
  }, ExtArgs["result"]["searchPatternResult"]>


  export type SearchPatternResultSelectScalar = {
    id?: boolean
    domainId?: boolean
    keywordId?: boolean
    patterns?: boolean
    volume?: boolean
    seasonality?: boolean
    trends?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
  }

  export type SearchPatternResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "domainId" | "keywordId" | "patterns" | "volume" | "seasonality" | "trends" | "tokenUsage" | "createdAt", ExtArgs["result"]["searchPatternResult"]>
  export type SearchPatternResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | SearchPatternResult$domainArgs<ExtArgs>
    keyword?: boolean | SearchPatternResult$keywordArgs<ExtArgs>
  }
  export type SearchPatternResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | SearchPatternResult$domainArgs<ExtArgs>
    keyword?: boolean | SearchPatternResult$keywordArgs<ExtArgs>
  }

  export type $SearchPatternResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SearchPatternResult"
    objects: {
      domain: Prisma.$DomainPayload<ExtArgs> | null
      keyword: Prisma.$KeywordPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      domainId: number
      keywordId: number | null
      patterns: Prisma.JsonValue
      volume: number | null
      seasonality: Prisma.JsonValue | null
      trends: Prisma.JsonValue | null
      tokenUsage: number | null
      createdAt: Date
    }, ExtArgs["result"]["searchPatternResult"]>
    composites: {}
  }

  type SearchPatternResultGetPayload<S extends boolean | null | undefined | SearchPatternResultDefaultArgs> = $Result.GetResult<Prisma.$SearchPatternResultPayload, S>

  type SearchPatternResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SearchPatternResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SearchPatternResultCountAggregateInputType | true
    }

  export interface SearchPatternResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SearchPatternResult'], meta: { name: 'SearchPatternResult' } }
    /**
     * Find zero or one SearchPatternResult that matches the filter.
     * @param {SearchPatternResultFindUniqueArgs} args - Arguments to find a SearchPatternResult
     * @example
     * // Get one SearchPatternResult
     * const searchPatternResult = await prisma.searchPatternResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SearchPatternResultFindUniqueArgs>(args: SelectSubset<T, SearchPatternResultFindUniqueArgs<ExtArgs>>): Prisma__SearchPatternResultClient<$Result.GetResult<Prisma.$SearchPatternResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SearchPatternResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SearchPatternResultFindUniqueOrThrowArgs} args - Arguments to find a SearchPatternResult
     * @example
     * // Get one SearchPatternResult
     * const searchPatternResult = await prisma.searchPatternResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SearchPatternResultFindUniqueOrThrowArgs>(args: SelectSubset<T, SearchPatternResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SearchPatternResultClient<$Result.GetResult<Prisma.$SearchPatternResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchPatternResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchPatternResultFindFirstArgs} args - Arguments to find a SearchPatternResult
     * @example
     * // Get one SearchPatternResult
     * const searchPatternResult = await prisma.searchPatternResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SearchPatternResultFindFirstArgs>(args?: SelectSubset<T, SearchPatternResultFindFirstArgs<ExtArgs>>): Prisma__SearchPatternResultClient<$Result.GetResult<Prisma.$SearchPatternResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchPatternResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchPatternResultFindFirstOrThrowArgs} args - Arguments to find a SearchPatternResult
     * @example
     * // Get one SearchPatternResult
     * const searchPatternResult = await prisma.searchPatternResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SearchPatternResultFindFirstOrThrowArgs>(args?: SelectSubset<T, SearchPatternResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__SearchPatternResultClient<$Result.GetResult<Prisma.$SearchPatternResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SearchPatternResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchPatternResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SearchPatternResults
     * const searchPatternResults = await prisma.searchPatternResult.findMany()
     * 
     * // Get first 10 SearchPatternResults
     * const searchPatternResults = await prisma.searchPatternResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const searchPatternResultWithIdOnly = await prisma.searchPatternResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SearchPatternResultFindManyArgs>(args?: SelectSubset<T, SearchPatternResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchPatternResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SearchPatternResult.
     * @param {SearchPatternResultCreateArgs} args - Arguments to create a SearchPatternResult.
     * @example
     * // Create one SearchPatternResult
     * const SearchPatternResult = await prisma.searchPatternResult.create({
     *   data: {
     *     // ... data to create a SearchPatternResult
     *   }
     * })
     * 
     */
    create<T extends SearchPatternResultCreateArgs>(args: SelectSubset<T, SearchPatternResultCreateArgs<ExtArgs>>): Prisma__SearchPatternResultClient<$Result.GetResult<Prisma.$SearchPatternResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SearchPatternResults.
     * @param {SearchPatternResultCreateManyArgs} args - Arguments to create many SearchPatternResults.
     * @example
     * // Create many SearchPatternResults
     * const searchPatternResult = await prisma.searchPatternResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SearchPatternResultCreateManyArgs>(args?: SelectSubset<T, SearchPatternResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SearchPatternResults and returns the data saved in the database.
     * @param {SearchPatternResultCreateManyAndReturnArgs} args - Arguments to create many SearchPatternResults.
     * @example
     * // Create many SearchPatternResults
     * const searchPatternResult = await prisma.searchPatternResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SearchPatternResults and only return the `id`
     * const searchPatternResultWithIdOnly = await prisma.searchPatternResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SearchPatternResultCreateManyAndReturnArgs>(args?: SelectSubset<T, SearchPatternResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchPatternResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SearchPatternResult.
     * @param {SearchPatternResultDeleteArgs} args - Arguments to delete one SearchPatternResult.
     * @example
     * // Delete one SearchPatternResult
     * const SearchPatternResult = await prisma.searchPatternResult.delete({
     *   where: {
     *     // ... filter to delete one SearchPatternResult
     *   }
     * })
     * 
     */
    delete<T extends SearchPatternResultDeleteArgs>(args: SelectSubset<T, SearchPatternResultDeleteArgs<ExtArgs>>): Prisma__SearchPatternResultClient<$Result.GetResult<Prisma.$SearchPatternResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SearchPatternResult.
     * @param {SearchPatternResultUpdateArgs} args - Arguments to update one SearchPatternResult.
     * @example
     * // Update one SearchPatternResult
     * const searchPatternResult = await prisma.searchPatternResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SearchPatternResultUpdateArgs>(args: SelectSubset<T, SearchPatternResultUpdateArgs<ExtArgs>>): Prisma__SearchPatternResultClient<$Result.GetResult<Prisma.$SearchPatternResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SearchPatternResults.
     * @param {SearchPatternResultDeleteManyArgs} args - Arguments to filter SearchPatternResults to delete.
     * @example
     * // Delete a few SearchPatternResults
     * const { count } = await prisma.searchPatternResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SearchPatternResultDeleteManyArgs>(args?: SelectSubset<T, SearchPatternResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchPatternResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchPatternResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SearchPatternResults
     * const searchPatternResult = await prisma.searchPatternResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SearchPatternResultUpdateManyArgs>(args: SelectSubset<T, SearchPatternResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SearchPatternResult.
     * @param {SearchPatternResultUpsertArgs} args - Arguments to update or create a SearchPatternResult.
     * @example
     * // Update or create a SearchPatternResult
     * const searchPatternResult = await prisma.searchPatternResult.upsert({
     *   create: {
     *     // ... data to create a SearchPatternResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SearchPatternResult we want to update
     *   }
     * })
     */
    upsert<T extends SearchPatternResultUpsertArgs>(args: SelectSubset<T, SearchPatternResultUpsertArgs<ExtArgs>>): Prisma__SearchPatternResultClient<$Result.GetResult<Prisma.$SearchPatternResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SearchPatternResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchPatternResultCountArgs} args - Arguments to filter SearchPatternResults to count.
     * @example
     * // Count the number of SearchPatternResults
     * const count = await prisma.searchPatternResult.count({
     *   where: {
     *     // ... the filter for the SearchPatternResults we want to count
     *   }
     * })
    **/
    count<T extends SearchPatternResultCountArgs>(
      args?: Subset<T, SearchPatternResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SearchPatternResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SearchPatternResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchPatternResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SearchPatternResultAggregateArgs>(args: Subset<T, SearchPatternResultAggregateArgs>): Prisma.PrismaPromise<GetSearchPatternResultAggregateType<T>>

    /**
     * Group by SearchPatternResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchPatternResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SearchPatternResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SearchPatternResultGroupByArgs['orderBy'] }
        : { orderBy?: SearchPatternResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SearchPatternResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSearchPatternResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SearchPatternResult model
   */
  readonly fields: SearchPatternResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SearchPatternResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SearchPatternResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domain<T extends SearchPatternResult$domainArgs<ExtArgs> = {}>(args?: Subset<T, SearchPatternResult$domainArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    keyword<T extends SearchPatternResult$keywordArgs<ExtArgs> = {}>(args?: Subset<T, SearchPatternResult$keywordArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SearchPatternResult model
   */
  interface SearchPatternResultFieldRefs {
    readonly id: FieldRef<"SearchPatternResult", 'Int'>
    readonly domainId: FieldRef<"SearchPatternResult", 'Int'>
    readonly keywordId: FieldRef<"SearchPatternResult", 'Int'>
    readonly patterns: FieldRef<"SearchPatternResult", 'Json'>
    readonly volume: FieldRef<"SearchPatternResult", 'Int'>
    readonly seasonality: FieldRef<"SearchPatternResult", 'Json'>
    readonly trends: FieldRef<"SearchPatternResult", 'Json'>
    readonly tokenUsage: FieldRef<"SearchPatternResult", 'Int'>
    readonly createdAt: FieldRef<"SearchPatternResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SearchPatternResult findUnique
   */
  export type SearchPatternResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPatternResult
     */
    select?: SearchPatternResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPatternResult
     */
    omit?: SearchPatternResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternResultInclude<ExtArgs> | null
    /**
     * Filter, which SearchPatternResult to fetch.
     */
    where: SearchPatternResultWhereUniqueInput
  }

  /**
   * SearchPatternResult findUniqueOrThrow
   */
  export type SearchPatternResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPatternResult
     */
    select?: SearchPatternResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPatternResult
     */
    omit?: SearchPatternResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternResultInclude<ExtArgs> | null
    /**
     * Filter, which SearchPatternResult to fetch.
     */
    where: SearchPatternResultWhereUniqueInput
  }

  /**
   * SearchPatternResult findFirst
   */
  export type SearchPatternResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPatternResult
     */
    select?: SearchPatternResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPatternResult
     */
    omit?: SearchPatternResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternResultInclude<ExtArgs> | null
    /**
     * Filter, which SearchPatternResult to fetch.
     */
    where?: SearchPatternResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchPatternResults to fetch.
     */
    orderBy?: SearchPatternResultOrderByWithRelationInput | SearchPatternResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchPatternResults.
     */
    cursor?: SearchPatternResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchPatternResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchPatternResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchPatternResults.
     */
    distinct?: SearchPatternResultScalarFieldEnum | SearchPatternResultScalarFieldEnum[]
  }

  /**
   * SearchPatternResult findFirstOrThrow
   */
  export type SearchPatternResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPatternResult
     */
    select?: SearchPatternResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPatternResult
     */
    omit?: SearchPatternResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternResultInclude<ExtArgs> | null
    /**
     * Filter, which SearchPatternResult to fetch.
     */
    where?: SearchPatternResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchPatternResults to fetch.
     */
    orderBy?: SearchPatternResultOrderByWithRelationInput | SearchPatternResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchPatternResults.
     */
    cursor?: SearchPatternResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchPatternResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchPatternResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchPatternResults.
     */
    distinct?: SearchPatternResultScalarFieldEnum | SearchPatternResultScalarFieldEnum[]
  }

  /**
   * SearchPatternResult findMany
   */
  export type SearchPatternResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPatternResult
     */
    select?: SearchPatternResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPatternResult
     */
    omit?: SearchPatternResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternResultInclude<ExtArgs> | null
    /**
     * Filter, which SearchPatternResults to fetch.
     */
    where?: SearchPatternResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchPatternResults to fetch.
     */
    orderBy?: SearchPatternResultOrderByWithRelationInput | SearchPatternResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SearchPatternResults.
     */
    cursor?: SearchPatternResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchPatternResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchPatternResults.
     */
    skip?: number
    distinct?: SearchPatternResultScalarFieldEnum | SearchPatternResultScalarFieldEnum[]
  }

  /**
   * SearchPatternResult create
   */
  export type SearchPatternResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPatternResult
     */
    select?: SearchPatternResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPatternResult
     */
    omit?: SearchPatternResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternResultInclude<ExtArgs> | null
    /**
     * The data needed to create a SearchPatternResult.
     */
    data: XOR<SearchPatternResultCreateInput, SearchPatternResultUncheckedCreateInput>
  }

  /**
   * SearchPatternResult createMany
   */
  export type SearchPatternResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SearchPatternResults.
     */
    data: SearchPatternResultCreateManyInput | SearchPatternResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SearchPatternResult createManyAndReturn
   */
  export type SearchPatternResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPatternResult
     */
    select?: SearchPatternResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPatternResult
     */
    omit?: SearchPatternResultOmit<ExtArgs> | null
    /**
     * The data used to create many SearchPatternResults.
     */
    data: SearchPatternResultCreateManyInput | SearchPatternResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SearchPatternResult update
   */
  export type SearchPatternResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPatternResult
     */
    select?: SearchPatternResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPatternResult
     */
    omit?: SearchPatternResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternResultInclude<ExtArgs> | null
    /**
     * The data needed to update a SearchPatternResult.
     */
    data: XOR<SearchPatternResultUpdateInput, SearchPatternResultUncheckedUpdateInput>
    /**
     * Choose, which SearchPatternResult to update.
     */
    where: SearchPatternResultWhereUniqueInput
  }

  /**
   * SearchPatternResult updateMany
   */
  export type SearchPatternResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SearchPatternResults.
     */
    data: XOR<SearchPatternResultUpdateManyMutationInput, SearchPatternResultUncheckedUpdateManyInput>
    /**
     * Filter which SearchPatternResults to update
     */
    where?: SearchPatternResultWhereInput
  }

  /**
   * SearchPatternResult upsert
   */
  export type SearchPatternResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPatternResult
     */
    select?: SearchPatternResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPatternResult
     */
    omit?: SearchPatternResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternResultInclude<ExtArgs> | null
    /**
     * The filter to search for the SearchPatternResult to update in case it exists.
     */
    where: SearchPatternResultWhereUniqueInput
    /**
     * In case the SearchPatternResult found by the `where` argument doesn't exist, create a new SearchPatternResult with this data.
     */
    create: XOR<SearchPatternResultCreateInput, SearchPatternResultUncheckedCreateInput>
    /**
     * In case the SearchPatternResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SearchPatternResultUpdateInput, SearchPatternResultUncheckedUpdateInput>
  }

  /**
   * SearchPatternResult delete
   */
  export type SearchPatternResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPatternResult
     */
    select?: SearchPatternResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPatternResult
     */
    omit?: SearchPatternResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternResultInclude<ExtArgs> | null
    /**
     * Filter which SearchPatternResult to delete.
     */
    where: SearchPatternResultWhereUniqueInput
  }

  /**
   * SearchPatternResult deleteMany
   */
  export type SearchPatternResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchPatternResults to delete
     */
    where?: SearchPatternResultWhereInput
  }

  /**
   * SearchPatternResult.domain
   */
  export type SearchPatternResult$domainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    where?: DomainWhereInput
  }

  /**
   * SearchPatternResult.keyword
   */
  export type SearchPatternResult$keywordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    where?: KeywordWhereInput
  }

  /**
   * SearchPatternResult without action
   */
  export type SearchPatternResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchPatternResult
     */
    select?: SearchPatternResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchPatternResult
     */
    omit?: SearchPatternResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchPatternResultInclude<ExtArgs> | null
  }


  /**
   * Model IntentClassificationResult
   */

  export type AggregateIntentClassificationResult = {
    _count: IntentClassificationResultCountAggregateOutputType | null
    _avg: IntentClassificationResultAvgAggregateOutputType | null
    _sum: IntentClassificationResultSumAggregateOutputType | null
    _min: IntentClassificationResultMinAggregateOutputType | null
    _max: IntentClassificationResultMaxAggregateOutputType | null
  }

  export type IntentClassificationResultAvgAggregateOutputType = {
    id: number | null
    domainId: number | null
    keywordId: number | null
    confidence: number | null
    tokenUsage: number | null
  }

  export type IntentClassificationResultSumAggregateOutputType = {
    id: number | null
    domainId: number | null
    keywordId: number | null
    confidence: number | null
    tokenUsage: number | null
  }

  export type IntentClassificationResultMinAggregateOutputType = {
    id: number | null
    domainId: number | null
    keywordId: number | null
    intent: string | null
    confidence: number | null
    tokenUsage: number | null
    createdAt: Date | null
  }

  export type IntentClassificationResultMaxAggregateOutputType = {
    id: number | null
    domainId: number | null
    keywordId: number | null
    intent: string | null
    confidence: number | null
    tokenUsage: number | null
    createdAt: Date | null
  }

  export type IntentClassificationResultCountAggregateOutputType = {
    id: number
    domainId: number
    keywordId: number
    intent: number
    confidence: number
    patterns: number
    tokenUsage: number
    createdAt: number
    _all: number
  }


  export type IntentClassificationResultAvgAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    confidence?: true
    tokenUsage?: true
  }

  export type IntentClassificationResultSumAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    confidence?: true
    tokenUsage?: true
  }

  export type IntentClassificationResultMinAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    intent?: true
    confidence?: true
    tokenUsage?: true
    createdAt?: true
  }

  export type IntentClassificationResultMaxAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    intent?: true
    confidence?: true
    tokenUsage?: true
    createdAt?: true
  }

  export type IntentClassificationResultCountAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    intent?: true
    confidence?: true
    patterns?: true
    tokenUsage?: true
    createdAt?: true
    _all?: true
  }

  export type IntentClassificationResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntentClassificationResult to aggregate.
     */
    where?: IntentClassificationResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntentClassificationResults to fetch.
     */
    orderBy?: IntentClassificationResultOrderByWithRelationInput | IntentClassificationResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntentClassificationResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntentClassificationResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntentClassificationResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntentClassificationResults
    **/
    _count?: true | IntentClassificationResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntentClassificationResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntentClassificationResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntentClassificationResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntentClassificationResultMaxAggregateInputType
  }

  export type GetIntentClassificationResultAggregateType<T extends IntentClassificationResultAggregateArgs> = {
        [P in keyof T & keyof AggregateIntentClassificationResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntentClassificationResult[P]>
      : GetScalarType<T[P], AggregateIntentClassificationResult[P]>
  }




  export type IntentClassificationResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntentClassificationResultWhereInput
    orderBy?: IntentClassificationResultOrderByWithAggregationInput | IntentClassificationResultOrderByWithAggregationInput[]
    by: IntentClassificationResultScalarFieldEnum[] | IntentClassificationResultScalarFieldEnum
    having?: IntentClassificationResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntentClassificationResultCountAggregateInputType | true
    _avg?: IntentClassificationResultAvgAggregateInputType
    _sum?: IntentClassificationResultSumAggregateInputType
    _min?: IntentClassificationResultMinAggregateInputType
    _max?: IntentClassificationResultMaxAggregateInputType
  }

  export type IntentClassificationResultGroupByOutputType = {
    id: number
    domainId: number
    keywordId: number | null
    intent: string
    confidence: number | null
    patterns: JsonValue | null
    tokenUsage: number | null
    createdAt: Date
    _count: IntentClassificationResultCountAggregateOutputType | null
    _avg: IntentClassificationResultAvgAggregateOutputType | null
    _sum: IntentClassificationResultSumAggregateOutputType | null
    _min: IntentClassificationResultMinAggregateOutputType | null
    _max: IntentClassificationResultMaxAggregateOutputType | null
  }

  type GetIntentClassificationResultGroupByPayload<T extends IntentClassificationResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntentClassificationResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntentClassificationResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntentClassificationResultGroupByOutputType[P]>
            : GetScalarType<T[P], IntentClassificationResultGroupByOutputType[P]>
        }
      >
    >


  export type IntentClassificationResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    keywordId?: boolean
    intent?: boolean
    confidence?: boolean
    patterns?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    domain?: boolean | IntentClassificationResult$domainArgs<ExtArgs>
    keyword?: boolean | IntentClassificationResult$keywordArgs<ExtArgs>
  }, ExtArgs["result"]["intentClassificationResult"]>

  export type IntentClassificationResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    keywordId?: boolean
    intent?: boolean
    confidence?: boolean
    patterns?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    domain?: boolean | IntentClassificationResult$domainArgs<ExtArgs>
    keyword?: boolean | IntentClassificationResult$keywordArgs<ExtArgs>
  }, ExtArgs["result"]["intentClassificationResult"]>


  export type IntentClassificationResultSelectScalar = {
    id?: boolean
    domainId?: boolean
    keywordId?: boolean
    intent?: boolean
    confidence?: boolean
    patterns?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
  }

  export type IntentClassificationResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "domainId" | "keywordId" | "intent" | "confidence" | "patterns" | "tokenUsage" | "createdAt", ExtArgs["result"]["intentClassificationResult"]>
  export type IntentClassificationResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | IntentClassificationResult$domainArgs<ExtArgs>
    keyword?: boolean | IntentClassificationResult$keywordArgs<ExtArgs>
  }
  export type IntentClassificationResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | IntentClassificationResult$domainArgs<ExtArgs>
    keyword?: boolean | IntentClassificationResult$keywordArgs<ExtArgs>
  }

  export type $IntentClassificationResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IntentClassificationResult"
    objects: {
      domain: Prisma.$DomainPayload<ExtArgs> | null
      keyword: Prisma.$KeywordPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      domainId: number
      keywordId: number | null
      intent: string
      confidence: number | null
      patterns: Prisma.JsonValue | null
      tokenUsage: number | null
      createdAt: Date
    }, ExtArgs["result"]["intentClassificationResult"]>
    composites: {}
  }

  type IntentClassificationResultGetPayload<S extends boolean | null | undefined | IntentClassificationResultDefaultArgs> = $Result.GetResult<Prisma.$IntentClassificationResultPayload, S>

  type IntentClassificationResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IntentClassificationResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IntentClassificationResultCountAggregateInputType | true
    }

  export interface IntentClassificationResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IntentClassificationResult'], meta: { name: 'IntentClassificationResult' } }
    /**
     * Find zero or one IntentClassificationResult that matches the filter.
     * @param {IntentClassificationResultFindUniqueArgs} args - Arguments to find a IntentClassificationResult
     * @example
     * // Get one IntentClassificationResult
     * const intentClassificationResult = await prisma.intentClassificationResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntentClassificationResultFindUniqueArgs>(args: SelectSubset<T, IntentClassificationResultFindUniqueArgs<ExtArgs>>): Prisma__IntentClassificationResultClient<$Result.GetResult<Prisma.$IntentClassificationResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IntentClassificationResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IntentClassificationResultFindUniqueOrThrowArgs} args - Arguments to find a IntentClassificationResult
     * @example
     * // Get one IntentClassificationResult
     * const intentClassificationResult = await prisma.intentClassificationResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntentClassificationResultFindUniqueOrThrowArgs>(args: SelectSubset<T, IntentClassificationResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntentClassificationResultClient<$Result.GetResult<Prisma.$IntentClassificationResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IntentClassificationResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentClassificationResultFindFirstArgs} args - Arguments to find a IntentClassificationResult
     * @example
     * // Get one IntentClassificationResult
     * const intentClassificationResult = await prisma.intentClassificationResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntentClassificationResultFindFirstArgs>(args?: SelectSubset<T, IntentClassificationResultFindFirstArgs<ExtArgs>>): Prisma__IntentClassificationResultClient<$Result.GetResult<Prisma.$IntentClassificationResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IntentClassificationResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentClassificationResultFindFirstOrThrowArgs} args - Arguments to find a IntentClassificationResult
     * @example
     * // Get one IntentClassificationResult
     * const intentClassificationResult = await prisma.intentClassificationResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntentClassificationResultFindFirstOrThrowArgs>(args?: SelectSubset<T, IntentClassificationResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntentClassificationResultClient<$Result.GetResult<Prisma.$IntentClassificationResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IntentClassificationResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentClassificationResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntentClassificationResults
     * const intentClassificationResults = await prisma.intentClassificationResult.findMany()
     * 
     * // Get first 10 IntentClassificationResults
     * const intentClassificationResults = await prisma.intentClassificationResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const intentClassificationResultWithIdOnly = await prisma.intentClassificationResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntentClassificationResultFindManyArgs>(args?: SelectSubset<T, IntentClassificationResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntentClassificationResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IntentClassificationResult.
     * @param {IntentClassificationResultCreateArgs} args - Arguments to create a IntentClassificationResult.
     * @example
     * // Create one IntentClassificationResult
     * const IntentClassificationResult = await prisma.intentClassificationResult.create({
     *   data: {
     *     // ... data to create a IntentClassificationResult
     *   }
     * })
     * 
     */
    create<T extends IntentClassificationResultCreateArgs>(args: SelectSubset<T, IntentClassificationResultCreateArgs<ExtArgs>>): Prisma__IntentClassificationResultClient<$Result.GetResult<Prisma.$IntentClassificationResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IntentClassificationResults.
     * @param {IntentClassificationResultCreateManyArgs} args - Arguments to create many IntentClassificationResults.
     * @example
     * // Create many IntentClassificationResults
     * const intentClassificationResult = await prisma.intentClassificationResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntentClassificationResultCreateManyArgs>(args?: SelectSubset<T, IntentClassificationResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IntentClassificationResults and returns the data saved in the database.
     * @param {IntentClassificationResultCreateManyAndReturnArgs} args - Arguments to create many IntentClassificationResults.
     * @example
     * // Create many IntentClassificationResults
     * const intentClassificationResult = await prisma.intentClassificationResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IntentClassificationResults and only return the `id`
     * const intentClassificationResultWithIdOnly = await prisma.intentClassificationResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntentClassificationResultCreateManyAndReturnArgs>(args?: SelectSubset<T, IntentClassificationResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntentClassificationResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IntentClassificationResult.
     * @param {IntentClassificationResultDeleteArgs} args - Arguments to delete one IntentClassificationResult.
     * @example
     * // Delete one IntentClassificationResult
     * const IntentClassificationResult = await prisma.intentClassificationResult.delete({
     *   where: {
     *     // ... filter to delete one IntentClassificationResult
     *   }
     * })
     * 
     */
    delete<T extends IntentClassificationResultDeleteArgs>(args: SelectSubset<T, IntentClassificationResultDeleteArgs<ExtArgs>>): Prisma__IntentClassificationResultClient<$Result.GetResult<Prisma.$IntentClassificationResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IntentClassificationResult.
     * @param {IntentClassificationResultUpdateArgs} args - Arguments to update one IntentClassificationResult.
     * @example
     * // Update one IntentClassificationResult
     * const intentClassificationResult = await prisma.intentClassificationResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntentClassificationResultUpdateArgs>(args: SelectSubset<T, IntentClassificationResultUpdateArgs<ExtArgs>>): Prisma__IntentClassificationResultClient<$Result.GetResult<Prisma.$IntentClassificationResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IntentClassificationResults.
     * @param {IntentClassificationResultDeleteManyArgs} args - Arguments to filter IntentClassificationResults to delete.
     * @example
     * // Delete a few IntentClassificationResults
     * const { count } = await prisma.intentClassificationResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntentClassificationResultDeleteManyArgs>(args?: SelectSubset<T, IntentClassificationResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntentClassificationResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentClassificationResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntentClassificationResults
     * const intentClassificationResult = await prisma.intentClassificationResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntentClassificationResultUpdateManyArgs>(args: SelectSubset<T, IntentClassificationResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IntentClassificationResult.
     * @param {IntentClassificationResultUpsertArgs} args - Arguments to update or create a IntentClassificationResult.
     * @example
     * // Update or create a IntentClassificationResult
     * const intentClassificationResult = await prisma.intentClassificationResult.upsert({
     *   create: {
     *     // ... data to create a IntentClassificationResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntentClassificationResult we want to update
     *   }
     * })
     */
    upsert<T extends IntentClassificationResultUpsertArgs>(args: SelectSubset<T, IntentClassificationResultUpsertArgs<ExtArgs>>): Prisma__IntentClassificationResultClient<$Result.GetResult<Prisma.$IntentClassificationResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IntentClassificationResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentClassificationResultCountArgs} args - Arguments to filter IntentClassificationResults to count.
     * @example
     * // Count the number of IntentClassificationResults
     * const count = await prisma.intentClassificationResult.count({
     *   where: {
     *     // ... the filter for the IntentClassificationResults we want to count
     *   }
     * })
    **/
    count<T extends IntentClassificationResultCountArgs>(
      args?: Subset<T, IntentClassificationResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntentClassificationResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntentClassificationResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentClassificationResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntentClassificationResultAggregateArgs>(args: Subset<T, IntentClassificationResultAggregateArgs>): Prisma.PrismaPromise<GetIntentClassificationResultAggregateType<T>>

    /**
     * Group by IntentClassificationResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentClassificationResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntentClassificationResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntentClassificationResultGroupByArgs['orderBy'] }
        : { orderBy?: IntentClassificationResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntentClassificationResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntentClassificationResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IntentClassificationResult model
   */
  readonly fields: IntentClassificationResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntentClassificationResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntentClassificationResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domain<T extends IntentClassificationResult$domainArgs<ExtArgs> = {}>(args?: Subset<T, IntentClassificationResult$domainArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    keyword<T extends IntentClassificationResult$keywordArgs<ExtArgs> = {}>(args?: Subset<T, IntentClassificationResult$keywordArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IntentClassificationResult model
   */
  interface IntentClassificationResultFieldRefs {
    readonly id: FieldRef<"IntentClassificationResult", 'Int'>
    readonly domainId: FieldRef<"IntentClassificationResult", 'Int'>
    readonly keywordId: FieldRef<"IntentClassificationResult", 'Int'>
    readonly intent: FieldRef<"IntentClassificationResult", 'String'>
    readonly confidence: FieldRef<"IntentClassificationResult", 'Int'>
    readonly patterns: FieldRef<"IntentClassificationResult", 'Json'>
    readonly tokenUsage: FieldRef<"IntentClassificationResult", 'Int'>
    readonly createdAt: FieldRef<"IntentClassificationResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IntentClassificationResult findUnique
   */
  export type IntentClassificationResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentClassificationResult
     */
    select?: IntentClassificationResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentClassificationResult
     */
    omit?: IntentClassificationResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentClassificationResultInclude<ExtArgs> | null
    /**
     * Filter, which IntentClassificationResult to fetch.
     */
    where: IntentClassificationResultWhereUniqueInput
  }

  /**
   * IntentClassificationResult findUniqueOrThrow
   */
  export type IntentClassificationResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentClassificationResult
     */
    select?: IntentClassificationResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentClassificationResult
     */
    omit?: IntentClassificationResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentClassificationResultInclude<ExtArgs> | null
    /**
     * Filter, which IntentClassificationResult to fetch.
     */
    where: IntentClassificationResultWhereUniqueInput
  }

  /**
   * IntentClassificationResult findFirst
   */
  export type IntentClassificationResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentClassificationResult
     */
    select?: IntentClassificationResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentClassificationResult
     */
    omit?: IntentClassificationResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentClassificationResultInclude<ExtArgs> | null
    /**
     * Filter, which IntentClassificationResult to fetch.
     */
    where?: IntentClassificationResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntentClassificationResults to fetch.
     */
    orderBy?: IntentClassificationResultOrderByWithRelationInput | IntentClassificationResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntentClassificationResults.
     */
    cursor?: IntentClassificationResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntentClassificationResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntentClassificationResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntentClassificationResults.
     */
    distinct?: IntentClassificationResultScalarFieldEnum | IntentClassificationResultScalarFieldEnum[]
  }

  /**
   * IntentClassificationResult findFirstOrThrow
   */
  export type IntentClassificationResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentClassificationResult
     */
    select?: IntentClassificationResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentClassificationResult
     */
    omit?: IntentClassificationResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentClassificationResultInclude<ExtArgs> | null
    /**
     * Filter, which IntentClassificationResult to fetch.
     */
    where?: IntentClassificationResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntentClassificationResults to fetch.
     */
    orderBy?: IntentClassificationResultOrderByWithRelationInput | IntentClassificationResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntentClassificationResults.
     */
    cursor?: IntentClassificationResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntentClassificationResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntentClassificationResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntentClassificationResults.
     */
    distinct?: IntentClassificationResultScalarFieldEnum | IntentClassificationResultScalarFieldEnum[]
  }

  /**
   * IntentClassificationResult findMany
   */
  export type IntentClassificationResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentClassificationResult
     */
    select?: IntentClassificationResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentClassificationResult
     */
    omit?: IntentClassificationResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentClassificationResultInclude<ExtArgs> | null
    /**
     * Filter, which IntentClassificationResults to fetch.
     */
    where?: IntentClassificationResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntentClassificationResults to fetch.
     */
    orderBy?: IntentClassificationResultOrderByWithRelationInput | IntentClassificationResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntentClassificationResults.
     */
    cursor?: IntentClassificationResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntentClassificationResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntentClassificationResults.
     */
    skip?: number
    distinct?: IntentClassificationResultScalarFieldEnum | IntentClassificationResultScalarFieldEnum[]
  }

  /**
   * IntentClassificationResult create
   */
  export type IntentClassificationResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentClassificationResult
     */
    select?: IntentClassificationResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentClassificationResult
     */
    omit?: IntentClassificationResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentClassificationResultInclude<ExtArgs> | null
    /**
     * The data needed to create a IntentClassificationResult.
     */
    data: XOR<IntentClassificationResultCreateInput, IntentClassificationResultUncheckedCreateInput>
  }

  /**
   * IntentClassificationResult createMany
   */
  export type IntentClassificationResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IntentClassificationResults.
     */
    data: IntentClassificationResultCreateManyInput | IntentClassificationResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IntentClassificationResult createManyAndReturn
   */
  export type IntentClassificationResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentClassificationResult
     */
    select?: IntentClassificationResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IntentClassificationResult
     */
    omit?: IntentClassificationResultOmit<ExtArgs> | null
    /**
     * The data used to create many IntentClassificationResults.
     */
    data: IntentClassificationResultCreateManyInput | IntentClassificationResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentClassificationResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IntentClassificationResult update
   */
  export type IntentClassificationResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentClassificationResult
     */
    select?: IntentClassificationResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentClassificationResult
     */
    omit?: IntentClassificationResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentClassificationResultInclude<ExtArgs> | null
    /**
     * The data needed to update a IntentClassificationResult.
     */
    data: XOR<IntentClassificationResultUpdateInput, IntentClassificationResultUncheckedUpdateInput>
    /**
     * Choose, which IntentClassificationResult to update.
     */
    where: IntentClassificationResultWhereUniqueInput
  }

  /**
   * IntentClassificationResult updateMany
   */
  export type IntentClassificationResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IntentClassificationResults.
     */
    data: XOR<IntentClassificationResultUpdateManyMutationInput, IntentClassificationResultUncheckedUpdateManyInput>
    /**
     * Filter which IntentClassificationResults to update
     */
    where?: IntentClassificationResultWhereInput
  }

  /**
   * IntentClassificationResult upsert
   */
  export type IntentClassificationResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentClassificationResult
     */
    select?: IntentClassificationResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentClassificationResult
     */
    omit?: IntentClassificationResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentClassificationResultInclude<ExtArgs> | null
    /**
     * The filter to search for the IntentClassificationResult to update in case it exists.
     */
    where: IntentClassificationResultWhereUniqueInput
    /**
     * In case the IntentClassificationResult found by the `where` argument doesn't exist, create a new IntentClassificationResult with this data.
     */
    create: XOR<IntentClassificationResultCreateInput, IntentClassificationResultUncheckedCreateInput>
    /**
     * In case the IntentClassificationResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntentClassificationResultUpdateInput, IntentClassificationResultUncheckedUpdateInput>
  }

  /**
   * IntentClassificationResult delete
   */
  export type IntentClassificationResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentClassificationResult
     */
    select?: IntentClassificationResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentClassificationResult
     */
    omit?: IntentClassificationResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentClassificationResultInclude<ExtArgs> | null
    /**
     * Filter which IntentClassificationResult to delete.
     */
    where: IntentClassificationResultWhereUniqueInput
  }

  /**
   * IntentClassificationResult deleteMany
   */
  export type IntentClassificationResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntentClassificationResults to delete
     */
    where?: IntentClassificationResultWhereInput
  }

  /**
   * IntentClassificationResult.domain
   */
  export type IntentClassificationResult$domainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    where?: DomainWhereInput
  }

  /**
   * IntentClassificationResult.keyword
   */
  export type IntentClassificationResult$keywordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    where?: KeywordWhereInput
  }

  /**
   * IntentClassificationResult without action
   */
  export type IntentClassificationResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentClassificationResult
     */
    select?: IntentClassificationResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentClassificationResult
     */
    omit?: IntentClassificationResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentClassificationResultInclude<ExtArgs> | null
  }


  /**
   * Model GeneratedIntentPhrase
   */

  export type AggregateGeneratedIntentPhrase = {
    _count: GeneratedIntentPhraseCountAggregateOutputType | null
    _avg: GeneratedIntentPhraseAvgAggregateOutputType | null
    _sum: GeneratedIntentPhraseSumAggregateOutputType | null
    _min: GeneratedIntentPhraseMinAggregateOutputType | null
    _max: GeneratedIntentPhraseMaxAggregateOutputType | null
  }

  export type GeneratedIntentPhraseAvgAggregateOutputType = {
    id: number | null
    domainId: number | null
    keywordId: number | null
    relevanceScore: number | null
    intentConfidence: number | null
    tokenUsage: number | null
  }

  export type GeneratedIntentPhraseSumAggregateOutputType = {
    id: number | null
    domainId: number | null
    keywordId: number | null
    relevanceScore: number | null
    intentConfidence: number | null
    tokenUsage: number | null
  }

  export type GeneratedIntentPhraseMinAggregateOutputType = {
    id: number | null
    domainId: number | null
    keywordId: number | null
    phrase: string | null
    relevanceScore: number | null
    intent: string | null
    intentConfidence: number | null
    trend: string | null
    isSelected: boolean | null
    tokenUsage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GeneratedIntentPhraseMaxAggregateOutputType = {
    id: number | null
    domainId: number | null
    keywordId: number | null
    phrase: string | null
    relevanceScore: number | null
    intent: string | null
    intentConfidence: number | null
    trend: string | null
    isSelected: boolean | null
    tokenUsage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GeneratedIntentPhraseCountAggregateOutputType = {
    id: number
    domainId: number
    keywordId: number
    phrase: number
    relevanceScore: number
    intent: number
    intentConfidence: number
    sources: number
    trend: number
    communityInsights: number
    searchPatterns: number
    isSelected: number
    tokenUsage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GeneratedIntentPhraseAvgAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    relevanceScore?: true
    intentConfidence?: true
    tokenUsage?: true
  }

  export type GeneratedIntentPhraseSumAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    relevanceScore?: true
    intentConfidence?: true
    tokenUsage?: true
  }

  export type GeneratedIntentPhraseMinAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    phrase?: true
    relevanceScore?: true
    intent?: true
    intentConfidence?: true
    trend?: true
    isSelected?: true
    tokenUsage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GeneratedIntentPhraseMaxAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    phrase?: true
    relevanceScore?: true
    intent?: true
    intentConfidence?: true
    trend?: true
    isSelected?: true
    tokenUsage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GeneratedIntentPhraseCountAggregateInputType = {
    id?: true
    domainId?: true
    keywordId?: true
    phrase?: true
    relevanceScore?: true
    intent?: true
    intentConfidence?: true
    sources?: true
    trend?: true
    communityInsights?: true
    searchPatterns?: true
    isSelected?: true
    tokenUsage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GeneratedIntentPhraseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeneratedIntentPhrase to aggregate.
     */
    where?: GeneratedIntentPhraseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedIntentPhrases to fetch.
     */
    orderBy?: GeneratedIntentPhraseOrderByWithRelationInput | GeneratedIntentPhraseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GeneratedIntentPhraseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedIntentPhrases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedIntentPhrases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GeneratedIntentPhrases
    **/
    _count?: true | GeneratedIntentPhraseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GeneratedIntentPhraseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GeneratedIntentPhraseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GeneratedIntentPhraseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GeneratedIntentPhraseMaxAggregateInputType
  }

  export type GetGeneratedIntentPhraseAggregateType<T extends GeneratedIntentPhraseAggregateArgs> = {
        [P in keyof T & keyof AggregateGeneratedIntentPhrase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeneratedIntentPhrase[P]>
      : GetScalarType<T[P], AggregateGeneratedIntentPhrase[P]>
  }




  export type GeneratedIntentPhraseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedIntentPhraseWhereInput
    orderBy?: GeneratedIntentPhraseOrderByWithAggregationInput | GeneratedIntentPhraseOrderByWithAggregationInput[]
    by: GeneratedIntentPhraseScalarFieldEnum[] | GeneratedIntentPhraseScalarFieldEnum
    having?: GeneratedIntentPhraseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GeneratedIntentPhraseCountAggregateInputType | true
    _avg?: GeneratedIntentPhraseAvgAggregateInputType
    _sum?: GeneratedIntentPhraseSumAggregateInputType
    _min?: GeneratedIntentPhraseMinAggregateInputType
    _max?: GeneratedIntentPhraseMaxAggregateInputType
  }

  export type GeneratedIntentPhraseGroupByOutputType = {
    id: number
    domainId: number
    keywordId: number | null
    phrase: string
    relevanceScore: number | null
    intent: string | null
    intentConfidence: number | null
    sources: JsonValue | null
    trend: string | null
    communityInsights: JsonValue | null
    searchPatterns: JsonValue | null
    isSelected: boolean
    tokenUsage: number | null
    createdAt: Date
    updatedAt: Date
    _count: GeneratedIntentPhraseCountAggregateOutputType | null
    _avg: GeneratedIntentPhraseAvgAggregateOutputType | null
    _sum: GeneratedIntentPhraseSumAggregateOutputType | null
    _min: GeneratedIntentPhraseMinAggregateOutputType | null
    _max: GeneratedIntentPhraseMaxAggregateOutputType | null
  }

  type GetGeneratedIntentPhraseGroupByPayload<T extends GeneratedIntentPhraseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GeneratedIntentPhraseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GeneratedIntentPhraseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GeneratedIntentPhraseGroupByOutputType[P]>
            : GetScalarType<T[P], GeneratedIntentPhraseGroupByOutputType[P]>
        }
      >
    >


  export type GeneratedIntentPhraseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    keywordId?: boolean
    phrase?: boolean
    relevanceScore?: boolean
    intent?: boolean
    intentConfidence?: boolean
    sources?: boolean
    trend?: boolean
    communityInsights?: boolean
    searchPatterns?: boolean
    isSelected?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domain?: boolean | GeneratedIntentPhrase$domainArgs<ExtArgs>
    keyword?: boolean | GeneratedIntentPhrase$keywordArgs<ExtArgs>
    relevanceScoreResults?: boolean | GeneratedIntentPhrase$relevanceScoreResultsArgs<ExtArgs>
    aiQueryResults?: boolean | GeneratedIntentPhrase$aiQueryResultsArgs<ExtArgs>
    _count?: boolean | GeneratedIntentPhraseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["generatedIntentPhrase"]>

  export type GeneratedIntentPhraseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    keywordId?: boolean
    phrase?: boolean
    relevanceScore?: boolean
    intent?: boolean
    intentConfidence?: boolean
    sources?: boolean
    trend?: boolean
    communityInsights?: boolean
    searchPatterns?: boolean
    isSelected?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domain?: boolean | GeneratedIntentPhrase$domainArgs<ExtArgs>
    keyword?: boolean | GeneratedIntentPhrase$keywordArgs<ExtArgs>
  }, ExtArgs["result"]["generatedIntentPhrase"]>


  export type GeneratedIntentPhraseSelectScalar = {
    id?: boolean
    domainId?: boolean
    keywordId?: boolean
    phrase?: boolean
    relevanceScore?: boolean
    intent?: boolean
    intentConfidence?: boolean
    sources?: boolean
    trend?: boolean
    communityInsights?: boolean
    searchPatterns?: boolean
    isSelected?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GeneratedIntentPhraseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "domainId" | "keywordId" | "phrase" | "relevanceScore" | "intent" | "intentConfidence" | "sources" | "trend" | "communityInsights" | "searchPatterns" | "isSelected" | "tokenUsage" | "createdAt" | "updatedAt", ExtArgs["result"]["generatedIntentPhrase"]>
  export type GeneratedIntentPhraseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | GeneratedIntentPhrase$domainArgs<ExtArgs>
    keyword?: boolean | GeneratedIntentPhrase$keywordArgs<ExtArgs>
    relevanceScoreResults?: boolean | GeneratedIntentPhrase$relevanceScoreResultsArgs<ExtArgs>
    aiQueryResults?: boolean | GeneratedIntentPhrase$aiQueryResultsArgs<ExtArgs>
    _count?: boolean | GeneratedIntentPhraseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GeneratedIntentPhraseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | GeneratedIntentPhrase$domainArgs<ExtArgs>
    keyword?: boolean | GeneratedIntentPhrase$keywordArgs<ExtArgs>
  }

  export type $GeneratedIntentPhrasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GeneratedIntentPhrase"
    objects: {
      domain: Prisma.$DomainPayload<ExtArgs> | null
      keyword: Prisma.$KeywordPayload<ExtArgs> | null
      relevanceScoreResults: Prisma.$RelevanceScoreResultPayload<ExtArgs>[]
      aiQueryResults: Prisma.$AIQueryResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      domainId: number
      keywordId: number | null
      phrase: string
      relevanceScore: number | null
      intent: string | null
      intentConfidence: number | null
      sources: Prisma.JsonValue | null
      trend: string | null
      communityInsights: Prisma.JsonValue | null
      searchPatterns: Prisma.JsonValue | null
      isSelected: boolean
      tokenUsage: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["generatedIntentPhrase"]>
    composites: {}
  }

  type GeneratedIntentPhraseGetPayload<S extends boolean | null | undefined | GeneratedIntentPhraseDefaultArgs> = $Result.GetResult<Prisma.$GeneratedIntentPhrasePayload, S>

  type GeneratedIntentPhraseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GeneratedIntentPhraseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GeneratedIntentPhraseCountAggregateInputType | true
    }

  export interface GeneratedIntentPhraseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GeneratedIntentPhrase'], meta: { name: 'GeneratedIntentPhrase' } }
    /**
     * Find zero or one GeneratedIntentPhrase that matches the filter.
     * @param {GeneratedIntentPhraseFindUniqueArgs} args - Arguments to find a GeneratedIntentPhrase
     * @example
     * // Get one GeneratedIntentPhrase
     * const generatedIntentPhrase = await prisma.generatedIntentPhrase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GeneratedIntentPhraseFindUniqueArgs>(args: SelectSubset<T, GeneratedIntentPhraseFindUniqueArgs<ExtArgs>>): Prisma__GeneratedIntentPhraseClient<$Result.GetResult<Prisma.$GeneratedIntentPhrasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GeneratedIntentPhrase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GeneratedIntentPhraseFindUniqueOrThrowArgs} args - Arguments to find a GeneratedIntentPhrase
     * @example
     * // Get one GeneratedIntentPhrase
     * const generatedIntentPhrase = await prisma.generatedIntentPhrase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GeneratedIntentPhraseFindUniqueOrThrowArgs>(args: SelectSubset<T, GeneratedIntentPhraseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GeneratedIntentPhraseClient<$Result.GetResult<Prisma.$GeneratedIntentPhrasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeneratedIntentPhrase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedIntentPhraseFindFirstArgs} args - Arguments to find a GeneratedIntentPhrase
     * @example
     * // Get one GeneratedIntentPhrase
     * const generatedIntentPhrase = await prisma.generatedIntentPhrase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GeneratedIntentPhraseFindFirstArgs>(args?: SelectSubset<T, GeneratedIntentPhraseFindFirstArgs<ExtArgs>>): Prisma__GeneratedIntentPhraseClient<$Result.GetResult<Prisma.$GeneratedIntentPhrasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeneratedIntentPhrase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedIntentPhraseFindFirstOrThrowArgs} args - Arguments to find a GeneratedIntentPhrase
     * @example
     * // Get one GeneratedIntentPhrase
     * const generatedIntentPhrase = await prisma.generatedIntentPhrase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GeneratedIntentPhraseFindFirstOrThrowArgs>(args?: SelectSubset<T, GeneratedIntentPhraseFindFirstOrThrowArgs<ExtArgs>>): Prisma__GeneratedIntentPhraseClient<$Result.GetResult<Prisma.$GeneratedIntentPhrasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GeneratedIntentPhrases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedIntentPhraseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GeneratedIntentPhrases
     * const generatedIntentPhrases = await prisma.generatedIntentPhrase.findMany()
     * 
     * // Get first 10 GeneratedIntentPhrases
     * const generatedIntentPhrases = await prisma.generatedIntentPhrase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const generatedIntentPhraseWithIdOnly = await prisma.generatedIntentPhrase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GeneratedIntentPhraseFindManyArgs>(args?: SelectSubset<T, GeneratedIntentPhraseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedIntentPhrasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GeneratedIntentPhrase.
     * @param {GeneratedIntentPhraseCreateArgs} args - Arguments to create a GeneratedIntentPhrase.
     * @example
     * // Create one GeneratedIntentPhrase
     * const GeneratedIntentPhrase = await prisma.generatedIntentPhrase.create({
     *   data: {
     *     // ... data to create a GeneratedIntentPhrase
     *   }
     * })
     * 
     */
    create<T extends GeneratedIntentPhraseCreateArgs>(args: SelectSubset<T, GeneratedIntentPhraseCreateArgs<ExtArgs>>): Prisma__GeneratedIntentPhraseClient<$Result.GetResult<Prisma.$GeneratedIntentPhrasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GeneratedIntentPhrases.
     * @param {GeneratedIntentPhraseCreateManyArgs} args - Arguments to create many GeneratedIntentPhrases.
     * @example
     * // Create many GeneratedIntentPhrases
     * const generatedIntentPhrase = await prisma.generatedIntentPhrase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GeneratedIntentPhraseCreateManyArgs>(args?: SelectSubset<T, GeneratedIntentPhraseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GeneratedIntentPhrases and returns the data saved in the database.
     * @param {GeneratedIntentPhraseCreateManyAndReturnArgs} args - Arguments to create many GeneratedIntentPhrases.
     * @example
     * // Create many GeneratedIntentPhrases
     * const generatedIntentPhrase = await prisma.generatedIntentPhrase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GeneratedIntentPhrases and only return the `id`
     * const generatedIntentPhraseWithIdOnly = await prisma.generatedIntentPhrase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GeneratedIntentPhraseCreateManyAndReturnArgs>(args?: SelectSubset<T, GeneratedIntentPhraseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedIntentPhrasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GeneratedIntentPhrase.
     * @param {GeneratedIntentPhraseDeleteArgs} args - Arguments to delete one GeneratedIntentPhrase.
     * @example
     * // Delete one GeneratedIntentPhrase
     * const GeneratedIntentPhrase = await prisma.generatedIntentPhrase.delete({
     *   where: {
     *     // ... filter to delete one GeneratedIntentPhrase
     *   }
     * })
     * 
     */
    delete<T extends GeneratedIntentPhraseDeleteArgs>(args: SelectSubset<T, GeneratedIntentPhraseDeleteArgs<ExtArgs>>): Prisma__GeneratedIntentPhraseClient<$Result.GetResult<Prisma.$GeneratedIntentPhrasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GeneratedIntentPhrase.
     * @param {GeneratedIntentPhraseUpdateArgs} args - Arguments to update one GeneratedIntentPhrase.
     * @example
     * // Update one GeneratedIntentPhrase
     * const generatedIntentPhrase = await prisma.generatedIntentPhrase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GeneratedIntentPhraseUpdateArgs>(args: SelectSubset<T, GeneratedIntentPhraseUpdateArgs<ExtArgs>>): Prisma__GeneratedIntentPhraseClient<$Result.GetResult<Prisma.$GeneratedIntentPhrasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GeneratedIntentPhrases.
     * @param {GeneratedIntentPhraseDeleteManyArgs} args - Arguments to filter GeneratedIntentPhrases to delete.
     * @example
     * // Delete a few GeneratedIntentPhrases
     * const { count } = await prisma.generatedIntentPhrase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GeneratedIntentPhraseDeleteManyArgs>(args?: SelectSubset<T, GeneratedIntentPhraseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeneratedIntentPhrases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedIntentPhraseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GeneratedIntentPhrases
     * const generatedIntentPhrase = await prisma.generatedIntentPhrase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GeneratedIntentPhraseUpdateManyArgs>(args: SelectSubset<T, GeneratedIntentPhraseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GeneratedIntentPhrase.
     * @param {GeneratedIntentPhraseUpsertArgs} args - Arguments to update or create a GeneratedIntentPhrase.
     * @example
     * // Update or create a GeneratedIntentPhrase
     * const generatedIntentPhrase = await prisma.generatedIntentPhrase.upsert({
     *   create: {
     *     // ... data to create a GeneratedIntentPhrase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GeneratedIntentPhrase we want to update
     *   }
     * })
     */
    upsert<T extends GeneratedIntentPhraseUpsertArgs>(args: SelectSubset<T, GeneratedIntentPhraseUpsertArgs<ExtArgs>>): Prisma__GeneratedIntentPhraseClient<$Result.GetResult<Prisma.$GeneratedIntentPhrasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GeneratedIntentPhrases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedIntentPhraseCountArgs} args - Arguments to filter GeneratedIntentPhrases to count.
     * @example
     * // Count the number of GeneratedIntentPhrases
     * const count = await prisma.generatedIntentPhrase.count({
     *   where: {
     *     // ... the filter for the GeneratedIntentPhrases we want to count
     *   }
     * })
    **/
    count<T extends GeneratedIntentPhraseCountArgs>(
      args?: Subset<T, GeneratedIntentPhraseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeneratedIntentPhraseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GeneratedIntentPhrase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedIntentPhraseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GeneratedIntentPhraseAggregateArgs>(args: Subset<T, GeneratedIntentPhraseAggregateArgs>): Prisma.PrismaPromise<GetGeneratedIntentPhraseAggregateType<T>>

    /**
     * Group by GeneratedIntentPhrase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedIntentPhraseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GeneratedIntentPhraseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GeneratedIntentPhraseGroupByArgs['orderBy'] }
        : { orderBy?: GeneratedIntentPhraseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GeneratedIntentPhraseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeneratedIntentPhraseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GeneratedIntentPhrase model
   */
  readonly fields: GeneratedIntentPhraseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GeneratedIntentPhrase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GeneratedIntentPhraseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domain<T extends GeneratedIntentPhrase$domainArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedIntentPhrase$domainArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    keyword<T extends GeneratedIntentPhrase$keywordArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedIntentPhrase$keywordArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    relevanceScoreResults<T extends GeneratedIntentPhrase$relevanceScoreResultsArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedIntentPhrase$relevanceScoreResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelevanceScoreResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiQueryResults<T extends GeneratedIntentPhrase$aiQueryResultsArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedIntentPhrase$aiQueryResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIQueryResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GeneratedIntentPhrase model
   */
  interface GeneratedIntentPhraseFieldRefs {
    readonly id: FieldRef<"GeneratedIntentPhrase", 'Int'>
    readonly domainId: FieldRef<"GeneratedIntentPhrase", 'Int'>
    readonly keywordId: FieldRef<"GeneratedIntentPhrase", 'Int'>
    readonly phrase: FieldRef<"GeneratedIntentPhrase", 'String'>
    readonly relevanceScore: FieldRef<"GeneratedIntentPhrase", 'Int'>
    readonly intent: FieldRef<"GeneratedIntentPhrase", 'String'>
    readonly intentConfidence: FieldRef<"GeneratedIntentPhrase", 'Int'>
    readonly sources: FieldRef<"GeneratedIntentPhrase", 'Json'>
    readonly trend: FieldRef<"GeneratedIntentPhrase", 'String'>
    readonly communityInsights: FieldRef<"GeneratedIntentPhrase", 'Json'>
    readonly searchPatterns: FieldRef<"GeneratedIntentPhrase", 'Json'>
    readonly isSelected: FieldRef<"GeneratedIntentPhrase", 'Boolean'>
    readonly tokenUsage: FieldRef<"GeneratedIntentPhrase", 'Int'>
    readonly createdAt: FieldRef<"GeneratedIntentPhrase", 'DateTime'>
    readonly updatedAt: FieldRef<"GeneratedIntentPhrase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GeneratedIntentPhrase findUnique
   */
  export type GeneratedIntentPhraseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedIntentPhrase
     */
    select?: GeneratedIntentPhraseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedIntentPhrase
     */
    omit?: GeneratedIntentPhraseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedIntentPhraseInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedIntentPhrase to fetch.
     */
    where: GeneratedIntentPhraseWhereUniqueInput
  }

  /**
   * GeneratedIntentPhrase findUniqueOrThrow
   */
  export type GeneratedIntentPhraseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedIntentPhrase
     */
    select?: GeneratedIntentPhraseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedIntentPhrase
     */
    omit?: GeneratedIntentPhraseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedIntentPhraseInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedIntentPhrase to fetch.
     */
    where: GeneratedIntentPhraseWhereUniqueInput
  }

  /**
   * GeneratedIntentPhrase findFirst
   */
  export type GeneratedIntentPhraseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedIntentPhrase
     */
    select?: GeneratedIntentPhraseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedIntentPhrase
     */
    omit?: GeneratedIntentPhraseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedIntentPhraseInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedIntentPhrase to fetch.
     */
    where?: GeneratedIntentPhraseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedIntentPhrases to fetch.
     */
    orderBy?: GeneratedIntentPhraseOrderByWithRelationInput | GeneratedIntentPhraseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeneratedIntentPhrases.
     */
    cursor?: GeneratedIntentPhraseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedIntentPhrases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedIntentPhrases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeneratedIntentPhrases.
     */
    distinct?: GeneratedIntentPhraseScalarFieldEnum | GeneratedIntentPhraseScalarFieldEnum[]
  }

  /**
   * GeneratedIntentPhrase findFirstOrThrow
   */
  export type GeneratedIntentPhraseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedIntentPhrase
     */
    select?: GeneratedIntentPhraseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedIntentPhrase
     */
    omit?: GeneratedIntentPhraseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedIntentPhraseInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedIntentPhrase to fetch.
     */
    where?: GeneratedIntentPhraseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedIntentPhrases to fetch.
     */
    orderBy?: GeneratedIntentPhraseOrderByWithRelationInput | GeneratedIntentPhraseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeneratedIntentPhrases.
     */
    cursor?: GeneratedIntentPhraseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedIntentPhrases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedIntentPhrases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeneratedIntentPhrases.
     */
    distinct?: GeneratedIntentPhraseScalarFieldEnum | GeneratedIntentPhraseScalarFieldEnum[]
  }

  /**
   * GeneratedIntentPhrase findMany
   */
  export type GeneratedIntentPhraseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedIntentPhrase
     */
    select?: GeneratedIntentPhraseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedIntentPhrase
     */
    omit?: GeneratedIntentPhraseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedIntentPhraseInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedIntentPhrases to fetch.
     */
    where?: GeneratedIntentPhraseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedIntentPhrases to fetch.
     */
    orderBy?: GeneratedIntentPhraseOrderByWithRelationInput | GeneratedIntentPhraseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GeneratedIntentPhrases.
     */
    cursor?: GeneratedIntentPhraseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedIntentPhrases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedIntentPhrases.
     */
    skip?: number
    distinct?: GeneratedIntentPhraseScalarFieldEnum | GeneratedIntentPhraseScalarFieldEnum[]
  }

  /**
   * GeneratedIntentPhrase create
   */
  export type GeneratedIntentPhraseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedIntentPhrase
     */
    select?: GeneratedIntentPhraseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedIntentPhrase
     */
    omit?: GeneratedIntentPhraseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedIntentPhraseInclude<ExtArgs> | null
    /**
     * The data needed to create a GeneratedIntentPhrase.
     */
    data: XOR<GeneratedIntentPhraseCreateInput, GeneratedIntentPhraseUncheckedCreateInput>
  }

  /**
   * GeneratedIntentPhrase createMany
   */
  export type GeneratedIntentPhraseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GeneratedIntentPhrases.
     */
    data: GeneratedIntentPhraseCreateManyInput | GeneratedIntentPhraseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GeneratedIntentPhrase createManyAndReturn
   */
  export type GeneratedIntentPhraseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedIntentPhrase
     */
    select?: GeneratedIntentPhraseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedIntentPhrase
     */
    omit?: GeneratedIntentPhraseOmit<ExtArgs> | null
    /**
     * The data used to create many GeneratedIntentPhrases.
     */
    data: GeneratedIntentPhraseCreateManyInput | GeneratedIntentPhraseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedIntentPhraseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GeneratedIntentPhrase update
   */
  export type GeneratedIntentPhraseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedIntentPhrase
     */
    select?: GeneratedIntentPhraseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedIntentPhrase
     */
    omit?: GeneratedIntentPhraseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedIntentPhraseInclude<ExtArgs> | null
    /**
     * The data needed to update a GeneratedIntentPhrase.
     */
    data: XOR<GeneratedIntentPhraseUpdateInput, GeneratedIntentPhraseUncheckedUpdateInput>
    /**
     * Choose, which GeneratedIntentPhrase to update.
     */
    where: GeneratedIntentPhraseWhereUniqueInput
  }

  /**
   * GeneratedIntentPhrase updateMany
   */
  export type GeneratedIntentPhraseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GeneratedIntentPhrases.
     */
    data: XOR<GeneratedIntentPhraseUpdateManyMutationInput, GeneratedIntentPhraseUncheckedUpdateManyInput>
    /**
     * Filter which GeneratedIntentPhrases to update
     */
    where?: GeneratedIntentPhraseWhereInput
  }

  /**
   * GeneratedIntentPhrase upsert
   */
  export type GeneratedIntentPhraseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedIntentPhrase
     */
    select?: GeneratedIntentPhraseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedIntentPhrase
     */
    omit?: GeneratedIntentPhraseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedIntentPhraseInclude<ExtArgs> | null
    /**
     * The filter to search for the GeneratedIntentPhrase to update in case it exists.
     */
    where: GeneratedIntentPhraseWhereUniqueInput
    /**
     * In case the GeneratedIntentPhrase found by the `where` argument doesn't exist, create a new GeneratedIntentPhrase with this data.
     */
    create: XOR<GeneratedIntentPhraseCreateInput, GeneratedIntentPhraseUncheckedCreateInput>
    /**
     * In case the GeneratedIntentPhrase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GeneratedIntentPhraseUpdateInput, GeneratedIntentPhraseUncheckedUpdateInput>
  }

  /**
   * GeneratedIntentPhrase delete
   */
  export type GeneratedIntentPhraseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedIntentPhrase
     */
    select?: GeneratedIntentPhraseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedIntentPhrase
     */
    omit?: GeneratedIntentPhraseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedIntentPhraseInclude<ExtArgs> | null
    /**
     * Filter which GeneratedIntentPhrase to delete.
     */
    where: GeneratedIntentPhraseWhereUniqueInput
  }

  /**
   * GeneratedIntentPhrase deleteMany
   */
  export type GeneratedIntentPhraseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeneratedIntentPhrases to delete
     */
    where?: GeneratedIntentPhraseWhereInput
  }

  /**
   * GeneratedIntentPhrase.domain
   */
  export type GeneratedIntentPhrase$domainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    where?: DomainWhereInput
  }

  /**
   * GeneratedIntentPhrase.keyword
   */
  export type GeneratedIntentPhrase$keywordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    where?: KeywordWhereInput
  }

  /**
   * GeneratedIntentPhrase.relevanceScoreResults
   */
  export type GeneratedIntentPhrase$relevanceScoreResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelevanceScoreResult
     */
    select?: RelevanceScoreResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelevanceScoreResult
     */
    omit?: RelevanceScoreResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelevanceScoreResultInclude<ExtArgs> | null
    where?: RelevanceScoreResultWhereInput
    orderBy?: RelevanceScoreResultOrderByWithRelationInput | RelevanceScoreResultOrderByWithRelationInput[]
    cursor?: RelevanceScoreResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelevanceScoreResultScalarFieldEnum | RelevanceScoreResultScalarFieldEnum[]
  }

  /**
   * GeneratedIntentPhrase.aiQueryResults
   */
  export type GeneratedIntentPhrase$aiQueryResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIQueryResult
     */
    select?: AIQueryResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIQueryResult
     */
    omit?: AIQueryResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIQueryResultInclude<ExtArgs> | null
    where?: AIQueryResultWhereInput
    orderBy?: AIQueryResultOrderByWithRelationInput | AIQueryResultOrderByWithRelationInput[]
    cursor?: AIQueryResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIQueryResultScalarFieldEnum | AIQueryResultScalarFieldEnum[]
  }

  /**
   * GeneratedIntentPhrase without action
   */
  export type GeneratedIntentPhraseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedIntentPhrase
     */
    select?: GeneratedIntentPhraseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedIntentPhrase
     */
    omit?: GeneratedIntentPhraseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedIntentPhraseInclude<ExtArgs> | null
  }


  /**
   * Model RelevanceScoreResult
   */

  export type AggregateRelevanceScoreResult = {
    _count: RelevanceScoreResultCountAggregateOutputType | null
    _avg: RelevanceScoreResultAvgAggregateOutputType | null
    _sum: RelevanceScoreResultSumAggregateOutputType | null
    _min: RelevanceScoreResultMinAggregateOutputType | null
    _max: RelevanceScoreResultMaxAggregateOutputType | null
  }

  export type RelevanceScoreResultAvgAggregateOutputType = {
    id: number | null
    domainId: number | null
    phraseId: number | null
    score: number | null
    tokenUsage: number | null
  }

  export type RelevanceScoreResultSumAggregateOutputType = {
    id: number | null
    domainId: number | null
    phraseId: number | null
    score: number | null
    tokenUsage: number | null
  }

  export type RelevanceScoreResultMinAggregateOutputType = {
    id: number | null
    domainId: number | null
    phraseId: number | null
    score: number | null
    tokenUsage: number | null
    createdAt: Date | null
  }

  export type RelevanceScoreResultMaxAggregateOutputType = {
    id: number | null
    domainId: number | null
    phraseId: number | null
    score: number | null
    tokenUsage: number | null
    createdAt: Date | null
  }

  export type RelevanceScoreResultCountAggregateOutputType = {
    id: number
    domainId: number
    phraseId: number
    score: number
    breakdown: number
    factors: number
    tokenUsage: number
    createdAt: number
    _all: number
  }


  export type RelevanceScoreResultAvgAggregateInputType = {
    id?: true
    domainId?: true
    phraseId?: true
    score?: true
    tokenUsage?: true
  }

  export type RelevanceScoreResultSumAggregateInputType = {
    id?: true
    domainId?: true
    phraseId?: true
    score?: true
    tokenUsage?: true
  }

  export type RelevanceScoreResultMinAggregateInputType = {
    id?: true
    domainId?: true
    phraseId?: true
    score?: true
    tokenUsage?: true
    createdAt?: true
  }

  export type RelevanceScoreResultMaxAggregateInputType = {
    id?: true
    domainId?: true
    phraseId?: true
    score?: true
    tokenUsage?: true
    createdAt?: true
  }

  export type RelevanceScoreResultCountAggregateInputType = {
    id?: true
    domainId?: true
    phraseId?: true
    score?: true
    breakdown?: true
    factors?: true
    tokenUsage?: true
    createdAt?: true
    _all?: true
  }

  export type RelevanceScoreResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelevanceScoreResult to aggregate.
     */
    where?: RelevanceScoreResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelevanceScoreResults to fetch.
     */
    orderBy?: RelevanceScoreResultOrderByWithRelationInput | RelevanceScoreResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelevanceScoreResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelevanceScoreResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelevanceScoreResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RelevanceScoreResults
    **/
    _count?: true | RelevanceScoreResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RelevanceScoreResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RelevanceScoreResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelevanceScoreResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelevanceScoreResultMaxAggregateInputType
  }

  export type GetRelevanceScoreResultAggregateType<T extends RelevanceScoreResultAggregateArgs> = {
        [P in keyof T & keyof AggregateRelevanceScoreResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelevanceScoreResult[P]>
      : GetScalarType<T[P], AggregateRelevanceScoreResult[P]>
  }




  export type RelevanceScoreResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelevanceScoreResultWhereInput
    orderBy?: RelevanceScoreResultOrderByWithAggregationInput | RelevanceScoreResultOrderByWithAggregationInput[]
    by: RelevanceScoreResultScalarFieldEnum[] | RelevanceScoreResultScalarFieldEnum
    having?: RelevanceScoreResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelevanceScoreResultCountAggregateInputType | true
    _avg?: RelevanceScoreResultAvgAggregateInputType
    _sum?: RelevanceScoreResultSumAggregateInputType
    _min?: RelevanceScoreResultMinAggregateInputType
    _max?: RelevanceScoreResultMaxAggregateInputType
  }

  export type RelevanceScoreResultGroupByOutputType = {
    id: number
    domainId: number
    phraseId: number | null
    score: number
    breakdown: JsonValue | null
    factors: JsonValue | null
    tokenUsage: number | null
    createdAt: Date
    _count: RelevanceScoreResultCountAggregateOutputType | null
    _avg: RelevanceScoreResultAvgAggregateOutputType | null
    _sum: RelevanceScoreResultSumAggregateOutputType | null
    _min: RelevanceScoreResultMinAggregateOutputType | null
    _max: RelevanceScoreResultMaxAggregateOutputType | null
  }

  type GetRelevanceScoreResultGroupByPayload<T extends RelevanceScoreResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelevanceScoreResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelevanceScoreResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelevanceScoreResultGroupByOutputType[P]>
            : GetScalarType<T[P], RelevanceScoreResultGroupByOutputType[P]>
        }
      >
    >


  export type RelevanceScoreResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    phraseId?: boolean
    score?: boolean
    breakdown?: boolean
    factors?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    domain?: boolean | RelevanceScoreResult$domainArgs<ExtArgs>
    phrase?: boolean | RelevanceScoreResult$phraseArgs<ExtArgs>
  }, ExtArgs["result"]["relevanceScoreResult"]>

  export type RelevanceScoreResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainId?: boolean
    phraseId?: boolean
    score?: boolean
    breakdown?: boolean
    factors?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    domain?: boolean | RelevanceScoreResult$domainArgs<ExtArgs>
    phrase?: boolean | RelevanceScoreResult$phraseArgs<ExtArgs>
  }, ExtArgs["result"]["relevanceScoreResult"]>


  export type RelevanceScoreResultSelectScalar = {
    id?: boolean
    domainId?: boolean
    phraseId?: boolean
    score?: boolean
    breakdown?: boolean
    factors?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
  }

  export type RelevanceScoreResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "domainId" | "phraseId" | "score" | "breakdown" | "factors" | "tokenUsage" | "createdAt", ExtArgs["result"]["relevanceScoreResult"]>
  export type RelevanceScoreResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | RelevanceScoreResult$domainArgs<ExtArgs>
    phrase?: boolean | RelevanceScoreResult$phraseArgs<ExtArgs>
  }
  export type RelevanceScoreResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | RelevanceScoreResult$domainArgs<ExtArgs>
    phrase?: boolean | RelevanceScoreResult$phraseArgs<ExtArgs>
  }

  export type $RelevanceScoreResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RelevanceScoreResult"
    objects: {
      domain: Prisma.$DomainPayload<ExtArgs> | null
      phrase: Prisma.$GeneratedIntentPhrasePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      domainId: number
      phraseId: number | null
      score: number
      breakdown: Prisma.JsonValue | null
      factors: Prisma.JsonValue | null
      tokenUsage: number | null
      createdAt: Date
    }, ExtArgs["result"]["relevanceScoreResult"]>
    composites: {}
  }

  type RelevanceScoreResultGetPayload<S extends boolean | null | undefined | RelevanceScoreResultDefaultArgs> = $Result.GetResult<Prisma.$RelevanceScoreResultPayload, S>

  type RelevanceScoreResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RelevanceScoreResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RelevanceScoreResultCountAggregateInputType | true
    }

  export interface RelevanceScoreResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RelevanceScoreResult'], meta: { name: 'RelevanceScoreResult' } }
    /**
     * Find zero or one RelevanceScoreResult that matches the filter.
     * @param {RelevanceScoreResultFindUniqueArgs} args - Arguments to find a RelevanceScoreResult
     * @example
     * // Get one RelevanceScoreResult
     * const relevanceScoreResult = await prisma.relevanceScoreResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RelevanceScoreResultFindUniqueArgs>(args: SelectSubset<T, RelevanceScoreResultFindUniqueArgs<ExtArgs>>): Prisma__RelevanceScoreResultClient<$Result.GetResult<Prisma.$RelevanceScoreResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RelevanceScoreResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RelevanceScoreResultFindUniqueOrThrowArgs} args - Arguments to find a RelevanceScoreResult
     * @example
     * // Get one RelevanceScoreResult
     * const relevanceScoreResult = await prisma.relevanceScoreResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RelevanceScoreResultFindUniqueOrThrowArgs>(args: SelectSubset<T, RelevanceScoreResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RelevanceScoreResultClient<$Result.GetResult<Prisma.$RelevanceScoreResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelevanceScoreResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelevanceScoreResultFindFirstArgs} args - Arguments to find a RelevanceScoreResult
     * @example
     * // Get one RelevanceScoreResult
     * const relevanceScoreResult = await prisma.relevanceScoreResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RelevanceScoreResultFindFirstArgs>(args?: SelectSubset<T, RelevanceScoreResultFindFirstArgs<ExtArgs>>): Prisma__RelevanceScoreResultClient<$Result.GetResult<Prisma.$RelevanceScoreResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelevanceScoreResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelevanceScoreResultFindFirstOrThrowArgs} args - Arguments to find a RelevanceScoreResult
     * @example
     * // Get one RelevanceScoreResult
     * const relevanceScoreResult = await prisma.relevanceScoreResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RelevanceScoreResultFindFirstOrThrowArgs>(args?: SelectSubset<T, RelevanceScoreResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__RelevanceScoreResultClient<$Result.GetResult<Prisma.$RelevanceScoreResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RelevanceScoreResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelevanceScoreResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RelevanceScoreResults
     * const relevanceScoreResults = await prisma.relevanceScoreResult.findMany()
     * 
     * // Get first 10 RelevanceScoreResults
     * const relevanceScoreResults = await prisma.relevanceScoreResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relevanceScoreResultWithIdOnly = await prisma.relevanceScoreResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RelevanceScoreResultFindManyArgs>(args?: SelectSubset<T, RelevanceScoreResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelevanceScoreResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RelevanceScoreResult.
     * @param {RelevanceScoreResultCreateArgs} args - Arguments to create a RelevanceScoreResult.
     * @example
     * // Create one RelevanceScoreResult
     * const RelevanceScoreResult = await prisma.relevanceScoreResult.create({
     *   data: {
     *     // ... data to create a RelevanceScoreResult
     *   }
     * })
     * 
     */
    create<T extends RelevanceScoreResultCreateArgs>(args: SelectSubset<T, RelevanceScoreResultCreateArgs<ExtArgs>>): Prisma__RelevanceScoreResultClient<$Result.GetResult<Prisma.$RelevanceScoreResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RelevanceScoreResults.
     * @param {RelevanceScoreResultCreateManyArgs} args - Arguments to create many RelevanceScoreResults.
     * @example
     * // Create many RelevanceScoreResults
     * const relevanceScoreResult = await prisma.relevanceScoreResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RelevanceScoreResultCreateManyArgs>(args?: SelectSubset<T, RelevanceScoreResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RelevanceScoreResults and returns the data saved in the database.
     * @param {RelevanceScoreResultCreateManyAndReturnArgs} args - Arguments to create many RelevanceScoreResults.
     * @example
     * // Create many RelevanceScoreResults
     * const relevanceScoreResult = await prisma.relevanceScoreResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RelevanceScoreResults and only return the `id`
     * const relevanceScoreResultWithIdOnly = await prisma.relevanceScoreResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RelevanceScoreResultCreateManyAndReturnArgs>(args?: SelectSubset<T, RelevanceScoreResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelevanceScoreResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RelevanceScoreResult.
     * @param {RelevanceScoreResultDeleteArgs} args - Arguments to delete one RelevanceScoreResult.
     * @example
     * // Delete one RelevanceScoreResult
     * const RelevanceScoreResult = await prisma.relevanceScoreResult.delete({
     *   where: {
     *     // ... filter to delete one RelevanceScoreResult
     *   }
     * })
     * 
     */
    delete<T extends RelevanceScoreResultDeleteArgs>(args: SelectSubset<T, RelevanceScoreResultDeleteArgs<ExtArgs>>): Prisma__RelevanceScoreResultClient<$Result.GetResult<Prisma.$RelevanceScoreResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RelevanceScoreResult.
     * @param {RelevanceScoreResultUpdateArgs} args - Arguments to update one RelevanceScoreResult.
     * @example
     * // Update one RelevanceScoreResult
     * const relevanceScoreResult = await prisma.relevanceScoreResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RelevanceScoreResultUpdateArgs>(args: SelectSubset<T, RelevanceScoreResultUpdateArgs<ExtArgs>>): Prisma__RelevanceScoreResultClient<$Result.GetResult<Prisma.$RelevanceScoreResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RelevanceScoreResults.
     * @param {RelevanceScoreResultDeleteManyArgs} args - Arguments to filter RelevanceScoreResults to delete.
     * @example
     * // Delete a few RelevanceScoreResults
     * const { count } = await prisma.relevanceScoreResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RelevanceScoreResultDeleteManyArgs>(args?: SelectSubset<T, RelevanceScoreResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelevanceScoreResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelevanceScoreResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RelevanceScoreResults
     * const relevanceScoreResult = await prisma.relevanceScoreResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RelevanceScoreResultUpdateManyArgs>(args: SelectSubset<T, RelevanceScoreResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RelevanceScoreResult.
     * @param {RelevanceScoreResultUpsertArgs} args - Arguments to update or create a RelevanceScoreResult.
     * @example
     * // Update or create a RelevanceScoreResult
     * const relevanceScoreResult = await prisma.relevanceScoreResult.upsert({
     *   create: {
     *     // ... data to create a RelevanceScoreResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RelevanceScoreResult we want to update
     *   }
     * })
     */
    upsert<T extends RelevanceScoreResultUpsertArgs>(args: SelectSubset<T, RelevanceScoreResultUpsertArgs<ExtArgs>>): Prisma__RelevanceScoreResultClient<$Result.GetResult<Prisma.$RelevanceScoreResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RelevanceScoreResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelevanceScoreResultCountArgs} args - Arguments to filter RelevanceScoreResults to count.
     * @example
     * // Count the number of RelevanceScoreResults
     * const count = await prisma.relevanceScoreResult.count({
     *   where: {
     *     // ... the filter for the RelevanceScoreResults we want to count
     *   }
     * })
    **/
    count<T extends RelevanceScoreResultCountArgs>(
      args?: Subset<T, RelevanceScoreResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelevanceScoreResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RelevanceScoreResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelevanceScoreResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelevanceScoreResultAggregateArgs>(args: Subset<T, RelevanceScoreResultAggregateArgs>): Prisma.PrismaPromise<GetRelevanceScoreResultAggregateType<T>>

    /**
     * Group by RelevanceScoreResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelevanceScoreResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelevanceScoreResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelevanceScoreResultGroupByArgs['orderBy'] }
        : { orderBy?: RelevanceScoreResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelevanceScoreResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelevanceScoreResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RelevanceScoreResult model
   */
  readonly fields: RelevanceScoreResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RelevanceScoreResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelevanceScoreResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domain<T extends RelevanceScoreResult$domainArgs<ExtArgs> = {}>(args?: Subset<T, RelevanceScoreResult$domainArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    phrase<T extends RelevanceScoreResult$phraseArgs<ExtArgs> = {}>(args?: Subset<T, RelevanceScoreResult$phraseArgs<ExtArgs>>): Prisma__GeneratedIntentPhraseClient<$Result.GetResult<Prisma.$GeneratedIntentPhrasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RelevanceScoreResult model
   */
  interface RelevanceScoreResultFieldRefs {
    readonly id: FieldRef<"RelevanceScoreResult", 'Int'>
    readonly domainId: FieldRef<"RelevanceScoreResult", 'Int'>
    readonly phraseId: FieldRef<"RelevanceScoreResult", 'Int'>
    readonly score: FieldRef<"RelevanceScoreResult", 'Int'>
    readonly breakdown: FieldRef<"RelevanceScoreResult", 'Json'>
    readonly factors: FieldRef<"RelevanceScoreResult", 'Json'>
    readonly tokenUsage: FieldRef<"RelevanceScoreResult", 'Int'>
    readonly createdAt: FieldRef<"RelevanceScoreResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RelevanceScoreResult findUnique
   */
  export type RelevanceScoreResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelevanceScoreResult
     */
    select?: RelevanceScoreResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelevanceScoreResult
     */
    omit?: RelevanceScoreResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelevanceScoreResultInclude<ExtArgs> | null
    /**
     * Filter, which RelevanceScoreResult to fetch.
     */
    where: RelevanceScoreResultWhereUniqueInput
  }

  /**
   * RelevanceScoreResult findUniqueOrThrow
   */
  export type RelevanceScoreResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelevanceScoreResult
     */
    select?: RelevanceScoreResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelevanceScoreResult
     */
    omit?: RelevanceScoreResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelevanceScoreResultInclude<ExtArgs> | null
    /**
     * Filter, which RelevanceScoreResult to fetch.
     */
    where: RelevanceScoreResultWhereUniqueInput
  }

  /**
   * RelevanceScoreResult findFirst
   */
  export type RelevanceScoreResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelevanceScoreResult
     */
    select?: RelevanceScoreResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelevanceScoreResult
     */
    omit?: RelevanceScoreResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelevanceScoreResultInclude<ExtArgs> | null
    /**
     * Filter, which RelevanceScoreResult to fetch.
     */
    where?: RelevanceScoreResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelevanceScoreResults to fetch.
     */
    orderBy?: RelevanceScoreResultOrderByWithRelationInput | RelevanceScoreResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelevanceScoreResults.
     */
    cursor?: RelevanceScoreResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelevanceScoreResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelevanceScoreResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelevanceScoreResults.
     */
    distinct?: RelevanceScoreResultScalarFieldEnum | RelevanceScoreResultScalarFieldEnum[]
  }

  /**
   * RelevanceScoreResult findFirstOrThrow
   */
  export type RelevanceScoreResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelevanceScoreResult
     */
    select?: RelevanceScoreResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelevanceScoreResult
     */
    omit?: RelevanceScoreResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelevanceScoreResultInclude<ExtArgs> | null
    /**
     * Filter, which RelevanceScoreResult to fetch.
     */
    where?: RelevanceScoreResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelevanceScoreResults to fetch.
     */
    orderBy?: RelevanceScoreResultOrderByWithRelationInput | RelevanceScoreResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelevanceScoreResults.
     */
    cursor?: RelevanceScoreResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelevanceScoreResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelevanceScoreResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelevanceScoreResults.
     */
    distinct?: RelevanceScoreResultScalarFieldEnum | RelevanceScoreResultScalarFieldEnum[]
  }

  /**
   * RelevanceScoreResult findMany
   */
  export type RelevanceScoreResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelevanceScoreResult
     */
    select?: RelevanceScoreResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelevanceScoreResult
     */
    omit?: RelevanceScoreResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelevanceScoreResultInclude<ExtArgs> | null
    /**
     * Filter, which RelevanceScoreResults to fetch.
     */
    where?: RelevanceScoreResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelevanceScoreResults to fetch.
     */
    orderBy?: RelevanceScoreResultOrderByWithRelationInput | RelevanceScoreResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RelevanceScoreResults.
     */
    cursor?: RelevanceScoreResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelevanceScoreResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelevanceScoreResults.
     */
    skip?: number
    distinct?: RelevanceScoreResultScalarFieldEnum | RelevanceScoreResultScalarFieldEnum[]
  }

  /**
   * RelevanceScoreResult create
   */
  export type RelevanceScoreResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelevanceScoreResult
     */
    select?: RelevanceScoreResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelevanceScoreResult
     */
    omit?: RelevanceScoreResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelevanceScoreResultInclude<ExtArgs> | null
    /**
     * The data needed to create a RelevanceScoreResult.
     */
    data: XOR<RelevanceScoreResultCreateInput, RelevanceScoreResultUncheckedCreateInput>
  }

  /**
   * RelevanceScoreResult createMany
   */
  export type RelevanceScoreResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RelevanceScoreResults.
     */
    data: RelevanceScoreResultCreateManyInput | RelevanceScoreResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelevanceScoreResult createManyAndReturn
   */
  export type RelevanceScoreResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelevanceScoreResult
     */
    select?: RelevanceScoreResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelevanceScoreResult
     */
    omit?: RelevanceScoreResultOmit<ExtArgs> | null
    /**
     * The data used to create many RelevanceScoreResults.
     */
    data: RelevanceScoreResultCreateManyInput | RelevanceScoreResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelevanceScoreResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RelevanceScoreResult update
   */
  export type RelevanceScoreResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelevanceScoreResult
     */
    select?: RelevanceScoreResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelevanceScoreResult
     */
    omit?: RelevanceScoreResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelevanceScoreResultInclude<ExtArgs> | null
    /**
     * The data needed to update a RelevanceScoreResult.
     */
    data: XOR<RelevanceScoreResultUpdateInput, RelevanceScoreResultUncheckedUpdateInput>
    /**
     * Choose, which RelevanceScoreResult to update.
     */
    where: RelevanceScoreResultWhereUniqueInput
  }

  /**
   * RelevanceScoreResult updateMany
   */
  export type RelevanceScoreResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RelevanceScoreResults.
     */
    data: XOR<RelevanceScoreResultUpdateManyMutationInput, RelevanceScoreResultUncheckedUpdateManyInput>
    /**
     * Filter which RelevanceScoreResults to update
     */
    where?: RelevanceScoreResultWhereInput
  }

  /**
   * RelevanceScoreResult upsert
   */
  export type RelevanceScoreResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelevanceScoreResult
     */
    select?: RelevanceScoreResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelevanceScoreResult
     */
    omit?: RelevanceScoreResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelevanceScoreResultInclude<ExtArgs> | null
    /**
     * The filter to search for the RelevanceScoreResult to update in case it exists.
     */
    where: RelevanceScoreResultWhereUniqueInput
    /**
     * In case the RelevanceScoreResult found by the `where` argument doesn't exist, create a new RelevanceScoreResult with this data.
     */
    create: XOR<RelevanceScoreResultCreateInput, RelevanceScoreResultUncheckedCreateInput>
    /**
     * In case the RelevanceScoreResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelevanceScoreResultUpdateInput, RelevanceScoreResultUncheckedUpdateInput>
  }

  /**
   * RelevanceScoreResult delete
   */
  export type RelevanceScoreResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelevanceScoreResult
     */
    select?: RelevanceScoreResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelevanceScoreResult
     */
    omit?: RelevanceScoreResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelevanceScoreResultInclude<ExtArgs> | null
    /**
     * Filter which RelevanceScoreResult to delete.
     */
    where: RelevanceScoreResultWhereUniqueInput
  }

  /**
   * RelevanceScoreResult deleteMany
   */
  export type RelevanceScoreResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelevanceScoreResults to delete
     */
    where?: RelevanceScoreResultWhereInput
  }

  /**
   * RelevanceScoreResult.domain
   */
  export type RelevanceScoreResult$domainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    where?: DomainWhereInput
  }

  /**
   * RelevanceScoreResult.phrase
   */
  export type RelevanceScoreResult$phraseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedIntentPhrase
     */
    select?: GeneratedIntentPhraseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedIntentPhrase
     */
    omit?: GeneratedIntentPhraseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedIntentPhraseInclude<ExtArgs> | null
    where?: GeneratedIntentPhraseWhereInput
  }

  /**
   * RelevanceScoreResult without action
   */
  export type RelevanceScoreResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelevanceScoreResult
     */
    select?: RelevanceScoreResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelevanceScoreResult
     */
    omit?: RelevanceScoreResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelevanceScoreResultInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const DomainScalarFieldEnum: {
    id: 'id',
    url: 'url',
    context: 'context',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    location: 'location',
    customKeywords: 'customKeywords',
    intentPhrases: 'intentPhrases',
    chatModel: 'chatModel',
    runAllModels: 'runAllModels',
    locationContext: 'locationContext'
  };

  export type DomainScalarFieldEnum = (typeof DomainScalarFieldEnum)[keyof typeof DomainScalarFieldEnum]


  export const CrawlResultScalarFieldEnum: {
    id: 'id',
    domainId: 'domainId',
    pagesScanned: 'pagesScanned',
    analyzedUrls: 'analyzedUrls',
    extractedContext: 'extractedContext',
    tokenUsage: 'tokenUsage',
    createdAt: 'createdAt'
  };

  export type CrawlResultScalarFieldEnum = (typeof CrawlResultScalarFieldEnum)[keyof typeof CrawlResultScalarFieldEnum]


  export const KeywordScalarFieldEnum: {
    id: 'id',
    term: 'term',
    volume: 'volume',
    difficulty: 'difficulty',
    cpc: 'cpc',
    intent: 'intent',
    domainId: 'domainId',
    isSelected: 'isSelected',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KeywordScalarFieldEnum = (typeof KeywordScalarFieldEnum)[keyof typeof KeywordScalarFieldEnum]


  export const PhraseScalarFieldEnum: {
    id: 'id',
    text: 'text',
    keywordId: 'keywordId',
    relevanceScore: 'relevanceScore',
    sources: 'sources',
    trend: 'trend',
    intent: 'intent',
    confidence: 'confidence',
    isSelected: 'isSelected',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PhraseScalarFieldEnum = (typeof PhraseScalarFieldEnum)[keyof typeof PhraseScalarFieldEnum]


  export const AIQueryResultScalarFieldEnum: {
    id: 'id',
    phraseId: 'phraseId',
    model: 'model',
    response: 'response',
    latency: 'latency',
    cost: 'cost',
    presence: 'presence',
    relevance: 'relevance',
    accuracy: 'accuracy',
    sentiment: 'sentiment',
    overall: 'overall',
    createdAt: 'createdAt'
  };

  export type AIQueryResultScalarFieldEnum = (typeof AIQueryResultScalarFieldEnum)[keyof typeof AIQueryResultScalarFieldEnum]


  export const DashboardAnalysisScalarFieldEnum: {
    id: 'id',
    domainId: 'domainId',
    metrics: 'metrics',
    insights: 'insights',
    industryAnalysis: 'industryAnalysis',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DashboardAnalysisScalarFieldEnum = (typeof DashboardAnalysisScalarFieldEnum)[keyof typeof DashboardAnalysisScalarFieldEnum]


  export const CompetitorAnalysisScalarFieldEnum: {
    id: 'id',
    domainId: 'domainId',
    competitors: 'competitors',
    marketInsights: 'marketInsights',
    strategicRecommendations: 'strategicRecommendations',
    competitiveAnalysis: 'competitiveAnalysis',
    competitorList: 'competitorList',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompetitorAnalysisScalarFieldEnum = (typeof CompetitorAnalysisScalarFieldEnum)[keyof typeof CompetitorAnalysisScalarFieldEnum]


  export const SuggestedCompetitorScalarFieldEnum: {
    id: 'id',
    domainId: 'domainId',
    name: 'name',
    competitorDomain: 'competitorDomain',
    reason: 'reason',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type SuggestedCompetitorScalarFieldEnum = (typeof SuggestedCompetitorScalarFieldEnum)[keyof typeof SuggestedCompetitorScalarFieldEnum]


  export const AnalysisPhaseScalarFieldEnum: {
    id: 'id',
    domainId: 'domainId',
    phase: 'phase',
    status: 'status',
    progress: 'progress',
    startTime: 'startTime',
    endTime: 'endTime',
    result: 'result',
    error: 'error',
    tokenUsage: 'tokenUsage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnalysisPhaseScalarFieldEnum = (typeof AnalysisPhaseScalarFieldEnum)[keyof typeof AnalysisPhaseScalarFieldEnum]


  export const SemanticAnalysisScalarFieldEnum: {
    id: 'id',
    domainId: 'domainId',
    contentSummary: 'contentSummary',
    keyThemes: 'keyThemes',
    brandVoice: 'brandVoice',
    targetAudience: 'targetAudience',
    contentGaps: 'contentGaps',
    tokenUsage: 'tokenUsage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SemanticAnalysisScalarFieldEnum = (typeof SemanticAnalysisScalarFieldEnum)[keyof typeof SemanticAnalysisScalarFieldEnum]


  export const KeywordAnalysisScalarFieldEnum: {
    id: 'id',
    domainId: 'domainId',
    keywords: 'keywords',
    searchVolumeData: 'searchVolumeData',
    intentClassification: 'intentClassification',
    competitiveAnalysis: 'competitiveAnalysis',
    tokenUsage: 'tokenUsage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KeywordAnalysisScalarFieldEnum = (typeof KeywordAnalysisScalarFieldEnum)[keyof typeof KeywordAnalysisScalarFieldEnum]


  export const SearchVolumeClassificationScalarFieldEnum: {
    id: 'id',
    domainId: 'domainId',
    highVolumeKeywords: 'highVolumeKeywords',
    mediumVolumeKeywords: 'mediumVolumeKeywords',
    lowVolumeKeywords: 'lowVolumeKeywords',
    volumeTrends: 'volumeTrends',
    seasonalPatterns: 'seasonalPatterns',
    tokenUsage: 'tokenUsage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SearchVolumeClassificationScalarFieldEnum = (typeof SearchVolumeClassificationScalarFieldEnum)[keyof typeof SearchVolumeClassificationScalarFieldEnum]


  export const IntentClassificationScalarFieldEnum: {
    id: 'id',
    domainId: 'domainId',
    informationalKeywords: 'informationalKeywords',
    navigationalKeywords: 'navigationalKeywords',
    transactionalKeywords: 'transactionalKeywords',
    commercialKeywords: 'commercialKeywords',
    intentDistribution: 'intentDistribution',
    tokenUsage: 'tokenUsage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntentClassificationScalarFieldEnum = (typeof IntentClassificationScalarFieldEnum)[keyof typeof IntentClassificationScalarFieldEnum]


  export const CommunityInsightScalarFieldEnum: {
    id: 'id',
    domainId: 'domainId',
    keywordId: 'keywordId',
    sources: 'sources',
    summary: 'summary',
    tokenUsage: 'tokenUsage',
    createdAt: 'createdAt'
  };

  export type CommunityInsightScalarFieldEnum = (typeof CommunityInsightScalarFieldEnum)[keyof typeof CommunityInsightScalarFieldEnum]


  export const SearchPatternScalarFieldEnum: {
    id: 'id',
    domainId: 'domainId',
    keywordId: 'keywordId',
    patterns: 'patterns',
    summary: 'summary',
    tokenUsage: 'tokenUsage',
    createdAt: 'createdAt'
  };

  export type SearchPatternScalarFieldEnum = (typeof SearchPatternScalarFieldEnum)[keyof typeof SearchPatternScalarFieldEnum]


  export const PhraseIntentClassificationScalarFieldEnum: {
    id: 'id',
    phraseId: 'phraseId',
    intent: 'intent',
    confidence: 'confidence',
    createdAt: 'createdAt'
  };

  export type PhraseIntentClassificationScalarFieldEnum = (typeof PhraseIntentClassificationScalarFieldEnum)[keyof typeof PhraseIntentClassificationScalarFieldEnum]


  export const PhraseScoreScalarFieldEnum: {
    id: 'id',
    phraseId: 'phraseId',
    score: 'score',
    breakdown: 'breakdown',
    createdAt: 'createdAt'
  };

  export type PhraseScoreScalarFieldEnum = (typeof PhraseScoreScalarFieldEnum)[keyof typeof PhraseScoreScalarFieldEnum]


  export const IntentPhraseGenerationScalarFieldEnum: {
    id: 'id',
    domainId: 'domainId',
    status: 'status',
    phase: 'phase',
    progress: 'progress',
    startTime: 'startTime',
    endTime: 'endTime',
    result: 'result',
    error: 'error',
    tokenUsage: 'tokenUsage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntentPhraseGenerationScalarFieldEnum = (typeof IntentPhraseGenerationScalarFieldEnum)[keyof typeof IntentPhraseGenerationScalarFieldEnum]


  export const CommunityMiningResultScalarFieldEnum: {
    id: 'id',
    domainId: 'domainId',
    keywordId: 'keywordId',
    platform: 'platform',
    insights: 'insights',
    sentiment: 'sentiment',
    frequency: 'frequency',
    tokenUsage: 'tokenUsage',
    createdAt: 'createdAt'
  };

  export type CommunityMiningResultScalarFieldEnum = (typeof CommunityMiningResultScalarFieldEnum)[keyof typeof CommunityMiningResultScalarFieldEnum]


  export const SearchPatternResultScalarFieldEnum: {
    id: 'id',
    domainId: 'domainId',
    keywordId: 'keywordId',
    patterns: 'patterns',
    volume: 'volume',
    seasonality: 'seasonality',
    trends: 'trends',
    tokenUsage: 'tokenUsage',
    createdAt: 'createdAt'
  };

  export type SearchPatternResultScalarFieldEnum = (typeof SearchPatternResultScalarFieldEnum)[keyof typeof SearchPatternResultScalarFieldEnum]


  export const IntentClassificationResultScalarFieldEnum: {
    id: 'id',
    domainId: 'domainId',
    keywordId: 'keywordId',
    intent: 'intent',
    confidence: 'confidence',
    patterns: 'patterns',
    tokenUsage: 'tokenUsage',
    createdAt: 'createdAt'
  };

  export type IntentClassificationResultScalarFieldEnum = (typeof IntentClassificationResultScalarFieldEnum)[keyof typeof IntentClassificationResultScalarFieldEnum]


  export const GeneratedIntentPhraseScalarFieldEnum: {
    id: 'id',
    domainId: 'domainId',
    keywordId: 'keywordId',
    phrase: 'phrase',
    relevanceScore: 'relevanceScore',
    intent: 'intent',
    intentConfidence: 'intentConfidence',
    sources: 'sources',
    trend: 'trend',
    communityInsights: 'communityInsights',
    searchPatterns: 'searchPatterns',
    isSelected: 'isSelected',
    tokenUsage: 'tokenUsage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GeneratedIntentPhraseScalarFieldEnum = (typeof GeneratedIntentPhraseScalarFieldEnum)[keyof typeof GeneratedIntentPhraseScalarFieldEnum]


  export const RelevanceScoreResultScalarFieldEnum: {
    id: 'id',
    domainId: 'domainId',
    phraseId: 'phraseId',
    score: 'score',
    breakdown: 'breakdown',
    factors: 'factors',
    tokenUsage: 'tokenUsage',
    createdAt: 'createdAt'
  };

  export type RelevanceScoreResultScalarFieldEnum = (typeof RelevanceScoreResultScalarFieldEnum)[keyof typeof RelevanceScoreResultScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    domains?: DomainListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    domains?: DomainOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    domains?: DomainListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type DomainWhereInput = {
    AND?: DomainWhereInput | DomainWhereInput[]
    OR?: DomainWhereInput[]
    NOT?: DomainWhereInput | DomainWhereInput[]
    id?: IntFilter<"Domain"> | number
    url?: StringFilter<"Domain"> | string
    context?: StringNullableFilter<"Domain"> | string | null
    userId?: IntNullableFilter<"Domain"> | number | null
    createdAt?: DateTimeFilter<"Domain"> | Date | string
    updatedAt?: DateTimeFilter<"Domain"> | Date | string
    location?: StringNullableFilter<"Domain"> | string | null
    customKeywords?: StringNullableFilter<"Domain"> | string | null
    intentPhrases?: StringNullableFilter<"Domain"> | string | null
    chatModel?: StringNullableFilter<"Domain"> | string | null
    runAllModels?: BoolFilter<"Domain"> | boolean
    locationContext?: StringNullableFilter<"Domain"> | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    crawlResults?: CrawlResultListRelationFilter
    keywords?: KeywordListRelationFilter
    dashboardAnalyses?: DashboardAnalysisListRelationFilter
    competitorAnalyses?: CompetitorAnalysisListRelationFilter
    suggestedCompetitors?: SuggestedCompetitorListRelationFilter
    analysisPhases?: AnalysisPhaseListRelationFilter
    semanticAnalyses?: SemanticAnalysisListRelationFilter
    keywordAnalyses?: KeywordAnalysisListRelationFilter
    searchVolumeClassifications?: SearchVolumeClassificationListRelationFilter
    intentClassifications?: IntentClassificationListRelationFilter
    communityInsights?: CommunityInsightListRelationFilter
    searchPatterns?: SearchPatternListRelationFilter
    intentPhraseGenerations?: IntentPhraseGenerationListRelationFilter
    communityMiningResults?: CommunityMiningResultListRelationFilter
    searchPatternResults?: SearchPatternResultListRelationFilter
    intentClassificationResults?: IntentClassificationResultListRelationFilter
    generatedIntentPhrases?: GeneratedIntentPhraseListRelationFilter
    relevanceScoreResults?: RelevanceScoreResultListRelationFilter
  }

  export type DomainOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    context?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: SortOrderInput | SortOrder
    customKeywords?: SortOrderInput | SortOrder
    intentPhrases?: SortOrderInput | SortOrder
    chatModel?: SortOrderInput | SortOrder
    runAllModels?: SortOrder
    locationContext?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    crawlResults?: CrawlResultOrderByRelationAggregateInput
    keywords?: KeywordOrderByRelationAggregateInput
    dashboardAnalyses?: DashboardAnalysisOrderByRelationAggregateInput
    competitorAnalyses?: CompetitorAnalysisOrderByRelationAggregateInput
    suggestedCompetitors?: SuggestedCompetitorOrderByRelationAggregateInput
    analysisPhases?: AnalysisPhaseOrderByRelationAggregateInput
    semanticAnalyses?: SemanticAnalysisOrderByRelationAggregateInput
    keywordAnalyses?: KeywordAnalysisOrderByRelationAggregateInput
    searchVolumeClassifications?: SearchVolumeClassificationOrderByRelationAggregateInput
    intentClassifications?: IntentClassificationOrderByRelationAggregateInput
    communityInsights?: CommunityInsightOrderByRelationAggregateInput
    searchPatterns?: SearchPatternOrderByRelationAggregateInput
    intentPhraseGenerations?: IntentPhraseGenerationOrderByRelationAggregateInput
    communityMiningResults?: CommunityMiningResultOrderByRelationAggregateInput
    searchPatternResults?: SearchPatternResultOrderByRelationAggregateInput
    intentClassificationResults?: IntentClassificationResultOrderByRelationAggregateInput
    generatedIntentPhrases?: GeneratedIntentPhraseOrderByRelationAggregateInput
    relevanceScoreResults?: RelevanceScoreResultOrderByRelationAggregateInput
  }

  export type DomainWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    url?: string
    AND?: DomainWhereInput | DomainWhereInput[]
    OR?: DomainWhereInput[]
    NOT?: DomainWhereInput | DomainWhereInput[]
    context?: StringNullableFilter<"Domain"> | string | null
    userId?: IntNullableFilter<"Domain"> | number | null
    createdAt?: DateTimeFilter<"Domain"> | Date | string
    updatedAt?: DateTimeFilter<"Domain"> | Date | string
    location?: StringNullableFilter<"Domain"> | string | null
    customKeywords?: StringNullableFilter<"Domain"> | string | null
    intentPhrases?: StringNullableFilter<"Domain"> | string | null
    chatModel?: StringNullableFilter<"Domain"> | string | null
    runAllModels?: BoolFilter<"Domain"> | boolean
    locationContext?: StringNullableFilter<"Domain"> | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    crawlResults?: CrawlResultListRelationFilter
    keywords?: KeywordListRelationFilter
    dashboardAnalyses?: DashboardAnalysisListRelationFilter
    competitorAnalyses?: CompetitorAnalysisListRelationFilter
    suggestedCompetitors?: SuggestedCompetitorListRelationFilter
    analysisPhases?: AnalysisPhaseListRelationFilter
    semanticAnalyses?: SemanticAnalysisListRelationFilter
    keywordAnalyses?: KeywordAnalysisListRelationFilter
    searchVolumeClassifications?: SearchVolumeClassificationListRelationFilter
    intentClassifications?: IntentClassificationListRelationFilter
    communityInsights?: CommunityInsightListRelationFilter
    searchPatterns?: SearchPatternListRelationFilter
    intentPhraseGenerations?: IntentPhraseGenerationListRelationFilter
    communityMiningResults?: CommunityMiningResultListRelationFilter
    searchPatternResults?: SearchPatternResultListRelationFilter
    intentClassificationResults?: IntentClassificationResultListRelationFilter
    generatedIntentPhrases?: GeneratedIntentPhraseListRelationFilter
    relevanceScoreResults?: RelevanceScoreResultListRelationFilter
  }, "id" | "url">

  export type DomainOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    context?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: SortOrderInput | SortOrder
    customKeywords?: SortOrderInput | SortOrder
    intentPhrases?: SortOrderInput | SortOrder
    chatModel?: SortOrderInput | SortOrder
    runAllModels?: SortOrder
    locationContext?: SortOrderInput | SortOrder
    _count?: DomainCountOrderByAggregateInput
    _avg?: DomainAvgOrderByAggregateInput
    _max?: DomainMaxOrderByAggregateInput
    _min?: DomainMinOrderByAggregateInput
    _sum?: DomainSumOrderByAggregateInput
  }

  export type DomainScalarWhereWithAggregatesInput = {
    AND?: DomainScalarWhereWithAggregatesInput | DomainScalarWhereWithAggregatesInput[]
    OR?: DomainScalarWhereWithAggregatesInput[]
    NOT?: DomainScalarWhereWithAggregatesInput | DomainScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Domain"> | number
    url?: StringWithAggregatesFilter<"Domain"> | string
    context?: StringNullableWithAggregatesFilter<"Domain"> | string | null
    userId?: IntNullableWithAggregatesFilter<"Domain"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Domain"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Domain"> | Date | string
    location?: StringNullableWithAggregatesFilter<"Domain"> | string | null
    customKeywords?: StringNullableWithAggregatesFilter<"Domain"> | string | null
    intentPhrases?: StringNullableWithAggregatesFilter<"Domain"> | string | null
    chatModel?: StringNullableWithAggregatesFilter<"Domain"> | string | null
    runAllModels?: BoolWithAggregatesFilter<"Domain"> | boolean
    locationContext?: StringNullableWithAggregatesFilter<"Domain"> | string | null
  }

  export type CrawlResultWhereInput = {
    AND?: CrawlResultWhereInput | CrawlResultWhereInput[]
    OR?: CrawlResultWhereInput[]
    NOT?: CrawlResultWhereInput | CrawlResultWhereInput[]
    id?: IntFilter<"CrawlResult"> | number
    domainId?: IntNullableFilter<"CrawlResult"> | number | null
    pagesScanned?: IntFilter<"CrawlResult"> | number
    analyzedUrls?: StringFilter<"CrawlResult"> | string
    extractedContext?: StringFilter<"CrawlResult"> | string
    tokenUsage?: IntNullableFilter<"CrawlResult"> | number | null
    createdAt?: DateTimeFilter<"CrawlResult"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
  }

  export type CrawlResultOrderByWithRelationInput = {
    id?: SortOrder
    domainId?: SortOrderInput | SortOrder
    pagesScanned?: SortOrder
    analyzedUrls?: SortOrder
    extractedContext?: SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    domain?: DomainOrderByWithRelationInput
  }

  export type CrawlResultWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CrawlResultWhereInput | CrawlResultWhereInput[]
    OR?: CrawlResultWhereInput[]
    NOT?: CrawlResultWhereInput | CrawlResultWhereInput[]
    domainId?: IntNullableFilter<"CrawlResult"> | number | null
    pagesScanned?: IntFilter<"CrawlResult"> | number
    analyzedUrls?: StringFilter<"CrawlResult"> | string
    extractedContext?: StringFilter<"CrawlResult"> | string
    tokenUsage?: IntNullableFilter<"CrawlResult"> | number | null
    createdAt?: DateTimeFilter<"CrawlResult"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
  }, "id">

  export type CrawlResultOrderByWithAggregationInput = {
    id?: SortOrder
    domainId?: SortOrderInput | SortOrder
    pagesScanned?: SortOrder
    analyzedUrls?: SortOrder
    extractedContext?: SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CrawlResultCountOrderByAggregateInput
    _avg?: CrawlResultAvgOrderByAggregateInput
    _max?: CrawlResultMaxOrderByAggregateInput
    _min?: CrawlResultMinOrderByAggregateInput
    _sum?: CrawlResultSumOrderByAggregateInput
  }

  export type CrawlResultScalarWhereWithAggregatesInput = {
    AND?: CrawlResultScalarWhereWithAggregatesInput | CrawlResultScalarWhereWithAggregatesInput[]
    OR?: CrawlResultScalarWhereWithAggregatesInput[]
    NOT?: CrawlResultScalarWhereWithAggregatesInput | CrawlResultScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CrawlResult"> | number
    domainId?: IntNullableWithAggregatesFilter<"CrawlResult"> | number | null
    pagesScanned?: IntWithAggregatesFilter<"CrawlResult"> | number
    analyzedUrls?: StringWithAggregatesFilter<"CrawlResult"> | string
    extractedContext?: StringWithAggregatesFilter<"CrawlResult"> | string
    tokenUsage?: IntNullableWithAggregatesFilter<"CrawlResult"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"CrawlResult"> | Date | string
  }

  export type KeywordWhereInput = {
    AND?: KeywordWhereInput | KeywordWhereInput[]
    OR?: KeywordWhereInput[]
    NOT?: KeywordWhereInput | KeywordWhereInput[]
    id?: IntFilter<"Keyword"> | number
    term?: StringFilter<"Keyword"> | string
    volume?: IntFilter<"Keyword"> | number
    difficulty?: StringFilter<"Keyword"> | string
    cpc?: FloatFilter<"Keyword"> | number
    intent?: StringNullableFilter<"Keyword"> | string | null
    domainId?: IntNullableFilter<"Keyword"> | number | null
    isSelected?: BoolFilter<"Keyword"> | boolean
    createdAt?: DateTimeFilter<"Keyword"> | Date | string
    updatedAt?: DateTimeFilter<"Keyword"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
    phrases?: PhraseListRelationFilter
    communityInsights?: CommunityInsightListRelationFilter
    searchPatterns?: SearchPatternListRelationFilter
    communityMiningResults?: CommunityMiningResultListRelationFilter
    searchPatternResults?: SearchPatternResultListRelationFilter
    intentClassificationResults?: IntentClassificationResultListRelationFilter
    generatedIntentPhrases?: GeneratedIntentPhraseListRelationFilter
  }

  export type KeywordOrderByWithRelationInput = {
    id?: SortOrder
    term?: SortOrder
    volume?: SortOrder
    difficulty?: SortOrder
    cpc?: SortOrder
    intent?: SortOrderInput | SortOrder
    domainId?: SortOrderInput | SortOrder
    isSelected?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    domain?: DomainOrderByWithRelationInput
    phrases?: PhraseOrderByRelationAggregateInput
    communityInsights?: CommunityInsightOrderByRelationAggregateInput
    searchPatterns?: SearchPatternOrderByRelationAggregateInput
    communityMiningResults?: CommunityMiningResultOrderByRelationAggregateInput
    searchPatternResults?: SearchPatternResultOrderByRelationAggregateInput
    intentClassificationResults?: IntentClassificationResultOrderByRelationAggregateInput
    generatedIntentPhrases?: GeneratedIntentPhraseOrderByRelationAggregateInput
  }

  export type KeywordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    term_domainId?: KeywordTermDomainIdCompoundUniqueInput
    AND?: KeywordWhereInput | KeywordWhereInput[]
    OR?: KeywordWhereInput[]
    NOT?: KeywordWhereInput | KeywordWhereInput[]
    term?: StringFilter<"Keyword"> | string
    volume?: IntFilter<"Keyword"> | number
    difficulty?: StringFilter<"Keyword"> | string
    cpc?: FloatFilter<"Keyword"> | number
    intent?: StringNullableFilter<"Keyword"> | string | null
    domainId?: IntNullableFilter<"Keyword"> | number | null
    isSelected?: BoolFilter<"Keyword"> | boolean
    createdAt?: DateTimeFilter<"Keyword"> | Date | string
    updatedAt?: DateTimeFilter<"Keyword"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
    phrases?: PhraseListRelationFilter
    communityInsights?: CommunityInsightListRelationFilter
    searchPatterns?: SearchPatternListRelationFilter
    communityMiningResults?: CommunityMiningResultListRelationFilter
    searchPatternResults?: SearchPatternResultListRelationFilter
    intentClassificationResults?: IntentClassificationResultListRelationFilter
    generatedIntentPhrases?: GeneratedIntentPhraseListRelationFilter
  }, "id" | "term_domainId">

  export type KeywordOrderByWithAggregationInput = {
    id?: SortOrder
    term?: SortOrder
    volume?: SortOrder
    difficulty?: SortOrder
    cpc?: SortOrder
    intent?: SortOrderInput | SortOrder
    domainId?: SortOrderInput | SortOrder
    isSelected?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KeywordCountOrderByAggregateInput
    _avg?: KeywordAvgOrderByAggregateInput
    _max?: KeywordMaxOrderByAggregateInput
    _min?: KeywordMinOrderByAggregateInput
    _sum?: KeywordSumOrderByAggregateInput
  }

  export type KeywordScalarWhereWithAggregatesInput = {
    AND?: KeywordScalarWhereWithAggregatesInput | KeywordScalarWhereWithAggregatesInput[]
    OR?: KeywordScalarWhereWithAggregatesInput[]
    NOT?: KeywordScalarWhereWithAggregatesInput | KeywordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Keyword"> | number
    term?: StringWithAggregatesFilter<"Keyword"> | string
    volume?: IntWithAggregatesFilter<"Keyword"> | number
    difficulty?: StringWithAggregatesFilter<"Keyword"> | string
    cpc?: FloatWithAggregatesFilter<"Keyword"> | number
    intent?: StringNullableWithAggregatesFilter<"Keyword"> | string | null
    domainId?: IntNullableWithAggregatesFilter<"Keyword"> | number | null
    isSelected?: BoolWithAggregatesFilter<"Keyword"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Keyword"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Keyword"> | Date | string
  }

  export type PhraseWhereInput = {
    AND?: PhraseWhereInput | PhraseWhereInput[]
    OR?: PhraseWhereInput[]
    NOT?: PhraseWhereInput | PhraseWhereInput[]
    id?: IntFilter<"Phrase"> | number
    text?: StringFilter<"Phrase"> | string
    keywordId?: IntFilter<"Phrase"> | number
    relevanceScore?: IntNullableFilter<"Phrase"> | number | null
    sources?: JsonNullableFilter<"Phrase">
    trend?: StringNullableFilter<"Phrase"> | string | null
    intent?: StringNullableFilter<"Phrase"> | string | null
    confidence?: IntNullableFilter<"Phrase"> | number | null
    isSelected?: BoolFilter<"Phrase"> | boolean
    createdAt?: DateTimeFilter<"Phrase"> | Date | string
    updatedAt?: DateTimeFilter<"Phrase"> | Date | string
    keyword?: XOR<KeywordRelationFilter, KeywordWhereInput>
    phraseIntentClassifications?: PhraseIntentClassificationListRelationFilter
    phraseScores?: PhraseScoreListRelationFilter
  }

  export type PhraseOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    keywordId?: SortOrder
    relevanceScore?: SortOrderInput | SortOrder
    sources?: SortOrderInput | SortOrder
    trend?: SortOrderInput | SortOrder
    intent?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    isSelected?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    keyword?: KeywordOrderByWithRelationInput
    phraseIntentClassifications?: PhraseIntentClassificationOrderByRelationAggregateInput
    phraseScores?: PhraseScoreOrderByRelationAggregateInput
  }

  export type PhraseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PhraseWhereInput | PhraseWhereInput[]
    OR?: PhraseWhereInput[]
    NOT?: PhraseWhereInput | PhraseWhereInput[]
    text?: StringFilter<"Phrase"> | string
    keywordId?: IntFilter<"Phrase"> | number
    relevanceScore?: IntNullableFilter<"Phrase"> | number | null
    sources?: JsonNullableFilter<"Phrase">
    trend?: StringNullableFilter<"Phrase"> | string | null
    intent?: StringNullableFilter<"Phrase"> | string | null
    confidence?: IntNullableFilter<"Phrase"> | number | null
    isSelected?: BoolFilter<"Phrase"> | boolean
    createdAt?: DateTimeFilter<"Phrase"> | Date | string
    updatedAt?: DateTimeFilter<"Phrase"> | Date | string
    keyword?: XOR<KeywordRelationFilter, KeywordWhereInput>
    phraseIntentClassifications?: PhraseIntentClassificationListRelationFilter
    phraseScores?: PhraseScoreListRelationFilter
  }, "id">

  export type PhraseOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    keywordId?: SortOrder
    relevanceScore?: SortOrderInput | SortOrder
    sources?: SortOrderInput | SortOrder
    trend?: SortOrderInput | SortOrder
    intent?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    isSelected?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PhraseCountOrderByAggregateInput
    _avg?: PhraseAvgOrderByAggregateInput
    _max?: PhraseMaxOrderByAggregateInput
    _min?: PhraseMinOrderByAggregateInput
    _sum?: PhraseSumOrderByAggregateInput
  }

  export type PhraseScalarWhereWithAggregatesInput = {
    AND?: PhraseScalarWhereWithAggregatesInput | PhraseScalarWhereWithAggregatesInput[]
    OR?: PhraseScalarWhereWithAggregatesInput[]
    NOT?: PhraseScalarWhereWithAggregatesInput | PhraseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Phrase"> | number
    text?: StringWithAggregatesFilter<"Phrase"> | string
    keywordId?: IntWithAggregatesFilter<"Phrase"> | number
    relevanceScore?: IntNullableWithAggregatesFilter<"Phrase"> | number | null
    sources?: JsonNullableWithAggregatesFilter<"Phrase">
    trend?: StringNullableWithAggregatesFilter<"Phrase"> | string | null
    intent?: StringNullableWithAggregatesFilter<"Phrase"> | string | null
    confidence?: IntNullableWithAggregatesFilter<"Phrase"> | number | null
    isSelected?: BoolWithAggregatesFilter<"Phrase"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Phrase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Phrase"> | Date | string
  }

  export type AIQueryResultWhereInput = {
    AND?: AIQueryResultWhereInput | AIQueryResultWhereInput[]
    OR?: AIQueryResultWhereInput[]
    NOT?: AIQueryResultWhereInput | AIQueryResultWhereInput[]
    id?: IntFilter<"AIQueryResult"> | number
    phraseId?: IntFilter<"AIQueryResult"> | number
    model?: StringFilter<"AIQueryResult"> | string
    response?: StringFilter<"AIQueryResult"> | string
    latency?: FloatFilter<"AIQueryResult"> | number
    cost?: FloatFilter<"AIQueryResult"> | number
    presence?: IntFilter<"AIQueryResult"> | number
    relevance?: IntFilter<"AIQueryResult"> | number
    accuracy?: IntFilter<"AIQueryResult"> | number
    sentiment?: IntFilter<"AIQueryResult"> | number
    overall?: FloatFilter<"AIQueryResult"> | number
    createdAt?: DateTimeFilter<"AIQueryResult"> | Date | string
    phrase?: XOR<GeneratedIntentPhraseRelationFilter, GeneratedIntentPhraseWhereInput>
  }

  export type AIQueryResultOrderByWithRelationInput = {
    id?: SortOrder
    phraseId?: SortOrder
    model?: SortOrder
    response?: SortOrder
    latency?: SortOrder
    cost?: SortOrder
    presence?: SortOrder
    relevance?: SortOrder
    accuracy?: SortOrder
    sentiment?: SortOrder
    overall?: SortOrder
    createdAt?: SortOrder
    phrase?: GeneratedIntentPhraseOrderByWithRelationInput
  }

  export type AIQueryResultWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AIQueryResultWhereInput | AIQueryResultWhereInput[]
    OR?: AIQueryResultWhereInput[]
    NOT?: AIQueryResultWhereInput | AIQueryResultWhereInput[]
    phraseId?: IntFilter<"AIQueryResult"> | number
    model?: StringFilter<"AIQueryResult"> | string
    response?: StringFilter<"AIQueryResult"> | string
    latency?: FloatFilter<"AIQueryResult"> | number
    cost?: FloatFilter<"AIQueryResult"> | number
    presence?: IntFilter<"AIQueryResult"> | number
    relevance?: IntFilter<"AIQueryResult"> | number
    accuracy?: IntFilter<"AIQueryResult"> | number
    sentiment?: IntFilter<"AIQueryResult"> | number
    overall?: FloatFilter<"AIQueryResult"> | number
    createdAt?: DateTimeFilter<"AIQueryResult"> | Date | string
    phrase?: XOR<GeneratedIntentPhraseRelationFilter, GeneratedIntentPhraseWhereInput>
  }, "id">

  export type AIQueryResultOrderByWithAggregationInput = {
    id?: SortOrder
    phraseId?: SortOrder
    model?: SortOrder
    response?: SortOrder
    latency?: SortOrder
    cost?: SortOrder
    presence?: SortOrder
    relevance?: SortOrder
    accuracy?: SortOrder
    sentiment?: SortOrder
    overall?: SortOrder
    createdAt?: SortOrder
    _count?: AIQueryResultCountOrderByAggregateInput
    _avg?: AIQueryResultAvgOrderByAggregateInput
    _max?: AIQueryResultMaxOrderByAggregateInput
    _min?: AIQueryResultMinOrderByAggregateInput
    _sum?: AIQueryResultSumOrderByAggregateInput
  }

  export type AIQueryResultScalarWhereWithAggregatesInput = {
    AND?: AIQueryResultScalarWhereWithAggregatesInput | AIQueryResultScalarWhereWithAggregatesInput[]
    OR?: AIQueryResultScalarWhereWithAggregatesInput[]
    NOT?: AIQueryResultScalarWhereWithAggregatesInput | AIQueryResultScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AIQueryResult"> | number
    phraseId?: IntWithAggregatesFilter<"AIQueryResult"> | number
    model?: StringWithAggregatesFilter<"AIQueryResult"> | string
    response?: StringWithAggregatesFilter<"AIQueryResult"> | string
    latency?: FloatWithAggregatesFilter<"AIQueryResult"> | number
    cost?: FloatWithAggregatesFilter<"AIQueryResult"> | number
    presence?: IntWithAggregatesFilter<"AIQueryResult"> | number
    relevance?: IntWithAggregatesFilter<"AIQueryResult"> | number
    accuracy?: IntWithAggregatesFilter<"AIQueryResult"> | number
    sentiment?: IntWithAggregatesFilter<"AIQueryResult"> | number
    overall?: FloatWithAggregatesFilter<"AIQueryResult"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AIQueryResult"> | Date | string
  }

  export type DashboardAnalysisWhereInput = {
    AND?: DashboardAnalysisWhereInput | DashboardAnalysisWhereInput[]
    OR?: DashboardAnalysisWhereInput[]
    NOT?: DashboardAnalysisWhereInput | DashboardAnalysisWhereInput[]
    id?: IntFilter<"DashboardAnalysis"> | number
    domainId?: IntNullableFilter<"DashboardAnalysis"> | number | null
    metrics?: JsonFilter<"DashboardAnalysis">
    insights?: JsonFilter<"DashboardAnalysis">
    industryAnalysis?: JsonFilter<"DashboardAnalysis">
    createdAt?: DateTimeFilter<"DashboardAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"DashboardAnalysis"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
  }

  export type DashboardAnalysisOrderByWithRelationInput = {
    id?: SortOrder
    domainId?: SortOrderInput | SortOrder
    metrics?: SortOrder
    insights?: SortOrder
    industryAnalysis?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    domain?: DomainOrderByWithRelationInput
  }

  export type DashboardAnalysisWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DashboardAnalysisWhereInput | DashboardAnalysisWhereInput[]
    OR?: DashboardAnalysisWhereInput[]
    NOT?: DashboardAnalysisWhereInput | DashboardAnalysisWhereInput[]
    domainId?: IntNullableFilter<"DashboardAnalysis"> | number | null
    metrics?: JsonFilter<"DashboardAnalysis">
    insights?: JsonFilter<"DashboardAnalysis">
    industryAnalysis?: JsonFilter<"DashboardAnalysis">
    createdAt?: DateTimeFilter<"DashboardAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"DashboardAnalysis"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
  }, "id">

  export type DashboardAnalysisOrderByWithAggregationInput = {
    id?: SortOrder
    domainId?: SortOrderInput | SortOrder
    metrics?: SortOrder
    insights?: SortOrder
    industryAnalysis?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DashboardAnalysisCountOrderByAggregateInput
    _avg?: DashboardAnalysisAvgOrderByAggregateInput
    _max?: DashboardAnalysisMaxOrderByAggregateInput
    _min?: DashboardAnalysisMinOrderByAggregateInput
    _sum?: DashboardAnalysisSumOrderByAggregateInput
  }

  export type DashboardAnalysisScalarWhereWithAggregatesInput = {
    AND?: DashboardAnalysisScalarWhereWithAggregatesInput | DashboardAnalysisScalarWhereWithAggregatesInput[]
    OR?: DashboardAnalysisScalarWhereWithAggregatesInput[]
    NOT?: DashboardAnalysisScalarWhereWithAggregatesInput | DashboardAnalysisScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DashboardAnalysis"> | number
    domainId?: IntNullableWithAggregatesFilter<"DashboardAnalysis"> | number | null
    metrics?: JsonWithAggregatesFilter<"DashboardAnalysis">
    insights?: JsonWithAggregatesFilter<"DashboardAnalysis">
    industryAnalysis?: JsonWithAggregatesFilter<"DashboardAnalysis">
    createdAt?: DateTimeWithAggregatesFilter<"DashboardAnalysis"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DashboardAnalysis"> | Date | string
  }

  export type CompetitorAnalysisWhereInput = {
    AND?: CompetitorAnalysisWhereInput | CompetitorAnalysisWhereInput[]
    OR?: CompetitorAnalysisWhereInput[]
    NOT?: CompetitorAnalysisWhereInput | CompetitorAnalysisWhereInput[]
    id?: IntFilter<"CompetitorAnalysis"> | number
    domainId?: IntNullableFilter<"CompetitorAnalysis"> | number | null
    competitors?: JsonFilter<"CompetitorAnalysis">
    marketInsights?: JsonFilter<"CompetitorAnalysis">
    strategicRecommendations?: JsonFilter<"CompetitorAnalysis">
    competitiveAnalysis?: JsonFilter<"CompetitorAnalysis">
    competitorList?: StringFilter<"CompetitorAnalysis"> | string
    createdAt?: DateTimeFilter<"CompetitorAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"CompetitorAnalysis"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
  }

  export type CompetitorAnalysisOrderByWithRelationInput = {
    id?: SortOrder
    domainId?: SortOrderInput | SortOrder
    competitors?: SortOrder
    marketInsights?: SortOrder
    strategicRecommendations?: SortOrder
    competitiveAnalysis?: SortOrder
    competitorList?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    domain?: DomainOrderByWithRelationInput
  }

  export type CompetitorAnalysisWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompetitorAnalysisWhereInput | CompetitorAnalysisWhereInput[]
    OR?: CompetitorAnalysisWhereInput[]
    NOT?: CompetitorAnalysisWhereInput | CompetitorAnalysisWhereInput[]
    domainId?: IntNullableFilter<"CompetitorAnalysis"> | number | null
    competitors?: JsonFilter<"CompetitorAnalysis">
    marketInsights?: JsonFilter<"CompetitorAnalysis">
    strategicRecommendations?: JsonFilter<"CompetitorAnalysis">
    competitiveAnalysis?: JsonFilter<"CompetitorAnalysis">
    competitorList?: StringFilter<"CompetitorAnalysis"> | string
    createdAt?: DateTimeFilter<"CompetitorAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"CompetitorAnalysis"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
  }, "id">

  export type CompetitorAnalysisOrderByWithAggregationInput = {
    id?: SortOrder
    domainId?: SortOrderInput | SortOrder
    competitors?: SortOrder
    marketInsights?: SortOrder
    strategicRecommendations?: SortOrder
    competitiveAnalysis?: SortOrder
    competitorList?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompetitorAnalysisCountOrderByAggregateInput
    _avg?: CompetitorAnalysisAvgOrderByAggregateInput
    _max?: CompetitorAnalysisMaxOrderByAggregateInput
    _min?: CompetitorAnalysisMinOrderByAggregateInput
    _sum?: CompetitorAnalysisSumOrderByAggregateInput
  }

  export type CompetitorAnalysisScalarWhereWithAggregatesInput = {
    AND?: CompetitorAnalysisScalarWhereWithAggregatesInput | CompetitorAnalysisScalarWhereWithAggregatesInput[]
    OR?: CompetitorAnalysisScalarWhereWithAggregatesInput[]
    NOT?: CompetitorAnalysisScalarWhereWithAggregatesInput | CompetitorAnalysisScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CompetitorAnalysis"> | number
    domainId?: IntNullableWithAggregatesFilter<"CompetitorAnalysis"> | number | null
    competitors?: JsonWithAggregatesFilter<"CompetitorAnalysis">
    marketInsights?: JsonWithAggregatesFilter<"CompetitorAnalysis">
    strategicRecommendations?: JsonWithAggregatesFilter<"CompetitorAnalysis">
    competitiveAnalysis?: JsonWithAggregatesFilter<"CompetitorAnalysis">
    competitorList?: StringWithAggregatesFilter<"CompetitorAnalysis"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CompetitorAnalysis"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompetitorAnalysis"> | Date | string
  }

  export type SuggestedCompetitorWhereInput = {
    AND?: SuggestedCompetitorWhereInput | SuggestedCompetitorWhereInput[]
    OR?: SuggestedCompetitorWhereInput[]
    NOT?: SuggestedCompetitorWhereInput | SuggestedCompetitorWhereInput[]
    id?: IntFilter<"SuggestedCompetitor"> | number
    domainId?: IntNullableFilter<"SuggestedCompetitor"> | number | null
    name?: StringFilter<"SuggestedCompetitor"> | string
    competitorDomain?: StringFilter<"SuggestedCompetitor"> | string
    reason?: StringFilter<"SuggestedCompetitor"> | string
    type?: StringFilter<"SuggestedCompetitor"> | string
    createdAt?: DateTimeFilter<"SuggestedCompetitor"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
  }

  export type SuggestedCompetitorOrderByWithRelationInput = {
    id?: SortOrder
    domainId?: SortOrderInput | SortOrder
    name?: SortOrder
    competitorDomain?: SortOrder
    reason?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    domain?: DomainOrderByWithRelationInput
  }

  export type SuggestedCompetitorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SuggestedCompetitorWhereInput | SuggestedCompetitorWhereInput[]
    OR?: SuggestedCompetitorWhereInput[]
    NOT?: SuggestedCompetitorWhereInput | SuggestedCompetitorWhereInput[]
    domainId?: IntNullableFilter<"SuggestedCompetitor"> | number | null
    name?: StringFilter<"SuggestedCompetitor"> | string
    competitorDomain?: StringFilter<"SuggestedCompetitor"> | string
    reason?: StringFilter<"SuggestedCompetitor"> | string
    type?: StringFilter<"SuggestedCompetitor"> | string
    createdAt?: DateTimeFilter<"SuggestedCompetitor"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
  }, "id">

  export type SuggestedCompetitorOrderByWithAggregationInput = {
    id?: SortOrder
    domainId?: SortOrderInput | SortOrder
    name?: SortOrder
    competitorDomain?: SortOrder
    reason?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: SuggestedCompetitorCountOrderByAggregateInput
    _avg?: SuggestedCompetitorAvgOrderByAggregateInput
    _max?: SuggestedCompetitorMaxOrderByAggregateInput
    _min?: SuggestedCompetitorMinOrderByAggregateInput
    _sum?: SuggestedCompetitorSumOrderByAggregateInput
  }

  export type SuggestedCompetitorScalarWhereWithAggregatesInput = {
    AND?: SuggestedCompetitorScalarWhereWithAggregatesInput | SuggestedCompetitorScalarWhereWithAggregatesInput[]
    OR?: SuggestedCompetitorScalarWhereWithAggregatesInput[]
    NOT?: SuggestedCompetitorScalarWhereWithAggregatesInput | SuggestedCompetitorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SuggestedCompetitor"> | number
    domainId?: IntNullableWithAggregatesFilter<"SuggestedCompetitor"> | number | null
    name?: StringWithAggregatesFilter<"SuggestedCompetitor"> | string
    competitorDomain?: StringWithAggregatesFilter<"SuggestedCompetitor"> | string
    reason?: StringWithAggregatesFilter<"SuggestedCompetitor"> | string
    type?: StringWithAggregatesFilter<"SuggestedCompetitor"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SuggestedCompetitor"> | Date | string
  }

  export type AnalysisPhaseWhereInput = {
    AND?: AnalysisPhaseWhereInput | AnalysisPhaseWhereInput[]
    OR?: AnalysisPhaseWhereInput[]
    NOT?: AnalysisPhaseWhereInput | AnalysisPhaseWhereInput[]
    id?: IntFilter<"AnalysisPhase"> | number
    domainId?: IntNullableFilter<"AnalysisPhase"> | number | null
    phase?: StringFilter<"AnalysisPhase"> | string
    status?: StringFilter<"AnalysisPhase"> | string
    progress?: IntFilter<"AnalysisPhase"> | number
    startTime?: DateTimeNullableFilter<"AnalysisPhase"> | Date | string | null
    endTime?: DateTimeNullableFilter<"AnalysisPhase"> | Date | string | null
    result?: JsonNullableFilter<"AnalysisPhase">
    error?: StringNullableFilter<"AnalysisPhase"> | string | null
    tokenUsage?: IntNullableFilter<"AnalysisPhase"> | number | null
    createdAt?: DateTimeFilter<"AnalysisPhase"> | Date | string
    updatedAt?: DateTimeFilter<"AnalysisPhase"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
  }

  export type AnalysisPhaseOrderByWithRelationInput = {
    id?: SortOrder
    domainId?: SortOrderInput | SortOrder
    phase?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    domain?: DomainOrderByWithRelationInput
  }

  export type AnalysisPhaseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    domainId_phase?: AnalysisPhaseDomainIdPhaseCompoundUniqueInput
    AND?: AnalysisPhaseWhereInput | AnalysisPhaseWhereInput[]
    OR?: AnalysisPhaseWhereInput[]
    NOT?: AnalysisPhaseWhereInput | AnalysisPhaseWhereInput[]
    domainId?: IntNullableFilter<"AnalysisPhase"> | number | null
    phase?: StringFilter<"AnalysisPhase"> | string
    status?: StringFilter<"AnalysisPhase"> | string
    progress?: IntFilter<"AnalysisPhase"> | number
    startTime?: DateTimeNullableFilter<"AnalysisPhase"> | Date | string | null
    endTime?: DateTimeNullableFilter<"AnalysisPhase"> | Date | string | null
    result?: JsonNullableFilter<"AnalysisPhase">
    error?: StringNullableFilter<"AnalysisPhase"> | string | null
    tokenUsage?: IntNullableFilter<"AnalysisPhase"> | number | null
    createdAt?: DateTimeFilter<"AnalysisPhase"> | Date | string
    updatedAt?: DateTimeFilter<"AnalysisPhase"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
  }, "id" | "domainId_phase">

  export type AnalysisPhaseOrderByWithAggregationInput = {
    id?: SortOrder
    domainId?: SortOrderInput | SortOrder
    phase?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnalysisPhaseCountOrderByAggregateInput
    _avg?: AnalysisPhaseAvgOrderByAggregateInput
    _max?: AnalysisPhaseMaxOrderByAggregateInput
    _min?: AnalysisPhaseMinOrderByAggregateInput
    _sum?: AnalysisPhaseSumOrderByAggregateInput
  }

  export type AnalysisPhaseScalarWhereWithAggregatesInput = {
    AND?: AnalysisPhaseScalarWhereWithAggregatesInput | AnalysisPhaseScalarWhereWithAggregatesInput[]
    OR?: AnalysisPhaseScalarWhereWithAggregatesInput[]
    NOT?: AnalysisPhaseScalarWhereWithAggregatesInput | AnalysisPhaseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AnalysisPhase"> | number
    domainId?: IntNullableWithAggregatesFilter<"AnalysisPhase"> | number | null
    phase?: StringWithAggregatesFilter<"AnalysisPhase"> | string
    status?: StringWithAggregatesFilter<"AnalysisPhase"> | string
    progress?: IntWithAggregatesFilter<"AnalysisPhase"> | number
    startTime?: DateTimeNullableWithAggregatesFilter<"AnalysisPhase"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"AnalysisPhase"> | Date | string | null
    result?: JsonNullableWithAggregatesFilter<"AnalysisPhase">
    error?: StringNullableWithAggregatesFilter<"AnalysisPhase"> | string | null
    tokenUsage?: IntNullableWithAggregatesFilter<"AnalysisPhase"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"AnalysisPhase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AnalysisPhase"> | Date | string
  }

  export type SemanticAnalysisWhereInput = {
    AND?: SemanticAnalysisWhereInput | SemanticAnalysisWhereInput[]
    OR?: SemanticAnalysisWhereInput[]
    NOT?: SemanticAnalysisWhereInput | SemanticAnalysisWhereInput[]
    id?: IntFilter<"SemanticAnalysis"> | number
    domainId?: IntNullableFilter<"SemanticAnalysis"> | number | null
    contentSummary?: StringFilter<"SemanticAnalysis"> | string
    keyThemes?: JsonFilter<"SemanticAnalysis">
    brandVoice?: StringFilter<"SemanticAnalysis"> | string
    targetAudience?: JsonFilter<"SemanticAnalysis">
    contentGaps?: JsonFilter<"SemanticAnalysis">
    tokenUsage?: IntNullableFilter<"SemanticAnalysis"> | number | null
    createdAt?: DateTimeFilter<"SemanticAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"SemanticAnalysis"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
  }

  export type SemanticAnalysisOrderByWithRelationInput = {
    id?: SortOrder
    domainId?: SortOrderInput | SortOrder
    contentSummary?: SortOrder
    keyThemes?: SortOrder
    brandVoice?: SortOrder
    targetAudience?: SortOrder
    contentGaps?: SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    domain?: DomainOrderByWithRelationInput
  }

  export type SemanticAnalysisWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SemanticAnalysisWhereInput | SemanticAnalysisWhereInput[]
    OR?: SemanticAnalysisWhereInput[]
    NOT?: SemanticAnalysisWhereInput | SemanticAnalysisWhereInput[]
    domainId?: IntNullableFilter<"SemanticAnalysis"> | number | null
    contentSummary?: StringFilter<"SemanticAnalysis"> | string
    keyThemes?: JsonFilter<"SemanticAnalysis">
    brandVoice?: StringFilter<"SemanticAnalysis"> | string
    targetAudience?: JsonFilter<"SemanticAnalysis">
    contentGaps?: JsonFilter<"SemanticAnalysis">
    tokenUsage?: IntNullableFilter<"SemanticAnalysis"> | number | null
    createdAt?: DateTimeFilter<"SemanticAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"SemanticAnalysis"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
  }, "id">

  export type SemanticAnalysisOrderByWithAggregationInput = {
    id?: SortOrder
    domainId?: SortOrderInput | SortOrder
    contentSummary?: SortOrder
    keyThemes?: SortOrder
    brandVoice?: SortOrder
    targetAudience?: SortOrder
    contentGaps?: SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SemanticAnalysisCountOrderByAggregateInput
    _avg?: SemanticAnalysisAvgOrderByAggregateInput
    _max?: SemanticAnalysisMaxOrderByAggregateInput
    _min?: SemanticAnalysisMinOrderByAggregateInput
    _sum?: SemanticAnalysisSumOrderByAggregateInput
  }

  export type SemanticAnalysisScalarWhereWithAggregatesInput = {
    AND?: SemanticAnalysisScalarWhereWithAggregatesInput | SemanticAnalysisScalarWhereWithAggregatesInput[]
    OR?: SemanticAnalysisScalarWhereWithAggregatesInput[]
    NOT?: SemanticAnalysisScalarWhereWithAggregatesInput | SemanticAnalysisScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SemanticAnalysis"> | number
    domainId?: IntNullableWithAggregatesFilter<"SemanticAnalysis"> | number | null
    contentSummary?: StringWithAggregatesFilter<"SemanticAnalysis"> | string
    keyThemes?: JsonWithAggregatesFilter<"SemanticAnalysis">
    brandVoice?: StringWithAggregatesFilter<"SemanticAnalysis"> | string
    targetAudience?: JsonWithAggregatesFilter<"SemanticAnalysis">
    contentGaps?: JsonWithAggregatesFilter<"SemanticAnalysis">
    tokenUsage?: IntNullableWithAggregatesFilter<"SemanticAnalysis"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SemanticAnalysis"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SemanticAnalysis"> | Date | string
  }

  export type KeywordAnalysisWhereInput = {
    AND?: KeywordAnalysisWhereInput | KeywordAnalysisWhereInput[]
    OR?: KeywordAnalysisWhereInput[]
    NOT?: KeywordAnalysisWhereInput | KeywordAnalysisWhereInput[]
    id?: IntFilter<"KeywordAnalysis"> | number
    domainId?: IntNullableFilter<"KeywordAnalysis"> | number | null
    keywords?: JsonFilter<"KeywordAnalysis">
    searchVolumeData?: JsonFilter<"KeywordAnalysis">
    intentClassification?: JsonFilter<"KeywordAnalysis">
    competitiveAnalysis?: JsonFilter<"KeywordAnalysis">
    tokenUsage?: IntNullableFilter<"KeywordAnalysis"> | number | null
    createdAt?: DateTimeFilter<"KeywordAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"KeywordAnalysis"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
  }

  export type KeywordAnalysisOrderByWithRelationInput = {
    id?: SortOrder
    domainId?: SortOrderInput | SortOrder
    keywords?: SortOrder
    searchVolumeData?: SortOrder
    intentClassification?: SortOrder
    competitiveAnalysis?: SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    domain?: DomainOrderByWithRelationInput
  }

  export type KeywordAnalysisWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: KeywordAnalysisWhereInput | KeywordAnalysisWhereInput[]
    OR?: KeywordAnalysisWhereInput[]
    NOT?: KeywordAnalysisWhereInput | KeywordAnalysisWhereInput[]
    domainId?: IntNullableFilter<"KeywordAnalysis"> | number | null
    keywords?: JsonFilter<"KeywordAnalysis">
    searchVolumeData?: JsonFilter<"KeywordAnalysis">
    intentClassification?: JsonFilter<"KeywordAnalysis">
    competitiveAnalysis?: JsonFilter<"KeywordAnalysis">
    tokenUsage?: IntNullableFilter<"KeywordAnalysis"> | number | null
    createdAt?: DateTimeFilter<"KeywordAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"KeywordAnalysis"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
  }, "id">

  export type KeywordAnalysisOrderByWithAggregationInput = {
    id?: SortOrder
    domainId?: SortOrderInput | SortOrder
    keywords?: SortOrder
    searchVolumeData?: SortOrder
    intentClassification?: SortOrder
    competitiveAnalysis?: SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KeywordAnalysisCountOrderByAggregateInput
    _avg?: KeywordAnalysisAvgOrderByAggregateInput
    _max?: KeywordAnalysisMaxOrderByAggregateInput
    _min?: KeywordAnalysisMinOrderByAggregateInput
    _sum?: KeywordAnalysisSumOrderByAggregateInput
  }

  export type KeywordAnalysisScalarWhereWithAggregatesInput = {
    AND?: KeywordAnalysisScalarWhereWithAggregatesInput | KeywordAnalysisScalarWhereWithAggregatesInput[]
    OR?: KeywordAnalysisScalarWhereWithAggregatesInput[]
    NOT?: KeywordAnalysisScalarWhereWithAggregatesInput | KeywordAnalysisScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"KeywordAnalysis"> | number
    domainId?: IntNullableWithAggregatesFilter<"KeywordAnalysis"> | number | null
    keywords?: JsonWithAggregatesFilter<"KeywordAnalysis">
    searchVolumeData?: JsonWithAggregatesFilter<"KeywordAnalysis">
    intentClassification?: JsonWithAggregatesFilter<"KeywordAnalysis">
    competitiveAnalysis?: JsonWithAggregatesFilter<"KeywordAnalysis">
    tokenUsage?: IntNullableWithAggregatesFilter<"KeywordAnalysis"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"KeywordAnalysis"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KeywordAnalysis"> | Date | string
  }

  export type SearchVolumeClassificationWhereInput = {
    AND?: SearchVolumeClassificationWhereInput | SearchVolumeClassificationWhereInput[]
    OR?: SearchVolumeClassificationWhereInput[]
    NOT?: SearchVolumeClassificationWhereInput | SearchVolumeClassificationWhereInput[]
    id?: IntFilter<"SearchVolumeClassification"> | number
    domainId?: IntNullableFilter<"SearchVolumeClassification"> | number | null
    highVolumeKeywords?: JsonFilter<"SearchVolumeClassification">
    mediumVolumeKeywords?: JsonFilter<"SearchVolumeClassification">
    lowVolumeKeywords?: JsonFilter<"SearchVolumeClassification">
    volumeTrends?: JsonFilter<"SearchVolumeClassification">
    seasonalPatterns?: JsonFilter<"SearchVolumeClassification">
    tokenUsage?: IntNullableFilter<"SearchVolumeClassification"> | number | null
    createdAt?: DateTimeFilter<"SearchVolumeClassification"> | Date | string
    updatedAt?: DateTimeFilter<"SearchVolumeClassification"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
  }

  export type SearchVolumeClassificationOrderByWithRelationInput = {
    id?: SortOrder
    domainId?: SortOrderInput | SortOrder
    highVolumeKeywords?: SortOrder
    mediumVolumeKeywords?: SortOrder
    lowVolumeKeywords?: SortOrder
    volumeTrends?: SortOrder
    seasonalPatterns?: SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    domain?: DomainOrderByWithRelationInput
  }

  export type SearchVolumeClassificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SearchVolumeClassificationWhereInput | SearchVolumeClassificationWhereInput[]
    OR?: SearchVolumeClassificationWhereInput[]
    NOT?: SearchVolumeClassificationWhereInput | SearchVolumeClassificationWhereInput[]
    domainId?: IntNullableFilter<"SearchVolumeClassification"> | number | null
    highVolumeKeywords?: JsonFilter<"SearchVolumeClassification">
    mediumVolumeKeywords?: JsonFilter<"SearchVolumeClassification">
    lowVolumeKeywords?: JsonFilter<"SearchVolumeClassification">
    volumeTrends?: JsonFilter<"SearchVolumeClassification">
    seasonalPatterns?: JsonFilter<"SearchVolumeClassification">
    tokenUsage?: IntNullableFilter<"SearchVolumeClassification"> | number | null
    createdAt?: DateTimeFilter<"SearchVolumeClassification"> | Date | string
    updatedAt?: DateTimeFilter<"SearchVolumeClassification"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
  }, "id">

  export type SearchVolumeClassificationOrderByWithAggregationInput = {
    id?: SortOrder
    domainId?: SortOrderInput | SortOrder
    highVolumeKeywords?: SortOrder
    mediumVolumeKeywords?: SortOrder
    lowVolumeKeywords?: SortOrder
    volumeTrends?: SortOrder
    seasonalPatterns?: SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SearchVolumeClassificationCountOrderByAggregateInput
    _avg?: SearchVolumeClassificationAvgOrderByAggregateInput
    _max?: SearchVolumeClassificationMaxOrderByAggregateInput
    _min?: SearchVolumeClassificationMinOrderByAggregateInput
    _sum?: SearchVolumeClassificationSumOrderByAggregateInput
  }

  export type SearchVolumeClassificationScalarWhereWithAggregatesInput = {
    AND?: SearchVolumeClassificationScalarWhereWithAggregatesInput | SearchVolumeClassificationScalarWhereWithAggregatesInput[]
    OR?: SearchVolumeClassificationScalarWhereWithAggregatesInput[]
    NOT?: SearchVolumeClassificationScalarWhereWithAggregatesInput | SearchVolumeClassificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SearchVolumeClassification"> | number
    domainId?: IntNullableWithAggregatesFilter<"SearchVolumeClassification"> | number | null
    highVolumeKeywords?: JsonWithAggregatesFilter<"SearchVolumeClassification">
    mediumVolumeKeywords?: JsonWithAggregatesFilter<"SearchVolumeClassification">
    lowVolumeKeywords?: JsonWithAggregatesFilter<"SearchVolumeClassification">
    volumeTrends?: JsonWithAggregatesFilter<"SearchVolumeClassification">
    seasonalPatterns?: JsonWithAggregatesFilter<"SearchVolumeClassification">
    tokenUsage?: IntNullableWithAggregatesFilter<"SearchVolumeClassification"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SearchVolumeClassification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SearchVolumeClassification"> | Date | string
  }

  export type IntentClassificationWhereInput = {
    AND?: IntentClassificationWhereInput | IntentClassificationWhereInput[]
    OR?: IntentClassificationWhereInput[]
    NOT?: IntentClassificationWhereInput | IntentClassificationWhereInput[]
    id?: IntFilter<"IntentClassification"> | number
    domainId?: IntNullableFilter<"IntentClassification"> | number | null
    informationalKeywords?: JsonFilter<"IntentClassification">
    navigationalKeywords?: JsonFilter<"IntentClassification">
    transactionalKeywords?: JsonFilter<"IntentClassification">
    commercialKeywords?: JsonFilter<"IntentClassification">
    intentDistribution?: JsonFilter<"IntentClassification">
    tokenUsage?: IntNullableFilter<"IntentClassification"> | number | null
    createdAt?: DateTimeFilter<"IntentClassification"> | Date | string
    updatedAt?: DateTimeFilter<"IntentClassification"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
  }

  export type IntentClassificationOrderByWithRelationInput = {
    id?: SortOrder
    domainId?: SortOrderInput | SortOrder
    informationalKeywords?: SortOrder
    navigationalKeywords?: SortOrder
    transactionalKeywords?: SortOrder
    commercialKeywords?: SortOrder
    intentDistribution?: SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    domain?: DomainOrderByWithRelationInput
  }

  export type IntentClassificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: IntentClassificationWhereInput | IntentClassificationWhereInput[]
    OR?: IntentClassificationWhereInput[]
    NOT?: IntentClassificationWhereInput | IntentClassificationWhereInput[]
    domainId?: IntNullableFilter<"IntentClassification"> | number | null
    informationalKeywords?: JsonFilter<"IntentClassification">
    navigationalKeywords?: JsonFilter<"IntentClassification">
    transactionalKeywords?: JsonFilter<"IntentClassification">
    commercialKeywords?: JsonFilter<"IntentClassification">
    intentDistribution?: JsonFilter<"IntentClassification">
    tokenUsage?: IntNullableFilter<"IntentClassification"> | number | null
    createdAt?: DateTimeFilter<"IntentClassification"> | Date | string
    updatedAt?: DateTimeFilter<"IntentClassification"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
  }, "id">

  export type IntentClassificationOrderByWithAggregationInput = {
    id?: SortOrder
    domainId?: SortOrderInput | SortOrder
    informationalKeywords?: SortOrder
    navigationalKeywords?: SortOrder
    transactionalKeywords?: SortOrder
    commercialKeywords?: SortOrder
    intentDistribution?: SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntentClassificationCountOrderByAggregateInput
    _avg?: IntentClassificationAvgOrderByAggregateInput
    _max?: IntentClassificationMaxOrderByAggregateInput
    _min?: IntentClassificationMinOrderByAggregateInput
    _sum?: IntentClassificationSumOrderByAggregateInput
  }

  export type IntentClassificationScalarWhereWithAggregatesInput = {
    AND?: IntentClassificationScalarWhereWithAggregatesInput | IntentClassificationScalarWhereWithAggregatesInput[]
    OR?: IntentClassificationScalarWhereWithAggregatesInput[]
    NOT?: IntentClassificationScalarWhereWithAggregatesInput | IntentClassificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"IntentClassification"> | number
    domainId?: IntNullableWithAggregatesFilter<"IntentClassification"> | number | null
    informationalKeywords?: JsonWithAggregatesFilter<"IntentClassification">
    navigationalKeywords?: JsonWithAggregatesFilter<"IntentClassification">
    transactionalKeywords?: JsonWithAggregatesFilter<"IntentClassification">
    commercialKeywords?: JsonWithAggregatesFilter<"IntentClassification">
    intentDistribution?: JsonWithAggregatesFilter<"IntentClassification">
    tokenUsage?: IntNullableWithAggregatesFilter<"IntentClassification"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"IntentClassification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IntentClassification"> | Date | string
  }

  export type CommunityInsightWhereInput = {
    AND?: CommunityInsightWhereInput | CommunityInsightWhereInput[]
    OR?: CommunityInsightWhereInput[]
    NOT?: CommunityInsightWhereInput | CommunityInsightWhereInput[]
    id?: IntFilter<"CommunityInsight"> | number
    domainId?: IntNullableFilter<"CommunityInsight"> | number | null
    keywordId?: IntNullableFilter<"CommunityInsight"> | number | null
    sources?: JsonFilter<"CommunityInsight">
    summary?: StringFilter<"CommunityInsight"> | string
    tokenUsage?: IntNullableFilter<"CommunityInsight"> | number | null
    createdAt?: DateTimeFilter<"CommunityInsight"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
    keyword?: XOR<KeywordNullableRelationFilter, KeywordWhereInput> | null
  }

  export type CommunityInsightOrderByWithRelationInput = {
    id?: SortOrder
    domainId?: SortOrderInput | SortOrder
    keywordId?: SortOrderInput | SortOrder
    sources?: SortOrder
    summary?: SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    domain?: DomainOrderByWithRelationInput
    keyword?: KeywordOrderByWithRelationInput
  }

  export type CommunityInsightWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommunityInsightWhereInput | CommunityInsightWhereInput[]
    OR?: CommunityInsightWhereInput[]
    NOT?: CommunityInsightWhereInput | CommunityInsightWhereInput[]
    domainId?: IntNullableFilter<"CommunityInsight"> | number | null
    keywordId?: IntNullableFilter<"CommunityInsight"> | number | null
    sources?: JsonFilter<"CommunityInsight">
    summary?: StringFilter<"CommunityInsight"> | string
    tokenUsage?: IntNullableFilter<"CommunityInsight"> | number | null
    createdAt?: DateTimeFilter<"CommunityInsight"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
    keyword?: XOR<KeywordNullableRelationFilter, KeywordWhereInput> | null
  }, "id">

  export type CommunityInsightOrderByWithAggregationInput = {
    id?: SortOrder
    domainId?: SortOrderInput | SortOrder
    keywordId?: SortOrderInput | SortOrder
    sources?: SortOrder
    summary?: SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CommunityInsightCountOrderByAggregateInput
    _avg?: CommunityInsightAvgOrderByAggregateInput
    _max?: CommunityInsightMaxOrderByAggregateInput
    _min?: CommunityInsightMinOrderByAggregateInput
    _sum?: CommunityInsightSumOrderByAggregateInput
  }

  export type CommunityInsightScalarWhereWithAggregatesInput = {
    AND?: CommunityInsightScalarWhereWithAggregatesInput | CommunityInsightScalarWhereWithAggregatesInput[]
    OR?: CommunityInsightScalarWhereWithAggregatesInput[]
    NOT?: CommunityInsightScalarWhereWithAggregatesInput | CommunityInsightScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CommunityInsight"> | number
    domainId?: IntNullableWithAggregatesFilter<"CommunityInsight"> | number | null
    keywordId?: IntNullableWithAggregatesFilter<"CommunityInsight"> | number | null
    sources?: JsonWithAggregatesFilter<"CommunityInsight">
    summary?: StringWithAggregatesFilter<"CommunityInsight"> | string
    tokenUsage?: IntNullableWithAggregatesFilter<"CommunityInsight"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"CommunityInsight"> | Date | string
  }

  export type SearchPatternWhereInput = {
    AND?: SearchPatternWhereInput | SearchPatternWhereInput[]
    OR?: SearchPatternWhereInput[]
    NOT?: SearchPatternWhereInput | SearchPatternWhereInput[]
    id?: IntFilter<"SearchPattern"> | number
    domainId?: IntNullableFilter<"SearchPattern"> | number | null
    keywordId?: IntNullableFilter<"SearchPattern"> | number | null
    patterns?: JsonFilter<"SearchPattern">
    summary?: StringFilter<"SearchPattern"> | string
    tokenUsage?: IntNullableFilter<"SearchPattern"> | number | null
    createdAt?: DateTimeFilter<"SearchPattern"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
    keyword?: XOR<KeywordNullableRelationFilter, KeywordWhereInput> | null
  }

  export type SearchPatternOrderByWithRelationInput = {
    id?: SortOrder
    domainId?: SortOrderInput | SortOrder
    keywordId?: SortOrderInput | SortOrder
    patterns?: SortOrder
    summary?: SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    domain?: DomainOrderByWithRelationInput
    keyword?: KeywordOrderByWithRelationInput
  }

  export type SearchPatternWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SearchPatternWhereInput | SearchPatternWhereInput[]
    OR?: SearchPatternWhereInput[]
    NOT?: SearchPatternWhereInput | SearchPatternWhereInput[]
    domainId?: IntNullableFilter<"SearchPattern"> | number | null
    keywordId?: IntNullableFilter<"SearchPattern"> | number | null
    patterns?: JsonFilter<"SearchPattern">
    summary?: StringFilter<"SearchPattern"> | string
    tokenUsage?: IntNullableFilter<"SearchPattern"> | number | null
    createdAt?: DateTimeFilter<"SearchPattern"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
    keyword?: XOR<KeywordNullableRelationFilter, KeywordWhereInput> | null
  }, "id">

  export type SearchPatternOrderByWithAggregationInput = {
    id?: SortOrder
    domainId?: SortOrderInput | SortOrder
    keywordId?: SortOrderInput | SortOrder
    patterns?: SortOrder
    summary?: SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SearchPatternCountOrderByAggregateInput
    _avg?: SearchPatternAvgOrderByAggregateInput
    _max?: SearchPatternMaxOrderByAggregateInput
    _min?: SearchPatternMinOrderByAggregateInput
    _sum?: SearchPatternSumOrderByAggregateInput
  }

  export type SearchPatternScalarWhereWithAggregatesInput = {
    AND?: SearchPatternScalarWhereWithAggregatesInput | SearchPatternScalarWhereWithAggregatesInput[]
    OR?: SearchPatternScalarWhereWithAggregatesInput[]
    NOT?: SearchPatternScalarWhereWithAggregatesInput | SearchPatternScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SearchPattern"> | number
    domainId?: IntNullableWithAggregatesFilter<"SearchPattern"> | number | null
    keywordId?: IntNullableWithAggregatesFilter<"SearchPattern"> | number | null
    patterns?: JsonWithAggregatesFilter<"SearchPattern">
    summary?: StringWithAggregatesFilter<"SearchPattern"> | string
    tokenUsage?: IntNullableWithAggregatesFilter<"SearchPattern"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SearchPattern"> | Date | string
  }

  export type PhraseIntentClassificationWhereInput = {
    AND?: PhraseIntentClassificationWhereInput | PhraseIntentClassificationWhereInput[]
    OR?: PhraseIntentClassificationWhereInput[]
    NOT?: PhraseIntentClassificationWhereInput | PhraseIntentClassificationWhereInput[]
    id?: IntFilter<"PhraseIntentClassification"> | number
    phraseId?: IntFilter<"PhraseIntentClassification"> | number
    intent?: StringFilter<"PhraseIntentClassification"> | string
    confidence?: IntNullableFilter<"PhraseIntentClassification"> | number | null
    createdAt?: DateTimeFilter<"PhraseIntentClassification"> | Date | string
    phrase?: XOR<PhraseRelationFilter, PhraseWhereInput>
  }

  export type PhraseIntentClassificationOrderByWithRelationInput = {
    id?: SortOrder
    phraseId?: SortOrder
    intent?: SortOrder
    confidence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    phrase?: PhraseOrderByWithRelationInput
  }

  export type PhraseIntentClassificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PhraseIntentClassificationWhereInput | PhraseIntentClassificationWhereInput[]
    OR?: PhraseIntentClassificationWhereInput[]
    NOT?: PhraseIntentClassificationWhereInput | PhraseIntentClassificationWhereInput[]
    phraseId?: IntFilter<"PhraseIntentClassification"> | number
    intent?: StringFilter<"PhraseIntentClassification"> | string
    confidence?: IntNullableFilter<"PhraseIntentClassification"> | number | null
    createdAt?: DateTimeFilter<"PhraseIntentClassification"> | Date | string
    phrase?: XOR<PhraseRelationFilter, PhraseWhereInput>
  }, "id">

  export type PhraseIntentClassificationOrderByWithAggregationInput = {
    id?: SortOrder
    phraseId?: SortOrder
    intent?: SortOrder
    confidence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PhraseIntentClassificationCountOrderByAggregateInput
    _avg?: PhraseIntentClassificationAvgOrderByAggregateInput
    _max?: PhraseIntentClassificationMaxOrderByAggregateInput
    _min?: PhraseIntentClassificationMinOrderByAggregateInput
    _sum?: PhraseIntentClassificationSumOrderByAggregateInput
  }

  export type PhraseIntentClassificationScalarWhereWithAggregatesInput = {
    AND?: PhraseIntentClassificationScalarWhereWithAggregatesInput | PhraseIntentClassificationScalarWhereWithAggregatesInput[]
    OR?: PhraseIntentClassificationScalarWhereWithAggregatesInput[]
    NOT?: PhraseIntentClassificationScalarWhereWithAggregatesInput | PhraseIntentClassificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PhraseIntentClassification"> | number
    phraseId?: IntWithAggregatesFilter<"PhraseIntentClassification"> | number
    intent?: StringWithAggregatesFilter<"PhraseIntentClassification"> | string
    confidence?: IntNullableWithAggregatesFilter<"PhraseIntentClassification"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"PhraseIntentClassification"> | Date | string
  }

  export type PhraseScoreWhereInput = {
    AND?: PhraseScoreWhereInput | PhraseScoreWhereInput[]
    OR?: PhraseScoreWhereInput[]
    NOT?: PhraseScoreWhereInput | PhraseScoreWhereInput[]
    id?: IntFilter<"PhraseScore"> | number
    phraseId?: IntFilter<"PhraseScore"> | number
    score?: IntFilter<"PhraseScore"> | number
    breakdown?: JsonNullableFilter<"PhraseScore">
    createdAt?: DateTimeFilter<"PhraseScore"> | Date | string
    phrase?: XOR<PhraseRelationFilter, PhraseWhereInput>
  }

  export type PhraseScoreOrderByWithRelationInput = {
    id?: SortOrder
    phraseId?: SortOrder
    score?: SortOrder
    breakdown?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    phrase?: PhraseOrderByWithRelationInput
  }

  export type PhraseScoreWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PhraseScoreWhereInput | PhraseScoreWhereInput[]
    OR?: PhraseScoreWhereInput[]
    NOT?: PhraseScoreWhereInput | PhraseScoreWhereInput[]
    phraseId?: IntFilter<"PhraseScore"> | number
    score?: IntFilter<"PhraseScore"> | number
    breakdown?: JsonNullableFilter<"PhraseScore">
    createdAt?: DateTimeFilter<"PhraseScore"> | Date | string
    phrase?: XOR<PhraseRelationFilter, PhraseWhereInput>
  }, "id">

  export type PhraseScoreOrderByWithAggregationInput = {
    id?: SortOrder
    phraseId?: SortOrder
    score?: SortOrder
    breakdown?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PhraseScoreCountOrderByAggregateInput
    _avg?: PhraseScoreAvgOrderByAggregateInput
    _max?: PhraseScoreMaxOrderByAggregateInput
    _min?: PhraseScoreMinOrderByAggregateInput
    _sum?: PhraseScoreSumOrderByAggregateInput
  }

  export type PhraseScoreScalarWhereWithAggregatesInput = {
    AND?: PhraseScoreScalarWhereWithAggregatesInput | PhraseScoreScalarWhereWithAggregatesInput[]
    OR?: PhraseScoreScalarWhereWithAggregatesInput[]
    NOT?: PhraseScoreScalarWhereWithAggregatesInput | PhraseScoreScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PhraseScore"> | number
    phraseId?: IntWithAggregatesFilter<"PhraseScore"> | number
    score?: IntWithAggregatesFilter<"PhraseScore"> | number
    breakdown?: JsonNullableWithAggregatesFilter<"PhraseScore">
    createdAt?: DateTimeWithAggregatesFilter<"PhraseScore"> | Date | string
  }

  export type IntentPhraseGenerationWhereInput = {
    AND?: IntentPhraseGenerationWhereInput | IntentPhraseGenerationWhereInput[]
    OR?: IntentPhraseGenerationWhereInput[]
    NOT?: IntentPhraseGenerationWhereInput | IntentPhraseGenerationWhereInput[]
    id?: IntFilter<"IntentPhraseGeneration"> | number
    domainId?: IntFilter<"IntentPhraseGeneration"> | number
    status?: StringFilter<"IntentPhraseGeneration"> | string
    phase?: StringFilter<"IntentPhraseGeneration"> | string
    progress?: IntFilter<"IntentPhraseGeneration"> | number
    startTime?: DateTimeFilter<"IntentPhraseGeneration"> | Date | string
    endTime?: DateTimeNullableFilter<"IntentPhraseGeneration"> | Date | string | null
    result?: JsonNullableFilter<"IntentPhraseGeneration">
    error?: StringNullableFilter<"IntentPhraseGeneration"> | string | null
    tokenUsage?: IntNullableFilter<"IntentPhraseGeneration"> | number | null
    createdAt?: DateTimeFilter<"IntentPhraseGeneration"> | Date | string
    updatedAt?: DateTimeFilter<"IntentPhraseGeneration"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
  }

  export type IntentPhraseGenerationOrderByWithRelationInput = {
    id?: SortOrder
    domainId?: SortOrder
    status?: SortOrder
    phase?: SortOrder
    progress?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    domain?: DomainOrderByWithRelationInput
  }

  export type IntentPhraseGenerationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: IntentPhraseGenerationWhereInput | IntentPhraseGenerationWhereInput[]
    OR?: IntentPhraseGenerationWhereInput[]
    NOT?: IntentPhraseGenerationWhereInput | IntentPhraseGenerationWhereInput[]
    domainId?: IntFilter<"IntentPhraseGeneration"> | number
    status?: StringFilter<"IntentPhraseGeneration"> | string
    phase?: StringFilter<"IntentPhraseGeneration"> | string
    progress?: IntFilter<"IntentPhraseGeneration"> | number
    startTime?: DateTimeFilter<"IntentPhraseGeneration"> | Date | string
    endTime?: DateTimeNullableFilter<"IntentPhraseGeneration"> | Date | string | null
    result?: JsonNullableFilter<"IntentPhraseGeneration">
    error?: StringNullableFilter<"IntentPhraseGeneration"> | string | null
    tokenUsage?: IntNullableFilter<"IntentPhraseGeneration"> | number | null
    createdAt?: DateTimeFilter<"IntentPhraseGeneration"> | Date | string
    updatedAt?: DateTimeFilter<"IntentPhraseGeneration"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
  }, "id">

  export type IntentPhraseGenerationOrderByWithAggregationInput = {
    id?: SortOrder
    domainId?: SortOrder
    status?: SortOrder
    phase?: SortOrder
    progress?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntentPhraseGenerationCountOrderByAggregateInput
    _avg?: IntentPhraseGenerationAvgOrderByAggregateInput
    _max?: IntentPhraseGenerationMaxOrderByAggregateInput
    _min?: IntentPhraseGenerationMinOrderByAggregateInput
    _sum?: IntentPhraseGenerationSumOrderByAggregateInput
  }

  export type IntentPhraseGenerationScalarWhereWithAggregatesInput = {
    AND?: IntentPhraseGenerationScalarWhereWithAggregatesInput | IntentPhraseGenerationScalarWhereWithAggregatesInput[]
    OR?: IntentPhraseGenerationScalarWhereWithAggregatesInput[]
    NOT?: IntentPhraseGenerationScalarWhereWithAggregatesInput | IntentPhraseGenerationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"IntentPhraseGeneration"> | number
    domainId?: IntWithAggregatesFilter<"IntentPhraseGeneration"> | number
    status?: StringWithAggregatesFilter<"IntentPhraseGeneration"> | string
    phase?: StringWithAggregatesFilter<"IntentPhraseGeneration"> | string
    progress?: IntWithAggregatesFilter<"IntentPhraseGeneration"> | number
    startTime?: DateTimeWithAggregatesFilter<"IntentPhraseGeneration"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"IntentPhraseGeneration"> | Date | string | null
    result?: JsonNullableWithAggregatesFilter<"IntentPhraseGeneration">
    error?: StringNullableWithAggregatesFilter<"IntentPhraseGeneration"> | string | null
    tokenUsage?: IntNullableWithAggregatesFilter<"IntentPhraseGeneration"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"IntentPhraseGeneration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IntentPhraseGeneration"> | Date | string
  }

  export type CommunityMiningResultWhereInput = {
    AND?: CommunityMiningResultWhereInput | CommunityMiningResultWhereInput[]
    OR?: CommunityMiningResultWhereInput[]
    NOT?: CommunityMiningResultWhereInput | CommunityMiningResultWhereInput[]
    id?: IntFilter<"CommunityMiningResult"> | number
    domainId?: IntFilter<"CommunityMiningResult"> | number
    keywordId?: IntNullableFilter<"CommunityMiningResult"> | number | null
    platform?: StringFilter<"CommunityMiningResult"> | string
    insights?: JsonFilter<"CommunityMiningResult">
    sentiment?: StringNullableFilter<"CommunityMiningResult"> | string | null
    frequency?: IntNullableFilter<"CommunityMiningResult"> | number | null
    tokenUsage?: IntNullableFilter<"CommunityMiningResult"> | number | null
    createdAt?: DateTimeFilter<"CommunityMiningResult"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
    keyword?: XOR<KeywordNullableRelationFilter, KeywordWhereInput> | null
  }

  export type CommunityMiningResultOrderByWithRelationInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrderInput | SortOrder
    platform?: SortOrder
    insights?: SortOrder
    sentiment?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    domain?: DomainOrderByWithRelationInput
    keyword?: KeywordOrderByWithRelationInput
  }

  export type CommunityMiningResultWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommunityMiningResultWhereInput | CommunityMiningResultWhereInput[]
    OR?: CommunityMiningResultWhereInput[]
    NOT?: CommunityMiningResultWhereInput | CommunityMiningResultWhereInput[]
    domainId?: IntFilter<"CommunityMiningResult"> | number
    keywordId?: IntNullableFilter<"CommunityMiningResult"> | number | null
    platform?: StringFilter<"CommunityMiningResult"> | string
    insights?: JsonFilter<"CommunityMiningResult">
    sentiment?: StringNullableFilter<"CommunityMiningResult"> | string | null
    frequency?: IntNullableFilter<"CommunityMiningResult"> | number | null
    tokenUsage?: IntNullableFilter<"CommunityMiningResult"> | number | null
    createdAt?: DateTimeFilter<"CommunityMiningResult"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
    keyword?: XOR<KeywordNullableRelationFilter, KeywordWhereInput> | null
  }, "id">

  export type CommunityMiningResultOrderByWithAggregationInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrderInput | SortOrder
    platform?: SortOrder
    insights?: SortOrder
    sentiment?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CommunityMiningResultCountOrderByAggregateInput
    _avg?: CommunityMiningResultAvgOrderByAggregateInput
    _max?: CommunityMiningResultMaxOrderByAggregateInput
    _min?: CommunityMiningResultMinOrderByAggregateInput
    _sum?: CommunityMiningResultSumOrderByAggregateInput
  }

  export type CommunityMiningResultScalarWhereWithAggregatesInput = {
    AND?: CommunityMiningResultScalarWhereWithAggregatesInput | CommunityMiningResultScalarWhereWithAggregatesInput[]
    OR?: CommunityMiningResultScalarWhereWithAggregatesInput[]
    NOT?: CommunityMiningResultScalarWhereWithAggregatesInput | CommunityMiningResultScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CommunityMiningResult"> | number
    domainId?: IntWithAggregatesFilter<"CommunityMiningResult"> | number
    keywordId?: IntNullableWithAggregatesFilter<"CommunityMiningResult"> | number | null
    platform?: StringWithAggregatesFilter<"CommunityMiningResult"> | string
    insights?: JsonWithAggregatesFilter<"CommunityMiningResult">
    sentiment?: StringNullableWithAggregatesFilter<"CommunityMiningResult"> | string | null
    frequency?: IntNullableWithAggregatesFilter<"CommunityMiningResult"> | number | null
    tokenUsage?: IntNullableWithAggregatesFilter<"CommunityMiningResult"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"CommunityMiningResult"> | Date | string
  }

  export type SearchPatternResultWhereInput = {
    AND?: SearchPatternResultWhereInput | SearchPatternResultWhereInput[]
    OR?: SearchPatternResultWhereInput[]
    NOT?: SearchPatternResultWhereInput | SearchPatternResultWhereInput[]
    id?: IntFilter<"SearchPatternResult"> | number
    domainId?: IntFilter<"SearchPatternResult"> | number
    keywordId?: IntNullableFilter<"SearchPatternResult"> | number | null
    patterns?: JsonFilter<"SearchPatternResult">
    volume?: IntNullableFilter<"SearchPatternResult"> | number | null
    seasonality?: JsonNullableFilter<"SearchPatternResult">
    trends?: JsonNullableFilter<"SearchPatternResult">
    tokenUsage?: IntNullableFilter<"SearchPatternResult"> | number | null
    createdAt?: DateTimeFilter<"SearchPatternResult"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
    keyword?: XOR<KeywordNullableRelationFilter, KeywordWhereInput> | null
  }

  export type SearchPatternResultOrderByWithRelationInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrderInput | SortOrder
    patterns?: SortOrder
    volume?: SortOrderInput | SortOrder
    seasonality?: SortOrderInput | SortOrder
    trends?: SortOrderInput | SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    domain?: DomainOrderByWithRelationInput
    keyword?: KeywordOrderByWithRelationInput
  }

  export type SearchPatternResultWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SearchPatternResultWhereInput | SearchPatternResultWhereInput[]
    OR?: SearchPatternResultWhereInput[]
    NOT?: SearchPatternResultWhereInput | SearchPatternResultWhereInput[]
    domainId?: IntFilter<"SearchPatternResult"> | number
    keywordId?: IntNullableFilter<"SearchPatternResult"> | number | null
    patterns?: JsonFilter<"SearchPatternResult">
    volume?: IntNullableFilter<"SearchPatternResult"> | number | null
    seasonality?: JsonNullableFilter<"SearchPatternResult">
    trends?: JsonNullableFilter<"SearchPatternResult">
    tokenUsage?: IntNullableFilter<"SearchPatternResult"> | number | null
    createdAt?: DateTimeFilter<"SearchPatternResult"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
    keyword?: XOR<KeywordNullableRelationFilter, KeywordWhereInput> | null
  }, "id">

  export type SearchPatternResultOrderByWithAggregationInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrderInput | SortOrder
    patterns?: SortOrder
    volume?: SortOrderInput | SortOrder
    seasonality?: SortOrderInput | SortOrder
    trends?: SortOrderInput | SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SearchPatternResultCountOrderByAggregateInput
    _avg?: SearchPatternResultAvgOrderByAggregateInput
    _max?: SearchPatternResultMaxOrderByAggregateInput
    _min?: SearchPatternResultMinOrderByAggregateInput
    _sum?: SearchPatternResultSumOrderByAggregateInput
  }

  export type SearchPatternResultScalarWhereWithAggregatesInput = {
    AND?: SearchPatternResultScalarWhereWithAggregatesInput | SearchPatternResultScalarWhereWithAggregatesInput[]
    OR?: SearchPatternResultScalarWhereWithAggregatesInput[]
    NOT?: SearchPatternResultScalarWhereWithAggregatesInput | SearchPatternResultScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SearchPatternResult"> | number
    domainId?: IntWithAggregatesFilter<"SearchPatternResult"> | number
    keywordId?: IntNullableWithAggregatesFilter<"SearchPatternResult"> | number | null
    patterns?: JsonWithAggregatesFilter<"SearchPatternResult">
    volume?: IntNullableWithAggregatesFilter<"SearchPatternResult"> | number | null
    seasonality?: JsonNullableWithAggregatesFilter<"SearchPatternResult">
    trends?: JsonNullableWithAggregatesFilter<"SearchPatternResult">
    tokenUsage?: IntNullableWithAggregatesFilter<"SearchPatternResult"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SearchPatternResult"> | Date | string
  }

  export type IntentClassificationResultWhereInput = {
    AND?: IntentClassificationResultWhereInput | IntentClassificationResultWhereInput[]
    OR?: IntentClassificationResultWhereInput[]
    NOT?: IntentClassificationResultWhereInput | IntentClassificationResultWhereInput[]
    id?: IntFilter<"IntentClassificationResult"> | number
    domainId?: IntFilter<"IntentClassificationResult"> | number
    keywordId?: IntNullableFilter<"IntentClassificationResult"> | number | null
    intent?: StringFilter<"IntentClassificationResult"> | string
    confidence?: IntNullableFilter<"IntentClassificationResult"> | number | null
    patterns?: JsonNullableFilter<"IntentClassificationResult">
    tokenUsage?: IntNullableFilter<"IntentClassificationResult"> | number | null
    createdAt?: DateTimeFilter<"IntentClassificationResult"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
    keyword?: XOR<KeywordNullableRelationFilter, KeywordWhereInput> | null
  }

  export type IntentClassificationResultOrderByWithRelationInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrderInput | SortOrder
    intent?: SortOrder
    confidence?: SortOrderInput | SortOrder
    patterns?: SortOrderInput | SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    domain?: DomainOrderByWithRelationInput
    keyword?: KeywordOrderByWithRelationInput
  }

  export type IntentClassificationResultWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: IntentClassificationResultWhereInput | IntentClassificationResultWhereInput[]
    OR?: IntentClassificationResultWhereInput[]
    NOT?: IntentClassificationResultWhereInput | IntentClassificationResultWhereInput[]
    domainId?: IntFilter<"IntentClassificationResult"> | number
    keywordId?: IntNullableFilter<"IntentClassificationResult"> | number | null
    intent?: StringFilter<"IntentClassificationResult"> | string
    confidence?: IntNullableFilter<"IntentClassificationResult"> | number | null
    patterns?: JsonNullableFilter<"IntentClassificationResult">
    tokenUsage?: IntNullableFilter<"IntentClassificationResult"> | number | null
    createdAt?: DateTimeFilter<"IntentClassificationResult"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
    keyword?: XOR<KeywordNullableRelationFilter, KeywordWhereInput> | null
  }, "id">

  export type IntentClassificationResultOrderByWithAggregationInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrderInput | SortOrder
    intent?: SortOrder
    confidence?: SortOrderInput | SortOrder
    patterns?: SortOrderInput | SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: IntentClassificationResultCountOrderByAggregateInput
    _avg?: IntentClassificationResultAvgOrderByAggregateInput
    _max?: IntentClassificationResultMaxOrderByAggregateInput
    _min?: IntentClassificationResultMinOrderByAggregateInput
    _sum?: IntentClassificationResultSumOrderByAggregateInput
  }

  export type IntentClassificationResultScalarWhereWithAggregatesInput = {
    AND?: IntentClassificationResultScalarWhereWithAggregatesInput | IntentClassificationResultScalarWhereWithAggregatesInput[]
    OR?: IntentClassificationResultScalarWhereWithAggregatesInput[]
    NOT?: IntentClassificationResultScalarWhereWithAggregatesInput | IntentClassificationResultScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"IntentClassificationResult"> | number
    domainId?: IntWithAggregatesFilter<"IntentClassificationResult"> | number
    keywordId?: IntNullableWithAggregatesFilter<"IntentClassificationResult"> | number | null
    intent?: StringWithAggregatesFilter<"IntentClassificationResult"> | string
    confidence?: IntNullableWithAggregatesFilter<"IntentClassificationResult"> | number | null
    patterns?: JsonNullableWithAggregatesFilter<"IntentClassificationResult">
    tokenUsage?: IntNullableWithAggregatesFilter<"IntentClassificationResult"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"IntentClassificationResult"> | Date | string
  }

  export type GeneratedIntentPhraseWhereInput = {
    AND?: GeneratedIntentPhraseWhereInput | GeneratedIntentPhraseWhereInput[]
    OR?: GeneratedIntentPhraseWhereInput[]
    NOT?: GeneratedIntentPhraseWhereInput | GeneratedIntentPhraseWhereInput[]
    id?: IntFilter<"GeneratedIntentPhrase"> | number
    domainId?: IntFilter<"GeneratedIntentPhrase"> | number
    keywordId?: IntNullableFilter<"GeneratedIntentPhrase"> | number | null
    phrase?: StringFilter<"GeneratedIntentPhrase"> | string
    relevanceScore?: IntNullableFilter<"GeneratedIntentPhrase"> | number | null
    intent?: StringNullableFilter<"GeneratedIntentPhrase"> | string | null
    intentConfidence?: IntNullableFilter<"GeneratedIntentPhrase"> | number | null
    sources?: JsonNullableFilter<"GeneratedIntentPhrase">
    trend?: StringNullableFilter<"GeneratedIntentPhrase"> | string | null
    communityInsights?: JsonNullableFilter<"GeneratedIntentPhrase">
    searchPatterns?: JsonNullableFilter<"GeneratedIntentPhrase">
    isSelected?: BoolFilter<"GeneratedIntentPhrase"> | boolean
    tokenUsage?: IntNullableFilter<"GeneratedIntentPhrase"> | number | null
    createdAt?: DateTimeFilter<"GeneratedIntentPhrase"> | Date | string
    updatedAt?: DateTimeFilter<"GeneratedIntentPhrase"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
    keyword?: XOR<KeywordNullableRelationFilter, KeywordWhereInput> | null
    relevanceScoreResults?: RelevanceScoreResultListRelationFilter
    aiQueryResults?: AIQueryResultListRelationFilter
  }

  export type GeneratedIntentPhraseOrderByWithRelationInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrderInput | SortOrder
    phrase?: SortOrder
    relevanceScore?: SortOrderInput | SortOrder
    intent?: SortOrderInput | SortOrder
    intentConfidence?: SortOrderInput | SortOrder
    sources?: SortOrderInput | SortOrder
    trend?: SortOrderInput | SortOrder
    communityInsights?: SortOrderInput | SortOrder
    searchPatterns?: SortOrderInput | SortOrder
    isSelected?: SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    domain?: DomainOrderByWithRelationInput
    keyword?: KeywordOrderByWithRelationInput
    relevanceScoreResults?: RelevanceScoreResultOrderByRelationAggregateInput
    aiQueryResults?: AIQueryResultOrderByRelationAggregateInput
  }

  export type GeneratedIntentPhraseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GeneratedIntentPhraseWhereInput | GeneratedIntentPhraseWhereInput[]
    OR?: GeneratedIntentPhraseWhereInput[]
    NOT?: GeneratedIntentPhraseWhereInput | GeneratedIntentPhraseWhereInput[]
    domainId?: IntFilter<"GeneratedIntentPhrase"> | number
    keywordId?: IntNullableFilter<"GeneratedIntentPhrase"> | number | null
    phrase?: StringFilter<"GeneratedIntentPhrase"> | string
    relevanceScore?: IntNullableFilter<"GeneratedIntentPhrase"> | number | null
    intent?: StringNullableFilter<"GeneratedIntentPhrase"> | string | null
    intentConfidence?: IntNullableFilter<"GeneratedIntentPhrase"> | number | null
    sources?: JsonNullableFilter<"GeneratedIntentPhrase">
    trend?: StringNullableFilter<"GeneratedIntentPhrase"> | string | null
    communityInsights?: JsonNullableFilter<"GeneratedIntentPhrase">
    searchPatterns?: JsonNullableFilter<"GeneratedIntentPhrase">
    isSelected?: BoolFilter<"GeneratedIntentPhrase"> | boolean
    tokenUsage?: IntNullableFilter<"GeneratedIntentPhrase"> | number | null
    createdAt?: DateTimeFilter<"GeneratedIntentPhrase"> | Date | string
    updatedAt?: DateTimeFilter<"GeneratedIntentPhrase"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
    keyword?: XOR<KeywordNullableRelationFilter, KeywordWhereInput> | null
    relevanceScoreResults?: RelevanceScoreResultListRelationFilter
    aiQueryResults?: AIQueryResultListRelationFilter
  }, "id">

  export type GeneratedIntentPhraseOrderByWithAggregationInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrderInput | SortOrder
    phrase?: SortOrder
    relevanceScore?: SortOrderInput | SortOrder
    intent?: SortOrderInput | SortOrder
    intentConfidence?: SortOrderInput | SortOrder
    sources?: SortOrderInput | SortOrder
    trend?: SortOrderInput | SortOrder
    communityInsights?: SortOrderInput | SortOrder
    searchPatterns?: SortOrderInput | SortOrder
    isSelected?: SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GeneratedIntentPhraseCountOrderByAggregateInput
    _avg?: GeneratedIntentPhraseAvgOrderByAggregateInput
    _max?: GeneratedIntentPhraseMaxOrderByAggregateInput
    _min?: GeneratedIntentPhraseMinOrderByAggregateInput
    _sum?: GeneratedIntentPhraseSumOrderByAggregateInput
  }

  export type GeneratedIntentPhraseScalarWhereWithAggregatesInput = {
    AND?: GeneratedIntentPhraseScalarWhereWithAggregatesInput | GeneratedIntentPhraseScalarWhereWithAggregatesInput[]
    OR?: GeneratedIntentPhraseScalarWhereWithAggregatesInput[]
    NOT?: GeneratedIntentPhraseScalarWhereWithAggregatesInput | GeneratedIntentPhraseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GeneratedIntentPhrase"> | number
    domainId?: IntWithAggregatesFilter<"GeneratedIntentPhrase"> | number
    keywordId?: IntNullableWithAggregatesFilter<"GeneratedIntentPhrase"> | number | null
    phrase?: StringWithAggregatesFilter<"GeneratedIntentPhrase"> | string
    relevanceScore?: IntNullableWithAggregatesFilter<"GeneratedIntentPhrase"> | number | null
    intent?: StringNullableWithAggregatesFilter<"GeneratedIntentPhrase"> | string | null
    intentConfidence?: IntNullableWithAggregatesFilter<"GeneratedIntentPhrase"> | number | null
    sources?: JsonNullableWithAggregatesFilter<"GeneratedIntentPhrase">
    trend?: StringNullableWithAggregatesFilter<"GeneratedIntentPhrase"> | string | null
    communityInsights?: JsonNullableWithAggregatesFilter<"GeneratedIntentPhrase">
    searchPatterns?: JsonNullableWithAggregatesFilter<"GeneratedIntentPhrase">
    isSelected?: BoolWithAggregatesFilter<"GeneratedIntentPhrase"> | boolean
    tokenUsage?: IntNullableWithAggregatesFilter<"GeneratedIntentPhrase"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"GeneratedIntentPhrase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GeneratedIntentPhrase"> | Date | string
  }

  export type RelevanceScoreResultWhereInput = {
    AND?: RelevanceScoreResultWhereInput | RelevanceScoreResultWhereInput[]
    OR?: RelevanceScoreResultWhereInput[]
    NOT?: RelevanceScoreResultWhereInput | RelevanceScoreResultWhereInput[]
    id?: IntFilter<"RelevanceScoreResult"> | number
    domainId?: IntFilter<"RelevanceScoreResult"> | number
    phraseId?: IntNullableFilter<"RelevanceScoreResult"> | number | null
    score?: IntFilter<"RelevanceScoreResult"> | number
    breakdown?: JsonNullableFilter<"RelevanceScoreResult">
    factors?: JsonNullableFilter<"RelevanceScoreResult">
    tokenUsage?: IntNullableFilter<"RelevanceScoreResult"> | number | null
    createdAt?: DateTimeFilter<"RelevanceScoreResult"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
    phrase?: XOR<GeneratedIntentPhraseNullableRelationFilter, GeneratedIntentPhraseWhereInput> | null
  }

  export type RelevanceScoreResultOrderByWithRelationInput = {
    id?: SortOrder
    domainId?: SortOrder
    phraseId?: SortOrderInput | SortOrder
    score?: SortOrder
    breakdown?: SortOrderInput | SortOrder
    factors?: SortOrderInput | SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    domain?: DomainOrderByWithRelationInput
    phrase?: GeneratedIntentPhraseOrderByWithRelationInput
  }

  export type RelevanceScoreResultWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RelevanceScoreResultWhereInput | RelevanceScoreResultWhereInput[]
    OR?: RelevanceScoreResultWhereInput[]
    NOT?: RelevanceScoreResultWhereInput | RelevanceScoreResultWhereInput[]
    domainId?: IntFilter<"RelevanceScoreResult"> | number
    phraseId?: IntNullableFilter<"RelevanceScoreResult"> | number | null
    score?: IntFilter<"RelevanceScoreResult"> | number
    breakdown?: JsonNullableFilter<"RelevanceScoreResult">
    factors?: JsonNullableFilter<"RelevanceScoreResult">
    tokenUsage?: IntNullableFilter<"RelevanceScoreResult"> | number | null
    createdAt?: DateTimeFilter<"RelevanceScoreResult"> | Date | string
    domain?: XOR<DomainNullableRelationFilter, DomainWhereInput> | null
    phrase?: XOR<GeneratedIntentPhraseNullableRelationFilter, GeneratedIntentPhraseWhereInput> | null
  }, "id">

  export type RelevanceScoreResultOrderByWithAggregationInput = {
    id?: SortOrder
    domainId?: SortOrder
    phraseId?: SortOrderInput | SortOrder
    score?: SortOrder
    breakdown?: SortOrderInput | SortOrder
    factors?: SortOrderInput | SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RelevanceScoreResultCountOrderByAggregateInput
    _avg?: RelevanceScoreResultAvgOrderByAggregateInput
    _max?: RelevanceScoreResultMaxOrderByAggregateInput
    _min?: RelevanceScoreResultMinOrderByAggregateInput
    _sum?: RelevanceScoreResultSumOrderByAggregateInput
  }

  export type RelevanceScoreResultScalarWhereWithAggregatesInput = {
    AND?: RelevanceScoreResultScalarWhereWithAggregatesInput | RelevanceScoreResultScalarWhereWithAggregatesInput[]
    OR?: RelevanceScoreResultScalarWhereWithAggregatesInput[]
    NOT?: RelevanceScoreResultScalarWhereWithAggregatesInput | RelevanceScoreResultScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RelevanceScoreResult"> | number
    domainId?: IntWithAggregatesFilter<"RelevanceScoreResult"> | number
    phraseId?: IntNullableWithAggregatesFilter<"RelevanceScoreResult"> | number | null
    score?: IntWithAggregatesFilter<"RelevanceScoreResult"> | number
    breakdown?: JsonNullableWithAggregatesFilter<"RelevanceScoreResult">
    factors?: JsonNullableWithAggregatesFilter<"RelevanceScoreResult">
    tokenUsage?: IntNullableWithAggregatesFilter<"RelevanceScoreResult"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"RelevanceScoreResult"> | Date | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    domains?: DomainCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    domains?: DomainUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: DomainUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: DomainUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainCreateInput = {
    url: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    user?: UserCreateNestedOneWithoutDomainsInput
    crawlResults?: CrawlResultCreateNestedManyWithoutDomainInput
    keywords?: KeywordCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultCreateNestedManyWithoutDomainInput
  }

  export type DomainUncheckedCreateInput = {
    id?: number
    url: string
    context?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    crawlResults?: CrawlResultUncheckedCreateNestedManyWithoutDomainInput
    keywords?: KeywordUncheckedCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisUncheckedCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisUncheckedCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseUncheckedCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisUncheckedCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisUncheckedCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationUncheckedCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedCreateNestedManyWithoutDomainInput
  }

  export type DomainUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutDomainsNestedInput
    crawlResults?: CrawlResultUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUpdateManyWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    crawlResults?: CrawlResultUncheckedUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUncheckedUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUncheckedUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUncheckedUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type DomainCreateManyInput = {
    id?: number
    url: string
    context?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
  }

  export type DomainUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DomainUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CrawlResultCreateInput = {
    pagesScanned: number
    analyzedUrls: string
    extractedContext: string
    tokenUsage?: number | null
    createdAt?: Date | string
    domain?: DomainCreateNestedOneWithoutCrawlResultsInput
  }

  export type CrawlResultUncheckedCreateInput = {
    id?: number
    domainId?: number | null
    pagesScanned: number
    analyzedUrls: string
    extractedContext: string
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type CrawlResultUpdateInput = {
    pagesScanned?: IntFieldUpdateOperationsInput | number
    analyzedUrls?: StringFieldUpdateOperationsInput | string
    extractedContext?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutCrawlResultsNestedInput
  }

  export type CrawlResultUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    pagesScanned?: IntFieldUpdateOperationsInput | number
    analyzedUrls?: StringFieldUpdateOperationsInput | string
    extractedContext?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrawlResultCreateManyInput = {
    id?: number
    domainId?: number | null
    pagesScanned: number
    analyzedUrls: string
    extractedContext: string
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type CrawlResultUpdateManyMutationInput = {
    pagesScanned?: IntFieldUpdateOperationsInput | number
    analyzedUrls?: StringFieldUpdateOperationsInput | string
    extractedContext?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrawlResultUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    pagesScanned?: IntFieldUpdateOperationsInput | number
    analyzedUrls?: StringFieldUpdateOperationsInput | string
    extractedContext?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeywordCreateInput = {
    term: string
    volume: number
    difficulty: string
    cpc: number
    intent?: string | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    domain?: DomainCreateNestedOneWithoutKeywordsInput
    phrases?: PhraseCreateNestedManyWithoutKeywordInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutKeywordInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutKeywordInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutKeywordInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutKeywordInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutKeywordInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutKeywordInput
  }

  export type KeywordUncheckedCreateInput = {
    id?: number
    term: string
    volume: number
    difficulty: string
    cpc: number
    intent?: string | null
    domainId?: number | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    phrases?: PhraseUncheckedCreateNestedManyWithoutKeywordInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutKeywordInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutKeywordInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutKeywordInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutKeywordInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutKeywordInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutKeywordInput
  }

  export type KeywordUpdateInput = {
    term?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    cpc?: FloatFieldUpdateOperationsInput | number
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutKeywordsNestedInput
    phrases?: PhraseUpdateManyWithoutKeywordNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutKeywordNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutKeywordNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutKeywordNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutKeywordNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutKeywordNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutKeywordNestedInput
  }

  export type KeywordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    term?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    cpc?: FloatFieldUpdateOperationsInput | number
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phrases?: PhraseUncheckedUpdateManyWithoutKeywordNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutKeywordNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutKeywordNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutKeywordNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutKeywordNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutKeywordNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutKeywordNestedInput
  }

  export type KeywordCreateManyInput = {
    id?: number
    term: string
    volume: number
    difficulty: string
    cpc: number
    intent?: string | null
    domainId?: number | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeywordUpdateManyMutationInput = {
    term?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    cpc?: FloatFieldUpdateOperationsInput | number
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeywordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    term?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    cpc?: FloatFieldUpdateOperationsInput | number
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhraseCreateInput = {
    text: string
    relevanceScore?: number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: string | null
    intent?: string | null
    confidence?: number | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    keyword: KeywordCreateNestedOneWithoutPhrasesInput
    phraseIntentClassifications?: PhraseIntentClassificationCreateNestedManyWithoutPhraseInput
    phraseScores?: PhraseScoreCreateNestedManyWithoutPhraseInput
  }

  export type PhraseUncheckedCreateInput = {
    id?: number
    text: string
    keywordId: number
    relevanceScore?: number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: string | null
    intent?: string | null
    confidence?: number | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    phraseIntentClassifications?: PhraseIntentClassificationUncheckedCreateNestedManyWithoutPhraseInput
    phraseScores?: PhraseScoreUncheckedCreateNestedManyWithoutPhraseInput
  }

  export type PhraseUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: NullableStringFieldUpdateOperationsInput | string | null
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keyword?: KeywordUpdateOneRequiredWithoutPhrasesNestedInput
    phraseIntentClassifications?: PhraseIntentClassificationUpdateManyWithoutPhraseNestedInput
    phraseScores?: PhraseScoreUpdateManyWithoutPhraseNestedInput
  }

  export type PhraseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    keywordId?: IntFieldUpdateOperationsInput | number
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: NullableStringFieldUpdateOperationsInput | string | null
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phraseIntentClassifications?: PhraseIntentClassificationUncheckedUpdateManyWithoutPhraseNestedInput
    phraseScores?: PhraseScoreUncheckedUpdateManyWithoutPhraseNestedInput
  }

  export type PhraseCreateManyInput = {
    id?: number
    text: string
    keywordId: number
    relevanceScore?: number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: string | null
    intent?: string | null
    confidence?: number | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhraseUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: NullableStringFieldUpdateOperationsInput | string | null
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhraseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    keywordId?: IntFieldUpdateOperationsInput | number
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: NullableStringFieldUpdateOperationsInput | string | null
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIQueryResultCreateInput = {
    model: string
    response: string
    latency: number
    cost: number
    presence: number
    relevance: number
    accuracy: number
    sentiment: number
    overall: number
    createdAt?: Date | string
    phrase: GeneratedIntentPhraseCreateNestedOneWithoutAiQueryResultsInput
  }

  export type AIQueryResultUncheckedCreateInput = {
    id?: number
    phraseId: number
    model: string
    response: string
    latency: number
    cost: number
    presence: number
    relevance: number
    accuracy: number
    sentiment: number
    overall: number
    createdAt?: Date | string
  }

  export type AIQueryResultUpdateInput = {
    model?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    latency?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    presence?: IntFieldUpdateOperationsInput | number
    relevance?: IntFieldUpdateOperationsInput | number
    accuracy?: IntFieldUpdateOperationsInput | number
    sentiment?: IntFieldUpdateOperationsInput | number
    overall?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phrase?: GeneratedIntentPhraseUpdateOneRequiredWithoutAiQueryResultsNestedInput
  }

  export type AIQueryResultUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    phraseId?: IntFieldUpdateOperationsInput | number
    model?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    latency?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    presence?: IntFieldUpdateOperationsInput | number
    relevance?: IntFieldUpdateOperationsInput | number
    accuracy?: IntFieldUpdateOperationsInput | number
    sentiment?: IntFieldUpdateOperationsInput | number
    overall?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIQueryResultCreateManyInput = {
    id?: number
    phraseId: number
    model: string
    response: string
    latency: number
    cost: number
    presence: number
    relevance: number
    accuracy: number
    sentiment: number
    overall: number
    createdAt?: Date | string
  }

  export type AIQueryResultUpdateManyMutationInput = {
    model?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    latency?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    presence?: IntFieldUpdateOperationsInput | number
    relevance?: IntFieldUpdateOperationsInput | number
    accuracy?: IntFieldUpdateOperationsInput | number
    sentiment?: IntFieldUpdateOperationsInput | number
    overall?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIQueryResultUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    phraseId?: IntFieldUpdateOperationsInput | number
    model?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    latency?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    presence?: IntFieldUpdateOperationsInput | number
    relevance?: IntFieldUpdateOperationsInput | number
    accuracy?: IntFieldUpdateOperationsInput | number
    sentiment?: IntFieldUpdateOperationsInput | number
    overall?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardAnalysisCreateInput = {
    metrics: JsonNullValueInput | InputJsonValue
    insights: JsonNullValueInput | InputJsonValue
    industryAnalysis: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    domain?: DomainCreateNestedOneWithoutDashboardAnalysesInput
  }

  export type DashboardAnalysisUncheckedCreateInput = {
    id?: number
    domainId?: number | null
    metrics: JsonNullValueInput | InputJsonValue
    insights: JsonNullValueInput | InputJsonValue
    industryAnalysis: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardAnalysisUpdateInput = {
    metrics?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    industryAnalysis?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutDashboardAnalysesNestedInput
  }

  export type DashboardAnalysisUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    metrics?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    industryAnalysis?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardAnalysisCreateManyInput = {
    id?: number
    domainId?: number | null
    metrics: JsonNullValueInput | InputJsonValue
    insights: JsonNullValueInput | InputJsonValue
    industryAnalysis: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardAnalysisUpdateManyMutationInput = {
    metrics?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    industryAnalysis?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardAnalysisUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    metrics?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    industryAnalysis?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetitorAnalysisCreateInput = {
    competitors: JsonNullValueInput | InputJsonValue
    marketInsights: JsonNullValueInput | InputJsonValue
    strategicRecommendations: JsonNullValueInput | InputJsonValue
    competitiveAnalysis: JsonNullValueInput | InputJsonValue
    competitorList: string
    createdAt?: Date | string
    updatedAt?: Date | string
    domain?: DomainCreateNestedOneWithoutCompetitorAnalysesInput
  }

  export type CompetitorAnalysisUncheckedCreateInput = {
    id?: number
    domainId?: number | null
    competitors: JsonNullValueInput | InputJsonValue
    marketInsights: JsonNullValueInput | InputJsonValue
    strategicRecommendations: JsonNullValueInput | InputJsonValue
    competitiveAnalysis: JsonNullValueInput | InputJsonValue
    competitorList: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompetitorAnalysisUpdateInput = {
    competitors?: JsonNullValueInput | InputJsonValue
    marketInsights?: JsonNullValueInput | InputJsonValue
    strategicRecommendations?: JsonNullValueInput | InputJsonValue
    competitiveAnalysis?: JsonNullValueInput | InputJsonValue
    competitorList?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutCompetitorAnalysesNestedInput
  }

  export type CompetitorAnalysisUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    competitors?: JsonNullValueInput | InputJsonValue
    marketInsights?: JsonNullValueInput | InputJsonValue
    strategicRecommendations?: JsonNullValueInput | InputJsonValue
    competitiveAnalysis?: JsonNullValueInput | InputJsonValue
    competitorList?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetitorAnalysisCreateManyInput = {
    id?: number
    domainId?: number | null
    competitors: JsonNullValueInput | InputJsonValue
    marketInsights: JsonNullValueInput | InputJsonValue
    strategicRecommendations: JsonNullValueInput | InputJsonValue
    competitiveAnalysis: JsonNullValueInput | InputJsonValue
    competitorList: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompetitorAnalysisUpdateManyMutationInput = {
    competitors?: JsonNullValueInput | InputJsonValue
    marketInsights?: JsonNullValueInput | InputJsonValue
    strategicRecommendations?: JsonNullValueInput | InputJsonValue
    competitiveAnalysis?: JsonNullValueInput | InputJsonValue
    competitorList?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetitorAnalysisUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    competitors?: JsonNullValueInput | InputJsonValue
    marketInsights?: JsonNullValueInput | InputJsonValue
    strategicRecommendations?: JsonNullValueInput | InputJsonValue
    competitiveAnalysis?: JsonNullValueInput | InputJsonValue
    competitorList?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuggestedCompetitorCreateInput = {
    name: string
    competitorDomain: string
    reason: string
    type: string
    createdAt?: Date | string
    domain?: DomainCreateNestedOneWithoutSuggestedCompetitorsInput
  }

  export type SuggestedCompetitorUncheckedCreateInput = {
    id?: number
    domainId?: number | null
    name: string
    competitorDomain: string
    reason: string
    type: string
    createdAt?: Date | string
  }

  export type SuggestedCompetitorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    competitorDomain?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutSuggestedCompetitorsNestedInput
  }

  export type SuggestedCompetitorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    competitorDomain?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuggestedCompetitorCreateManyInput = {
    id?: number
    domainId?: number | null
    name: string
    competitorDomain: string
    reason: string
    type: string
    createdAt?: Date | string
  }

  export type SuggestedCompetitorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    competitorDomain?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuggestedCompetitorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    competitorDomain?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisPhaseCreateInput = {
    phase: string
    status: string
    progress?: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    domain?: DomainCreateNestedOneWithoutAnalysisPhasesInput
  }

  export type AnalysisPhaseUncheckedCreateInput = {
    id?: number
    domainId?: number | null
    phase: string
    status: string
    progress?: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalysisPhaseUpdateInput = {
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutAnalysisPhasesNestedInput
  }

  export type AnalysisPhaseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisPhaseCreateManyInput = {
    id?: number
    domainId?: number | null
    phase: string
    status: string
    progress?: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalysisPhaseUpdateManyMutationInput = {
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisPhaseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SemanticAnalysisCreateInput = {
    contentSummary: string
    keyThemes: JsonNullValueInput | InputJsonValue
    brandVoice: string
    targetAudience: JsonNullValueInput | InputJsonValue
    contentGaps: JsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    domain?: DomainCreateNestedOneWithoutSemanticAnalysesInput
  }

  export type SemanticAnalysisUncheckedCreateInput = {
    id?: number
    domainId?: number | null
    contentSummary: string
    keyThemes: JsonNullValueInput | InputJsonValue
    brandVoice: string
    targetAudience: JsonNullValueInput | InputJsonValue
    contentGaps: JsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SemanticAnalysisUpdateInput = {
    contentSummary?: StringFieldUpdateOperationsInput | string
    keyThemes?: JsonNullValueInput | InputJsonValue
    brandVoice?: StringFieldUpdateOperationsInput | string
    targetAudience?: JsonNullValueInput | InputJsonValue
    contentGaps?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutSemanticAnalysesNestedInput
  }

  export type SemanticAnalysisUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    contentSummary?: StringFieldUpdateOperationsInput | string
    keyThemes?: JsonNullValueInput | InputJsonValue
    brandVoice?: StringFieldUpdateOperationsInput | string
    targetAudience?: JsonNullValueInput | InputJsonValue
    contentGaps?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SemanticAnalysisCreateManyInput = {
    id?: number
    domainId?: number | null
    contentSummary: string
    keyThemes: JsonNullValueInput | InputJsonValue
    brandVoice: string
    targetAudience: JsonNullValueInput | InputJsonValue
    contentGaps: JsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SemanticAnalysisUpdateManyMutationInput = {
    contentSummary?: StringFieldUpdateOperationsInput | string
    keyThemes?: JsonNullValueInput | InputJsonValue
    brandVoice?: StringFieldUpdateOperationsInput | string
    targetAudience?: JsonNullValueInput | InputJsonValue
    contentGaps?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SemanticAnalysisUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    contentSummary?: StringFieldUpdateOperationsInput | string
    keyThemes?: JsonNullValueInput | InputJsonValue
    brandVoice?: StringFieldUpdateOperationsInput | string
    targetAudience?: JsonNullValueInput | InputJsonValue
    contentGaps?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeywordAnalysisCreateInput = {
    keywords: JsonNullValueInput | InputJsonValue
    searchVolumeData: JsonNullValueInput | InputJsonValue
    intentClassification: JsonNullValueInput | InputJsonValue
    competitiveAnalysis: JsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    domain?: DomainCreateNestedOneWithoutKeywordAnalysesInput
  }

  export type KeywordAnalysisUncheckedCreateInput = {
    id?: number
    domainId?: number | null
    keywords: JsonNullValueInput | InputJsonValue
    searchVolumeData: JsonNullValueInput | InputJsonValue
    intentClassification: JsonNullValueInput | InputJsonValue
    competitiveAnalysis: JsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeywordAnalysisUpdateInput = {
    keywords?: JsonNullValueInput | InputJsonValue
    searchVolumeData?: JsonNullValueInput | InputJsonValue
    intentClassification?: JsonNullValueInput | InputJsonValue
    competitiveAnalysis?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutKeywordAnalysesNestedInput
  }

  export type KeywordAnalysisUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    keywords?: JsonNullValueInput | InputJsonValue
    searchVolumeData?: JsonNullValueInput | InputJsonValue
    intentClassification?: JsonNullValueInput | InputJsonValue
    competitiveAnalysis?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeywordAnalysisCreateManyInput = {
    id?: number
    domainId?: number | null
    keywords: JsonNullValueInput | InputJsonValue
    searchVolumeData: JsonNullValueInput | InputJsonValue
    intentClassification: JsonNullValueInput | InputJsonValue
    competitiveAnalysis: JsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeywordAnalysisUpdateManyMutationInput = {
    keywords?: JsonNullValueInput | InputJsonValue
    searchVolumeData?: JsonNullValueInput | InputJsonValue
    intentClassification?: JsonNullValueInput | InputJsonValue
    competitiveAnalysis?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeywordAnalysisUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    keywords?: JsonNullValueInput | InputJsonValue
    searchVolumeData?: JsonNullValueInput | InputJsonValue
    intentClassification?: JsonNullValueInput | InputJsonValue
    competitiveAnalysis?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchVolumeClassificationCreateInput = {
    highVolumeKeywords: JsonNullValueInput | InputJsonValue
    mediumVolumeKeywords: JsonNullValueInput | InputJsonValue
    lowVolumeKeywords: JsonNullValueInput | InputJsonValue
    volumeTrends: JsonNullValueInput | InputJsonValue
    seasonalPatterns: JsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    domain?: DomainCreateNestedOneWithoutSearchVolumeClassificationsInput
  }

  export type SearchVolumeClassificationUncheckedCreateInput = {
    id?: number
    domainId?: number | null
    highVolumeKeywords: JsonNullValueInput | InputJsonValue
    mediumVolumeKeywords: JsonNullValueInput | InputJsonValue
    lowVolumeKeywords: JsonNullValueInput | InputJsonValue
    volumeTrends: JsonNullValueInput | InputJsonValue
    seasonalPatterns: JsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SearchVolumeClassificationUpdateInput = {
    highVolumeKeywords?: JsonNullValueInput | InputJsonValue
    mediumVolumeKeywords?: JsonNullValueInput | InputJsonValue
    lowVolumeKeywords?: JsonNullValueInput | InputJsonValue
    volumeTrends?: JsonNullValueInput | InputJsonValue
    seasonalPatterns?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutSearchVolumeClassificationsNestedInput
  }

  export type SearchVolumeClassificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    highVolumeKeywords?: JsonNullValueInput | InputJsonValue
    mediumVolumeKeywords?: JsonNullValueInput | InputJsonValue
    lowVolumeKeywords?: JsonNullValueInput | InputJsonValue
    volumeTrends?: JsonNullValueInput | InputJsonValue
    seasonalPatterns?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchVolumeClassificationCreateManyInput = {
    id?: number
    domainId?: number | null
    highVolumeKeywords: JsonNullValueInput | InputJsonValue
    mediumVolumeKeywords: JsonNullValueInput | InputJsonValue
    lowVolumeKeywords: JsonNullValueInput | InputJsonValue
    volumeTrends: JsonNullValueInput | InputJsonValue
    seasonalPatterns: JsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SearchVolumeClassificationUpdateManyMutationInput = {
    highVolumeKeywords?: JsonNullValueInput | InputJsonValue
    mediumVolumeKeywords?: JsonNullValueInput | InputJsonValue
    lowVolumeKeywords?: JsonNullValueInput | InputJsonValue
    volumeTrends?: JsonNullValueInput | InputJsonValue
    seasonalPatterns?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchVolumeClassificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    highVolumeKeywords?: JsonNullValueInput | InputJsonValue
    mediumVolumeKeywords?: JsonNullValueInput | InputJsonValue
    lowVolumeKeywords?: JsonNullValueInput | InputJsonValue
    volumeTrends?: JsonNullValueInput | InputJsonValue
    seasonalPatterns?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentClassificationCreateInput = {
    informationalKeywords: JsonNullValueInput | InputJsonValue
    navigationalKeywords: JsonNullValueInput | InputJsonValue
    transactionalKeywords: JsonNullValueInput | InputJsonValue
    commercialKeywords: JsonNullValueInput | InputJsonValue
    intentDistribution: JsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    domain?: DomainCreateNestedOneWithoutIntentClassificationsInput
  }

  export type IntentClassificationUncheckedCreateInput = {
    id?: number
    domainId?: number | null
    informationalKeywords: JsonNullValueInput | InputJsonValue
    navigationalKeywords: JsonNullValueInput | InputJsonValue
    transactionalKeywords: JsonNullValueInput | InputJsonValue
    commercialKeywords: JsonNullValueInput | InputJsonValue
    intentDistribution: JsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntentClassificationUpdateInput = {
    informationalKeywords?: JsonNullValueInput | InputJsonValue
    navigationalKeywords?: JsonNullValueInput | InputJsonValue
    transactionalKeywords?: JsonNullValueInput | InputJsonValue
    commercialKeywords?: JsonNullValueInput | InputJsonValue
    intentDistribution?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutIntentClassificationsNestedInput
  }

  export type IntentClassificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    informationalKeywords?: JsonNullValueInput | InputJsonValue
    navigationalKeywords?: JsonNullValueInput | InputJsonValue
    transactionalKeywords?: JsonNullValueInput | InputJsonValue
    commercialKeywords?: JsonNullValueInput | InputJsonValue
    intentDistribution?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentClassificationCreateManyInput = {
    id?: number
    domainId?: number | null
    informationalKeywords: JsonNullValueInput | InputJsonValue
    navigationalKeywords: JsonNullValueInput | InputJsonValue
    transactionalKeywords: JsonNullValueInput | InputJsonValue
    commercialKeywords: JsonNullValueInput | InputJsonValue
    intentDistribution: JsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntentClassificationUpdateManyMutationInput = {
    informationalKeywords?: JsonNullValueInput | InputJsonValue
    navigationalKeywords?: JsonNullValueInput | InputJsonValue
    transactionalKeywords?: JsonNullValueInput | InputJsonValue
    commercialKeywords?: JsonNullValueInput | InputJsonValue
    intentDistribution?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentClassificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    informationalKeywords?: JsonNullValueInput | InputJsonValue
    navigationalKeywords?: JsonNullValueInput | InputJsonValue
    transactionalKeywords?: JsonNullValueInput | InputJsonValue
    commercialKeywords?: JsonNullValueInput | InputJsonValue
    intentDistribution?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityInsightCreateInput = {
    sources: JsonNullValueInput | InputJsonValue
    summary: string
    tokenUsage?: number | null
    createdAt?: Date | string
    domain?: DomainCreateNestedOneWithoutCommunityInsightsInput
    keyword?: KeywordCreateNestedOneWithoutCommunityInsightsInput
  }

  export type CommunityInsightUncheckedCreateInput = {
    id?: number
    domainId?: number | null
    keywordId?: number | null
    sources: JsonNullValueInput | InputJsonValue
    summary: string
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type CommunityInsightUpdateInput = {
    sources?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutCommunityInsightsNestedInput
    keyword?: KeywordUpdateOneWithoutCommunityInsightsNestedInput
  }

  export type CommunityInsightUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityInsightCreateManyInput = {
    id?: number
    domainId?: number | null
    keywordId?: number | null
    sources: JsonNullValueInput | InputJsonValue
    summary: string
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type CommunityInsightUpdateManyMutationInput = {
    sources?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityInsightUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchPatternCreateInput = {
    patterns: JsonNullValueInput | InputJsonValue
    summary: string
    tokenUsage?: number | null
    createdAt?: Date | string
    domain?: DomainCreateNestedOneWithoutSearchPatternsInput
    keyword?: KeywordCreateNestedOneWithoutSearchPatternsInput
  }

  export type SearchPatternUncheckedCreateInput = {
    id?: number
    domainId?: number | null
    keywordId?: number | null
    patterns: JsonNullValueInput | InputJsonValue
    summary: string
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type SearchPatternUpdateInput = {
    patterns?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutSearchPatternsNestedInput
    keyword?: KeywordUpdateOneWithoutSearchPatternsNestedInput
  }

  export type SearchPatternUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    patterns?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchPatternCreateManyInput = {
    id?: number
    domainId?: number | null
    keywordId?: number | null
    patterns: JsonNullValueInput | InputJsonValue
    summary: string
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type SearchPatternUpdateManyMutationInput = {
    patterns?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchPatternUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    patterns?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhraseIntentClassificationCreateInput = {
    intent: string
    confidence?: number | null
    createdAt?: Date | string
    phrase: PhraseCreateNestedOneWithoutPhraseIntentClassificationsInput
  }

  export type PhraseIntentClassificationUncheckedCreateInput = {
    id?: number
    phraseId: number
    intent: string
    confidence?: number | null
    createdAt?: Date | string
  }

  export type PhraseIntentClassificationUpdateInput = {
    intent?: StringFieldUpdateOperationsInput | string
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phrase?: PhraseUpdateOneRequiredWithoutPhraseIntentClassificationsNestedInput
  }

  export type PhraseIntentClassificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    phraseId?: IntFieldUpdateOperationsInput | number
    intent?: StringFieldUpdateOperationsInput | string
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhraseIntentClassificationCreateManyInput = {
    id?: number
    phraseId: number
    intent: string
    confidence?: number | null
    createdAt?: Date | string
  }

  export type PhraseIntentClassificationUpdateManyMutationInput = {
    intent?: StringFieldUpdateOperationsInput | string
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhraseIntentClassificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    phraseId?: IntFieldUpdateOperationsInput | number
    intent?: StringFieldUpdateOperationsInput | string
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhraseScoreCreateInput = {
    score: number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    phrase: PhraseCreateNestedOneWithoutPhraseScoresInput
  }

  export type PhraseScoreUncheckedCreateInput = {
    id?: number
    phraseId: number
    score: number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PhraseScoreUpdateInput = {
    score?: IntFieldUpdateOperationsInput | number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phrase?: PhraseUpdateOneRequiredWithoutPhraseScoresNestedInput
  }

  export type PhraseScoreUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    phraseId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhraseScoreCreateManyInput = {
    id?: number
    phraseId: number
    score: number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PhraseScoreUpdateManyMutationInput = {
    score?: IntFieldUpdateOperationsInput | number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhraseScoreUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    phraseId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentPhraseGenerationCreateInput = {
    status?: string
    phase: string
    progress?: number
    startTime?: Date | string
    endTime?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    domain?: DomainCreateNestedOneWithoutIntentPhraseGenerationsInput
  }

  export type IntentPhraseGenerationUncheckedCreateInput = {
    id?: number
    domainId: number
    status?: string
    phase: string
    progress?: number
    startTime?: Date | string
    endTime?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntentPhraseGenerationUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutIntentPhraseGenerationsNestedInput
  }

  export type IntentPhraseGenerationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentPhraseGenerationCreateManyInput = {
    id?: number
    domainId: number
    status?: string
    phase: string
    progress?: number
    startTime?: Date | string
    endTime?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntentPhraseGenerationUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentPhraseGenerationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityMiningResultCreateInput = {
    platform: string
    insights: JsonNullValueInput | InputJsonValue
    sentiment?: string | null
    frequency?: number | null
    tokenUsage?: number | null
    createdAt?: Date | string
    domain?: DomainCreateNestedOneWithoutCommunityMiningResultsInput
    keyword?: KeywordCreateNestedOneWithoutCommunityMiningResultsInput
  }

  export type CommunityMiningResultUncheckedCreateInput = {
    id?: number
    domainId: number
    keywordId?: number | null
    platform: string
    insights: JsonNullValueInput | InputJsonValue
    sentiment?: string | null
    frequency?: number | null
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type CommunityMiningResultUpdateInput = {
    platform?: StringFieldUpdateOperationsInput | string
    insights?: JsonNullValueInput | InputJsonValue
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutCommunityMiningResultsNestedInput
    keyword?: KeywordUpdateOneWithoutCommunityMiningResultsNestedInput
  }

  export type CommunityMiningResultUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    platform?: StringFieldUpdateOperationsInput | string
    insights?: JsonNullValueInput | InputJsonValue
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityMiningResultCreateManyInput = {
    id?: number
    domainId: number
    keywordId?: number | null
    platform: string
    insights: JsonNullValueInput | InputJsonValue
    sentiment?: string | null
    frequency?: number | null
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type CommunityMiningResultUpdateManyMutationInput = {
    platform?: StringFieldUpdateOperationsInput | string
    insights?: JsonNullValueInput | InputJsonValue
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityMiningResultUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    platform?: StringFieldUpdateOperationsInput | string
    insights?: JsonNullValueInput | InputJsonValue
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchPatternResultCreateInput = {
    patterns: JsonNullValueInput | InputJsonValue
    volume?: number | null
    seasonality?: NullableJsonNullValueInput | InputJsonValue
    trends?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    domain?: DomainCreateNestedOneWithoutSearchPatternResultsInput
    keyword?: KeywordCreateNestedOneWithoutSearchPatternResultsInput
  }

  export type SearchPatternResultUncheckedCreateInput = {
    id?: number
    domainId: number
    keywordId?: number | null
    patterns: JsonNullValueInput | InputJsonValue
    volume?: number | null
    seasonality?: NullableJsonNullValueInput | InputJsonValue
    trends?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type SearchPatternResultUpdateInput = {
    patterns?: JsonNullValueInput | InputJsonValue
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    seasonality?: NullableJsonNullValueInput | InputJsonValue
    trends?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutSearchPatternResultsNestedInput
    keyword?: KeywordUpdateOneWithoutSearchPatternResultsNestedInput
  }

  export type SearchPatternResultUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    patterns?: JsonNullValueInput | InputJsonValue
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    seasonality?: NullableJsonNullValueInput | InputJsonValue
    trends?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchPatternResultCreateManyInput = {
    id?: number
    domainId: number
    keywordId?: number | null
    patterns: JsonNullValueInput | InputJsonValue
    volume?: number | null
    seasonality?: NullableJsonNullValueInput | InputJsonValue
    trends?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type SearchPatternResultUpdateManyMutationInput = {
    patterns?: JsonNullValueInput | InputJsonValue
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    seasonality?: NullableJsonNullValueInput | InputJsonValue
    trends?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchPatternResultUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    patterns?: JsonNullValueInput | InputJsonValue
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    seasonality?: NullableJsonNullValueInput | InputJsonValue
    trends?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentClassificationResultCreateInput = {
    intent: string
    confidence?: number | null
    patterns?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    domain?: DomainCreateNestedOneWithoutIntentClassificationResultsInput
    keyword?: KeywordCreateNestedOneWithoutIntentClassificationResultsInput
  }

  export type IntentClassificationResultUncheckedCreateInput = {
    id?: number
    domainId: number
    keywordId?: number | null
    intent: string
    confidence?: number | null
    patterns?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type IntentClassificationResultUpdateInput = {
    intent?: StringFieldUpdateOperationsInput | string
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    patterns?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutIntentClassificationResultsNestedInput
    keyword?: KeywordUpdateOneWithoutIntentClassificationResultsNestedInput
  }

  export type IntentClassificationResultUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    intent?: StringFieldUpdateOperationsInput | string
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    patterns?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentClassificationResultCreateManyInput = {
    id?: number
    domainId: number
    keywordId?: number | null
    intent: string
    confidence?: number | null
    patterns?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type IntentClassificationResultUpdateManyMutationInput = {
    intent?: StringFieldUpdateOperationsInput | string
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    patterns?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentClassificationResultUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    intent?: StringFieldUpdateOperationsInput | string
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    patterns?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedIntentPhraseCreateInput = {
    phrase: string
    relevanceScore?: number | null
    intent?: string | null
    intentConfidence?: number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: boolean
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    domain?: DomainCreateNestedOneWithoutGeneratedIntentPhrasesInput
    keyword?: KeywordCreateNestedOneWithoutGeneratedIntentPhrasesInput
    relevanceScoreResults?: RelevanceScoreResultCreateNestedManyWithoutPhraseInput
    aiQueryResults?: AIQueryResultCreateNestedManyWithoutPhraseInput
  }

  export type GeneratedIntentPhraseUncheckedCreateInput = {
    id?: number
    domainId: number
    keywordId?: number | null
    phrase: string
    relevanceScore?: number | null
    intent?: string | null
    intentConfidence?: number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: boolean
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    relevanceScoreResults?: RelevanceScoreResultUncheckedCreateNestedManyWithoutPhraseInput
    aiQueryResults?: AIQueryResultUncheckedCreateNestedManyWithoutPhraseInput
  }

  export type GeneratedIntentPhraseUpdateInput = {
    phrase?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    intentConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: NullableStringFieldUpdateOperationsInput | string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutGeneratedIntentPhrasesNestedInput
    keyword?: KeywordUpdateOneWithoutGeneratedIntentPhrasesNestedInput
    relevanceScoreResults?: RelevanceScoreResultUpdateManyWithoutPhraseNestedInput
    aiQueryResults?: AIQueryResultUpdateManyWithoutPhraseNestedInput
  }

  export type GeneratedIntentPhraseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    phrase?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    intentConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: NullableStringFieldUpdateOperationsInput | string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relevanceScoreResults?: RelevanceScoreResultUncheckedUpdateManyWithoutPhraseNestedInput
    aiQueryResults?: AIQueryResultUncheckedUpdateManyWithoutPhraseNestedInput
  }

  export type GeneratedIntentPhraseCreateManyInput = {
    id?: number
    domainId: number
    keywordId?: number | null
    phrase: string
    relevanceScore?: number | null
    intent?: string | null
    intentConfidence?: number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: boolean
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GeneratedIntentPhraseUpdateManyMutationInput = {
    phrase?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    intentConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: NullableStringFieldUpdateOperationsInput | string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedIntentPhraseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    phrase?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    intentConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: NullableStringFieldUpdateOperationsInput | string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelevanceScoreResultCreateInput = {
    score: number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    factors?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    domain?: DomainCreateNestedOneWithoutRelevanceScoreResultsInput
    phrase?: GeneratedIntentPhraseCreateNestedOneWithoutRelevanceScoreResultsInput
  }

  export type RelevanceScoreResultUncheckedCreateInput = {
    id?: number
    domainId: number
    phraseId?: number | null
    score: number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    factors?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type RelevanceScoreResultUpdateInput = {
    score?: IntFieldUpdateOperationsInput | number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    factors?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutRelevanceScoreResultsNestedInput
    phrase?: GeneratedIntentPhraseUpdateOneWithoutRelevanceScoreResultsNestedInput
  }

  export type RelevanceScoreResultUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    phraseId?: NullableIntFieldUpdateOperationsInput | number | null
    score?: IntFieldUpdateOperationsInput | number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    factors?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelevanceScoreResultCreateManyInput = {
    id?: number
    domainId: number
    phraseId?: number | null
    score: number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    factors?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type RelevanceScoreResultUpdateManyMutationInput = {
    score?: IntFieldUpdateOperationsInput | number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    factors?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelevanceScoreResultUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    phraseId?: NullableIntFieldUpdateOperationsInput | number | null
    score?: IntFieldUpdateOperationsInput | number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    factors?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DomainListRelationFilter = {
    every?: DomainWhereInput
    some?: DomainWhereInput
    none?: DomainWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type DomainOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CrawlResultListRelationFilter = {
    every?: CrawlResultWhereInput
    some?: CrawlResultWhereInput
    none?: CrawlResultWhereInput
  }

  export type KeywordListRelationFilter = {
    every?: KeywordWhereInput
    some?: KeywordWhereInput
    none?: KeywordWhereInput
  }

  export type DashboardAnalysisListRelationFilter = {
    every?: DashboardAnalysisWhereInput
    some?: DashboardAnalysisWhereInput
    none?: DashboardAnalysisWhereInput
  }

  export type CompetitorAnalysisListRelationFilter = {
    every?: CompetitorAnalysisWhereInput
    some?: CompetitorAnalysisWhereInput
    none?: CompetitorAnalysisWhereInput
  }

  export type SuggestedCompetitorListRelationFilter = {
    every?: SuggestedCompetitorWhereInput
    some?: SuggestedCompetitorWhereInput
    none?: SuggestedCompetitorWhereInput
  }

  export type AnalysisPhaseListRelationFilter = {
    every?: AnalysisPhaseWhereInput
    some?: AnalysisPhaseWhereInput
    none?: AnalysisPhaseWhereInput
  }

  export type SemanticAnalysisListRelationFilter = {
    every?: SemanticAnalysisWhereInput
    some?: SemanticAnalysisWhereInput
    none?: SemanticAnalysisWhereInput
  }

  export type KeywordAnalysisListRelationFilter = {
    every?: KeywordAnalysisWhereInput
    some?: KeywordAnalysisWhereInput
    none?: KeywordAnalysisWhereInput
  }

  export type SearchVolumeClassificationListRelationFilter = {
    every?: SearchVolumeClassificationWhereInput
    some?: SearchVolumeClassificationWhereInput
    none?: SearchVolumeClassificationWhereInput
  }

  export type IntentClassificationListRelationFilter = {
    every?: IntentClassificationWhereInput
    some?: IntentClassificationWhereInput
    none?: IntentClassificationWhereInput
  }

  export type CommunityInsightListRelationFilter = {
    every?: CommunityInsightWhereInput
    some?: CommunityInsightWhereInput
    none?: CommunityInsightWhereInput
  }

  export type SearchPatternListRelationFilter = {
    every?: SearchPatternWhereInput
    some?: SearchPatternWhereInput
    none?: SearchPatternWhereInput
  }

  export type IntentPhraseGenerationListRelationFilter = {
    every?: IntentPhraseGenerationWhereInput
    some?: IntentPhraseGenerationWhereInput
    none?: IntentPhraseGenerationWhereInput
  }

  export type CommunityMiningResultListRelationFilter = {
    every?: CommunityMiningResultWhereInput
    some?: CommunityMiningResultWhereInput
    none?: CommunityMiningResultWhereInput
  }

  export type SearchPatternResultListRelationFilter = {
    every?: SearchPatternResultWhereInput
    some?: SearchPatternResultWhereInput
    none?: SearchPatternResultWhereInput
  }

  export type IntentClassificationResultListRelationFilter = {
    every?: IntentClassificationResultWhereInput
    some?: IntentClassificationResultWhereInput
    none?: IntentClassificationResultWhereInput
  }

  export type GeneratedIntentPhraseListRelationFilter = {
    every?: GeneratedIntentPhraseWhereInput
    some?: GeneratedIntentPhraseWhereInput
    none?: GeneratedIntentPhraseWhereInput
  }

  export type RelevanceScoreResultListRelationFilter = {
    every?: RelevanceScoreResultWhereInput
    some?: RelevanceScoreResultWhereInput
    none?: RelevanceScoreResultWhereInput
  }

  export type CrawlResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KeywordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DashboardAnalysisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompetitorAnalysisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SuggestedCompetitorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnalysisPhaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SemanticAnalysisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KeywordAnalysisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SearchVolumeClassificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntentClassificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunityInsightOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SearchPatternOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntentPhraseGenerationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunityMiningResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SearchPatternResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntentClassificationResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GeneratedIntentPhraseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RelevanceScoreResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DomainCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    context?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: SortOrder
    customKeywords?: SortOrder
    intentPhrases?: SortOrder
    chatModel?: SortOrder
    runAllModels?: SortOrder
    locationContext?: SortOrder
  }

  export type DomainAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DomainMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    context?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: SortOrder
    customKeywords?: SortOrder
    intentPhrases?: SortOrder
    chatModel?: SortOrder
    runAllModels?: SortOrder
    locationContext?: SortOrder
  }

  export type DomainMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    context?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: SortOrder
    customKeywords?: SortOrder
    intentPhrases?: SortOrder
    chatModel?: SortOrder
    runAllModels?: SortOrder
    locationContext?: SortOrder
  }

  export type DomainSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DomainNullableRelationFilter = {
    is?: DomainWhereInput | null
    isNot?: DomainWhereInput | null
  }

  export type CrawlResultCountOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    pagesScanned?: SortOrder
    analyzedUrls?: SortOrder
    extractedContext?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
  }

  export type CrawlResultAvgOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    pagesScanned?: SortOrder
    tokenUsage?: SortOrder
  }

  export type CrawlResultMaxOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    pagesScanned?: SortOrder
    analyzedUrls?: SortOrder
    extractedContext?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
  }

  export type CrawlResultMinOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    pagesScanned?: SortOrder
    analyzedUrls?: SortOrder
    extractedContext?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
  }

  export type CrawlResultSumOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    pagesScanned?: SortOrder
    tokenUsage?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type PhraseListRelationFilter = {
    every?: PhraseWhereInput
    some?: PhraseWhereInput
    none?: PhraseWhereInput
  }

  export type PhraseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KeywordTermDomainIdCompoundUniqueInput = {
    term: string
    domainId: number
  }

  export type KeywordCountOrderByAggregateInput = {
    id?: SortOrder
    term?: SortOrder
    volume?: SortOrder
    difficulty?: SortOrder
    cpc?: SortOrder
    intent?: SortOrder
    domainId?: SortOrder
    isSelected?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeywordAvgOrderByAggregateInput = {
    id?: SortOrder
    volume?: SortOrder
    cpc?: SortOrder
    domainId?: SortOrder
  }

  export type KeywordMaxOrderByAggregateInput = {
    id?: SortOrder
    term?: SortOrder
    volume?: SortOrder
    difficulty?: SortOrder
    cpc?: SortOrder
    intent?: SortOrder
    domainId?: SortOrder
    isSelected?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeywordMinOrderByAggregateInput = {
    id?: SortOrder
    term?: SortOrder
    volume?: SortOrder
    difficulty?: SortOrder
    cpc?: SortOrder
    intent?: SortOrder
    domainId?: SortOrder
    isSelected?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeywordSumOrderByAggregateInput = {
    id?: SortOrder
    volume?: SortOrder
    cpc?: SortOrder
    domainId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type KeywordRelationFilter = {
    is?: KeywordWhereInput
    isNot?: KeywordWhereInput
  }

  export type PhraseIntentClassificationListRelationFilter = {
    every?: PhraseIntentClassificationWhereInput
    some?: PhraseIntentClassificationWhereInput
    none?: PhraseIntentClassificationWhereInput
  }

  export type PhraseScoreListRelationFilter = {
    every?: PhraseScoreWhereInput
    some?: PhraseScoreWhereInput
    none?: PhraseScoreWhereInput
  }

  export type PhraseIntentClassificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PhraseScoreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PhraseCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    keywordId?: SortOrder
    relevanceScore?: SortOrder
    sources?: SortOrder
    trend?: SortOrder
    intent?: SortOrder
    confidence?: SortOrder
    isSelected?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhraseAvgOrderByAggregateInput = {
    id?: SortOrder
    keywordId?: SortOrder
    relevanceScore?: SortOrder
    confidence?: SortOrder
  }

  export type PhraseMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    keywordId?: SortOrder
    relevanceScore?: SortOrder
    trend?: SortOrder
    intent?: SortOrder
    confidence?: SortOrder
    isSelected?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhraseMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    keywordId?: SortOrder
    relevanceScore?: SortOrder
    trend?: SortOrder
    intent?: SortOrder
    confidence?: SortOrder
    isSelected?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhraseSumOrderByAggregateInput = {
    id?: SortOrder
    keywordId?: SortOrder
    relevanceScore?: SortOrder
    confidence?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type GeneratedIntentPhraseRelationFilter = {
    is?: GeneratedIntentPhraseWhereInput
    isNot?: GeneratedIntentPhraseWhereInput
  }

  export type AIQueryResultCountOrderByAggregateInput = {
    id?: SortOrder
    phraseId?: SortOrder
    model?: SortOrder
    response?: SortOrder
    latency?: SortOrder
    cost?: SortOrder
    presence?: SortOrder
    relevance?: SortOrder
    accuracy?: SortOrder
    sentiment?: SortOrder
    overall?: SortOrder
    createdAt?: SortOrder
  }

  export type AIQueryResultAvgOrderByAggregateInput = {
    id?: SortOrder
    phraseId?: SortOrder
    latency?: SortOrder
    cost?: SortOrder
    presence?: SortOrder
    relevance?: SortOrder
    accuracy?: SortOrder
    sentiment?: SortOrder
    overall?: SortOrder
  }

  export type AIQueryResultMaxOrderByAggregateInput = {
    id?: SortOrder
    phraseId?: SortOrder
    model?: SortOrder
    response?: SortOrder
    latency?: SortOrder
    cost?: SortOrder
    presence?: SortOrder
    relevance?: SortOrder
    accuracy?: SortOrder
    sentiment?: SortOrder
    overall?: SortOrder
    createdAt?: SortOrder
  }

  export type AIQueryResultMinOrderByAggregateInput = {
    id?: SortOrder
    phraseId?: SortOrder
    model?: SortOrder
    response?: SortOrder
    latency?: SortOrder
    cost?: SortOrder
    presence?: SortOrder
    relevance?: SortOrder
    accuracy?: SortOrder
    sentiment?: SortOrder
    overall?: SortOrder
    createdAt?: SortOrder
  }

  export type AIQueryResultSumOrderByAggregateInput = {
    id?: SortOrder
    phraseId?: SortOrder
    latency?: SortOrder
    cost?: SortOrder
    presence?: SortOrder
    relevance?: SortOrder
    accuracy?: SortOrder
    sentiment?: SortOrder
    overall?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DashboardAnalysisCountOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    metrics?: SortOrder
    insights?: SortOrder
    industryAnalysis?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DashboardAnalysisAvgOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
  }

  export type DashboardAnalysisMaxOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DashboardAnalysisMinOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DashboardAnalysisSumOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type CompetitorAnalysisCountOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    competitors?: SortOrder
    marketInsights?: SortOrder
    strategicRecommendations?: SortOrder
    competitiveAnalysis?: SortOrder
    competitorList?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompetitorAnalysisAvgOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
  }

  export type CompetitorAnalysisMaxOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    competitorList?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompetitorAnalysisMinOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    competitorList?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompetitorAnalysisSumOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
  }

  export type SuggestedCompetitorCountOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    name?: SortOrder
    competitorDomain?: SortOrder
    reason?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type SuggestedCompetitorAvgOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
  }

  export type SuggestedCompetitorMaxOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    name?: SortOrder
    competitorDomain?: SortOrder
    reason?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type SuggestedCompetitorMinOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    name?: SortOrder
    competitorDomain?: SortOrder
    reason?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type SuggestedCompetitorSumOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AnalysisPhaseDomainIdPhaseCompoundUniqueInput = {
    domainId: number
    phase: string
  }

  export type AnalysisPhaseCountOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    phase?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    result?: SortOrder
    error?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalysisPhaseAvgOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    progress?: SortOrder
    tokenUsage?: SortOrder
  }

  export type AnalysisPhaseMaxOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    phase?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    error?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalysisPhaseMinOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    phase?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    error?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalysisPhaseSumOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    progress?: SortOrder
    tokenUsage?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type SemanticAnalysisCountOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    contentSummary?: SortOrder
    keyThemes?: SortOrder
    brandVoice?: SortOrder
    targetAudience?: SortOrder
    contentGaps?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SemanticAnalysisAvgOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    tokenUsage?: SortOrder
  }

  export type SemanticAnalysisMaxOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    contentSummary?: SortOrder
    brandVoice?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SemanticAnalysisMinOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    contentSummary?: SortOrder
    brandVoice?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SemanticAnalysisSumOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    tokenUsage?: SortOrder
  }

  export type KeywordAnalysisCountOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywords?: SortOrder
    searchVolumeData?: SortOrder
    intentClassification?: SortOrder
    competitiveAnalysis?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeywordAnalysisAvgOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    tokenUsage?: SortOrder
  }

  export type KeywordAnalysisMaxOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeywordAnalysisMinOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeywordAnalysisSumOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    tokenUsage?: SortOrder
  }

  export type SearchVolumeClassificationCountOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    highVolumeKeywords?: SortOrder
    mediumVolumeKeywords?: SortOrder
    lowVolumeKeywords?: SortOrder
    volumeTrends?: SortOrder
    seasonalPatterns?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SearchVolumeClassificationAvgOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    tokenUsage?: SortOrder
  }

  export type SearchVolumeClassificationMaxOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SearchVolumeClassificationMinOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SearchVolumeClassificationSumOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    tokenUsage?: SortOrder
  }

  export type IntentClassificationCountOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    informationalKeywords?: SortOrder
    navigationalKeywords?: SortOrder
    transactionalKeywords?: SortOrder
    commercialKeywords?: SortOrder
    intentDistribution?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntentClassificationAvgOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    tokenUsage?: SortOrder
  }

  export type IntentClassificationMaxOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntentClassificationMinOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntentClassificationSumOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    tokenUsage?: SortOrder
  }

  export type KeywordNullableRelationFilter = {
    is?: KeywordWhereInput | null
    isNot?: KeywordWhereInput | null
  }

  export type CommunityInsightCountOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    sources?: SortOrder
    summary?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
  }

  export type CommunityInsightAvgOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    tokenUsage?: SortOrder
  }

  export type CommunityInsightMaxOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    summary?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
  }

  export type CommunityInsightMinOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    summary?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
  }

  export type CommunityInsightSumOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    tokenUsage?: SortOrder
  }

  export type SearchPatternCountOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    patterns?: SortOrder
    summary?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchPatternAvgOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    tokenUsage?: SortOrder
  }

  export type SearchPatternMaxOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    summary?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchPatternMinOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    summary?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchPatternSumOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    tokenUsage?: SortOrder
  }

  export type PhraseRelationFilter = {
    is?: PhraseWhereInput
    isNot?: PhraseWhereInput
  }

  export type PhraseIntentClassificationCountOrderByAggregateInput = {
    id?: SortOrder
    phraseId?: SortOrder
    intent?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
  }

  export type PhraseIntentClassificationAvgOrderByAggregateInput = {
    id?: SortOrder
    phraseId?: SortOrder
    confidence?: SortOrder
  }

  export type PhraseIntentClassificationMaxOrderByAggregateInput = {
    id?: SortOrder
    phraseId?: SortOrder
    intent?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
  }

  export type PhraseIntentClassificationMinOrderByAggregateInput = {
    id?: SortOrder
    phraseId?: SortOrder
    intent?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
  }

  export type PhraseIntentClassificationSumOrderByAggregateInput = {
    id?: SortOrder
    phraseId?: SortOrder
    confidence?: SortOrder
  }

  export type PhraseScoreCountOrderByAggregateInput = {
    id?: SortOrder
    phraseId?: SortOrder
    score?: SortOrder
    breakdown?: SortOrder
    createdAt?: SortOrder
  }

  export type PhraseScoreAvgOrderByAggregateInput = {
    id?: SortOrder
    phraseId?: SortOrder
    score?: SortOrder
  }

  export type PhraseScoreMaxOrderByAggregateInput = {
    id?: SortOrder
    phraseId?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
  }

  export type PhraseScoreMinOrderByAggregateInput = {
    id?: SortOrder
    phraseId?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
  }

  export type PhraseScoreSumOrderByAggregateInput = {
    id?: SortOrder
    phraseId?: SortOrder
    score?: SortOrder
  }

  export type IntentPhraseGenerationCountOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    status?: SortOrder
    phase?: SortOrder
    progress?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    result?: SortOrder
    error?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntentPhraseGenerationAvgOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    progress?: SortOrder
    tokenUsage?: SortOrder
  }

  export type IntentPhraseGenerationMaxOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    status?: SortOrder
    phase?: SortOrder
    progress?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    error?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntentPhraseGenerationMinOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    status?: SortOrder
    phase?: SortOrder
    progress?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    error?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntentPhraseGenerationSumOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    progress?: SortOrder
    tokenUsage?: SortOrder
  }

  export type CommunityMiningResultCountOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    platform?: SortOrder
    insights?: SortOrder
    sentiment?: SortOrder
    frequency?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
  }

  export type CommunityMiningResultAvgOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    frequency?: SortOrder
    tokenUsage?: SortOrder
  }

  export type CommunityMiningResultMaxOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    platform?: SortOrder
    sentiment?: SortOrder
    frequency?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
  }

  export type CommunityMiningResultMinOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    platform?: SortOrder
    sentiment?: SortOrder
    frequency?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
  }

  export type CommunityMiningResultSumOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    frequency?: SortOrder
    tokenUsage?: SortOrder
  }

  export type SearchPatternResultCountOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    patterns?: SortOrder
    volume?: SortOrder
    seasonality?: SortOrder
    trends?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchPatternResultAvgOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    volume?: SortOrder
    tokenUsage?: SortOrder
  }

  export type SearchPatternResultMaxOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    volume?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchPatternResultMinOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    volume?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchPatternResultSumOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    volume?: SortOrder
    tokenUsage?: SortOrder
  }

  export type IntentClassificationResultCountOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    intent?: SortOrder
    confidence?: SortOrder
    patterns?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
  }

  export type IntentClassificationResultAvgOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    confidence?: SortOrder
    tokenUsage?: SortOrder
  }

  export type IntentClassificationResultMaxOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    intent?: SortOrder
    confidence?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
  }

  export type IntentClassificationResultMinOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    intent?: SortOrder
    confidence?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
  }

  export type IntentClassificationResultSumOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    confidence?: SortOrder
    tokenUsage?: SortOrder
  }

  export type AIQueryResultListRelationFilter = {
    every?: AIQueryResultWhereInput
    some?: AIQueryResultWhereInput
    none?: AIQueryResultWhereInput
  }

  export type AIQueryResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GeneratedIntentPhraseCountOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    phrase?: SortOrder
    relevanceScore?: SortOrder
    intent?: SortOrder
    intentConfidence?: SortOrder
    sources?: SortOrder
    trend?: SortOrder
    communityInsights?: SortOrder
    searchPatterns?: SortOrder
    isSelected?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GeneratedIntentPhraseAvgOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    relevanceScore?: SortOrder
    intentConfidence?: SortOrder
    tokenUsage?: SortOrder
  }

  export type GeneratedIntentPhraseMaxOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    phrase?: SortOrder
    relevanceScore?: SortOrder
    intent?: SortOrder
    intentConfidence?: SortOrder
    trend?: SortOrder
    isSelected?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GeneratedIntentPhraseMinOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    phrase?: SortOrder
    relevanceScore?: SortOrder
    intent?: SortOrder
    intentConfidence?: SortOrder
    trend?: SortOrder
    isSelected?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GeneratedIntentPhraseSumOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    keywordId?: SortOrder
    relevanceScore?: SortOrder
    intentConfidence?: SortOrder
    tokenUsage?: SortOrder
  }

  export type GeneratedIntentPhraseNullableRelationFilter = {
    is?: GeneratedIntentPhraseWhereInput | null
    isNot?: GeneratedIntentPhraseWhereInput | null
  }

  export type RelevanceScoreResultCountOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    phraseId?: SortOrder
    score?: SortOrder
    breakdown?: SortOrder
    factors?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
  }

  export type RelevanceScoreResultAvgOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    phraseId?: SortOrder
    score?: SortOrder
    tokenUsage?: SortOrder
  }

  export type RelevanceScoreResultMaxOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    phraseId?: SortOrder
    score?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
  }

  export type RelevanceScoreResultMinOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    phraseId?: SortOrder
    score?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
  }

  export type RelevanceScoreResultSumOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    phraseId?: SortOrder
    score?: SortOrder
    tokenUsage?: SortOrder
  }

  export type DomainCreateNestedManyWithoutUserInput = {
    create?: XOR<DomainCreateWithoutUserInput, DomainUncheckedCreateWithoutUserInput> | DomainCreateWithoutUserInput[] | DomainUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DomainCreateOrConnectWithoutUserInput | DomainCreateOrConnectWithoutUserInput[]
    createMany?: DomainCreateManyUserInputEnvelope
    connect?: DomainWhereUniqueInput | DomainWhereUniqueInput[]
  }

  export type DomainUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DomainCreateWithoutUserInput, DomainUncheckedCreateWithoutUserInput> | DomainCreateWithoutUserInput[] | DomainUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DomainCreateOrConnectWithoutUserInput | DomainCreateOrConnectWithoutUserInput[]
    createMany?: DomainCreateManyUserInputEnvelope
    connect?: DomainWhereUniqueInput | DomainWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DomainUpdateManyWithoutUserNestedInput = {
    create?: XOR<DomainCreateWithoutUserInput, DomainUncheckedCreateWithoutUserInput> | DomainCreateWithoutUserInput[] | DomainUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DomainCreateOrConnectWithoutUserInput | DomainCreateOrConnectWithoutUserInput[]
    upsert?: DomainUpsertWithWhereUniqueWithoutUserInput | DomainUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DomainCreateManyUserInputEnvelope
    set?: DomainWhereUniqueInput | DomainWhereUniqueInput[]
    disconnect?: DomainWhereUniqueInput | DomainWhereUniqueInput[]
    delete?: DomainWhereUniqueInput | DomainWhereUniqueInput[]
    connect?: DomainWhereUniqueInput | DomainWhereUniqueInput[]
    update?: DomainUpdateWithWhereUniqueWithoutUserInput | DomainUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DomainUpdateManyWithWhereWithoutUserInput | DomainUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DomainScalarWhereInput | DomainScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DomainUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DomainCreateWithoutUserInput, DomainUncheckedCreateWithoutUserInput> | DomainCreateWithoutUserInput[] | DomainUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DomainCreateOrConnectWithoutUserInput | DomainCreateOrConnectWithoutUserInput[]
    upsert?: DomainUpsertWithWhereUniqueWithoutUserInput | DomainUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DomainCreateManyUserInputEnvelope
    set?: DomainWhereUniqueInput | DomainWhereUniqueInput[]
    disconnect?: DomainWhereUniqueInput | DomainWhereUniqueInput[]
    delete?: DomainWhereUniqueInput | DomainWhereUniqueInput[]
    connect?: DomainWhereUniqueInput | DomainWhereUniqueInput[]
    update?: DomainUpdateWithWhereUniqueWithoutUserInput | DomainUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DomainUpdateManyWithWhereWithoutUserInput | DomainUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DomainScalarWhereInput | DomainScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDomainsInput = {
    create?: XOR<UserCreateWithoutDomainsInput, UserUncheckedCreateWithoutDomainsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDomainsInput
    connect?: UserWhereUniqueInput
  }

  export type CrawlResultCreateNestedManyWithoutDomainInput = {
    create?: XOR<CrawlResultCreateWithoutDomainInput, CrawlResultUncheckedCreateWithoutDomainInput> | CrawlResultCreateWithoutDomainInput[] | CrawlResultUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: CrawlResultCreateOrConnectWithoutDomainInput | CrawlResultCreateOrConnectWithoutDomainInput[]
    createMany?: CrawlResultCreateManyDomainInputEnvelope
    connect?: CrawlResultWhereUniqueInput | CrawlResultWhereUniqueInput[]
  }

  export type KeywordCreateNestedManyWithoutDomainInput = {
    create?: XOR<KeywordCreateWithoutDomainInput, KeywordUncheckedCreateWithoutDomainInput> | KeywordCreateWithoutDomainInput[] | KeywordUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: KeywordCreateOrConnectWithoutDomainInput | KeywordCreateOrConnectWithoutDomainInput[]
    createMany?: KeywordCreateManyDomainInputEnvelope
    connect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
  }

  export type DashboardAnalysisCreateNestedManyWithoutDomainInput = {
    create?: XOR<DashboardAnalysisCreateWithoutDomainInput, DashboardAnalysisUncheckedCreateWithoutDomainInput> | DashboardAnalysisCreateWithoutDomainInput[] | DashboardAnalysisUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: DashboardAnalysisCreateOrConnectWithoutDomainInput | DashboardAnalysisCreateOrConnectWithoutDomainInput[]
    createMany?: DashboardAnalysisCreateManyDomainInputEnvelope
    connect?: DashboardAnalysisWhereUniqueInput | DashboardAnalysisWhereUniqueInput[]
  }

  export type CompetitorAnalysisCreateNestedManyWithoutDomainInput = {
    create?: XOR<CompetitorAnalysisCreateWithoutDomainInput, CompetitorAnalysisUncheckedCreateWithoutDomainInput> | CompetitorAnalysisCreateWithoutDomainInput[] | CompetitorAnalysisUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: CompetitorAnalysisCreateOrConnectWithoutDomainInput | CompetitorAnalysisCreateOrConnectWithoutDomainInput[]
    createMany?: CompetitorAnalysisCreateManyDomainInputEnvelope
    connect?: CompetitorAnalysisWhereUniqueInput | CompetitorAnalysisWhereUniqueInput[]
  }

  export type SuggestedCompetitorCreateNestedManyWithoutDomainInput = {
    create?: XOR<SuggestedCompetitorCreateWithoutDomainInput, SuggestedCompetitorUncheckedCreateWithoutDomainInput> | SuggestedCompetitorCreateWithoutDomainInput[] | SuggestedCompetitorUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: SuggestedCompetitorCreateOrConnectWithoutDomainInput | SuggestedCompetitorCreateOrConnectWithoutDomainInput[]
    createMany?: SuggestedCompetitorCreateManyDomainInputEnvelope
    connect?: SuggestedCompetitorWhereUniqueInput | SuggestedCompetitorWhereUniqueInput[]
  }

  export type AnalysisPhaseCreateNestedManyWithoutDomainInput = {
    create?: XOR<AnalysisPhaseCreateWithoutDomainInput, AnalysisPhaseUncheckedCreateWithoutDomainInput> | AnalysisPhaseCreateWithoutDomainInput[] | AnalysisPhaseUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: AnalysisPhaseCreateOrConnectWithoutDomainInput | AnalysisPhaseCreateOrConnectWithoutDomainInput[]
    createMany?: AnalysisPhaseCreateManyDomainInputEnvelope
    connect?: AnalysisPhaseWhereUniqueInput | AnalysisPhaseWhereUniqueInput[]
  }

  export type SemanticAnalysisCreateNestedManyWithoutDomainInput = {
    create?: XOR<SemanticAnalysisCreateWithoutDomainInput, SemanticAnalysisUncheckedCreateWithoutDomainInput> | SemanticAnalysisCreateWithoutDomainInput[] | SemanticAnalysisUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: SemanticAnalysisCreateOrConnectWithoutDomainInput | SemanticAnalysisCreateOrConnectWithoutDomainInput[]
    createMany?: SemanticAnalysisCreateManyDomainInputEnvelope
    connect?: SemanticAnalysisWhereUniqueInput | SemanticAnalysisWhereUniqueInput[]
  }

  export type KeywordAnalysisCreateNestedManyWithoutDomainInput = {
    create?: XOR<KeywordAnalysisCreateWithoutDomainInput, KeywordAnalysisUncheckedCreateWithoutDomainInput> | KeywordAnalysisCreateWithoutDomainInput[] | KeywordAnalysisUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: KeywordAnalysisCreateOrConnectWithoutDomainInput | KeywordAnalysisCreateOrConnectWithoutDomainInput[]
    createMany?: KeywordAnalysisCreateManyDomainInputEnvelope
    connect?: KeywordAnalysisWhereUniqueInput | KeywordAnalysisWhereUniqueInput[]
  }

  export type SearchVolumeClassificationCreateNestedManyWithoutDomainInput = {
    create?: XOR<SearchVolumeClassificationCreateWithoutDomainInput, SearchVolumeClassificationUncheckedCreateWithoutDomainInput> | SearchVolumeClassificationCreateWithoutDomainInput[] | SearchVolumeClassificationUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: SearchVolumeClassificationCreateOrConnectWithoutDomainInput | SearchVolumeClassificationCreateOrConnectWithoutDomainInput[]
    createMany?: SearchVolumeClassificationCreateManyDomainInputEnvelope
    connect?: SearchVolumeClassificationWhereUniqueInput | SearchVolumeClassificationWhereUniqueInput[]
  }

  export type IntentClassificationCreateNestedManyWithoutDomainInput = {
    create?: XOR<IntentClassificationCreateWithoutDomainInput, IntentClassificationUncheckedCreateWithoutDomainInput> | IntentClassificationCreateWithoutDomainInput[] | IntentClassificationUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: IntentClassificationCreateOrConnectWithoutDomainInput | IntentClassificationCreateOrConnectWithoutDomainInput[]
    createMany?: IntentClassificationCreateManyDomainInputEnvelope
    connect?: IntentClassificationWhereUniqueInput | IntentClassificationWhereUniqueInput[]
  }

  export type CommunityInsightCreateNestedManyWithoutDomainInput = {
    create?: XOR<CommunityInsightCreateWithoutDomainInput, CommunityInsightUncheckedCreateWithoutDomainInput> | CommunityInsightCreateWithoutDomainInput[] | CommunityInsightUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: CommunityInsightCreateOrConnectWithoutDomainInput | CommunityInsightCreateOrConnectWithoutDomainInput[]
    createMany?: CommunityInsightCreateManyDomainInputEnvelope
    connect?: CommunityInsightWhereUniqueInput | CommunityInsightWhereUniqueInput[]
  }

  export type SearchPatternCreateNestedManyWithoutDomainInput = {
    create?: XOR<SearchPatternCreateWithoutDomainInput, SearchPatternUncheckedCreateWithoutDomainInput> | SearchPatternCreateWithoutDomainInput[] | SearchPatternUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: SearchPatternCreateOrConnectWithoutDomainInput | SearchPatternCreateOrConnectWithoutDomainInput[]
    createMany?: SearchPatternCreateManyDomainInputEnvelope
    connect?: SearchPatternWhereUniqueInput | SearchPatternWhereUniqueInput[]
  }

  export type IntentPhraseGenerationCreateNestedManyWithoutDomainInput = {
    create?: XOR<IntentPhraseGenerationCreateWithoutDomainInput, IntentPhraseGenerationUncheckedCreateWithoutDomainInput> | IntentPhraseGenerationCreateWithoutDomainInput[] | IntentPhraseGenerationUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: IntentPhraseGenerationCreateOrConnectWithoutDomainInput | IntentPhraseGenerationCreateOrConnectWithoutDomainInput[]
    createMany?: IntentPhraseGenerationCreateManyDomainInputEnvelope
    connect?: IntentPhraseGenerationWhereUniqueInput | IntentPhraseGenerationWhereUniqueInput[]
  }

  export type CommunityMiningResultCreateNestedManyWithoutDomainInput = {
    create?: XOR<CommunityMiningResultCreateWithoutDomainInput, CommunityMiningResultUncheckedCreateWithoutDomainInput> | CommunityMiningResultCreateWithoutDomainInput[] | CommunityMiningResultUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: CommunityMiningResultCreateOrConnectWithoutDomainInput | CommunityMiningResultCreateOrConnectWithoutDomainInput[]
    createMany?: CommunityMiningResultCreateManyDomainInputEnvelope
    connect?: CommunityMiningResultWhereUniqueInput | CommunityMiningResultWhereUniqueInput[]
  }

  export type SearchPatternResultCreateNestedManyWithoutDomainInput = {
    create?: XOR<SearchPatternResultCreateWithoutDomainInput, SearchPatternResultUncheckedCreateWithoutDomainInput> | SearchPatternResultCreateWithoutDomainInput[] | SearchPatternResultUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: SearchPatternResultCreateOrConnectWithoutDomainInput | SearchPatternResultCreateOrConnectWithoutDomainInput[]
    createMany?: SearchPatternResultCreateManyDomainInputEnvelope
    connect?: SearchPatternResultWhereUniqueInput | SearchPatternResultWhereUniqueInput[]
  }

  export type IntentClassificationResultCreateNestedManyWithoutDomainInput = {
    create?: XOR<IntentClassificationResultCreateWithoutDomainInput, IntentClassificationResultUncheckedCreateWithoutDomainInput> | IntentClassificationResultCreateWithoutDomainInput[] | IntentClassificationResultUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: IntentClassificationResultCreateOrConnectWithoutDomainInput | IntentClassificationResultCreateOrConnectWithoutDomainInput[]
    createMany?: IntentClassificationResultCreateManyDomainInputEnvelope
    connect?: IntentClassificationResultWhereUniqueInput | IntentClassificationResultWhereUniqueInput[]
  }

  export type GeneratedIntentPhraseCreateNestedManyWithoutDomainInput = {
    create?: XOR<GeneratedIntentPhraseCreateWithoutDomainInput, GeneratedIntentPhraseUncheckedCreateWithoutDomainInput> | GeneratedIntentPhraseCreateWithoutDomainInput[] | GeneratedIntentPhraseUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: GeneratedIntentPhraseCreateOrConnectWithoutDomainInput | GeneratedIntentPhraseCreateOrConnectWithoutDomainInput[]
    createMany?: GeneratedIntentPhraseCreateManyDomainInputEnvelope
    connect?: GeneratedIntentPhraseWhereUniqueInput | GeneratedIntentPhraseWhereUniqueInput[]
  }

  export type RelevanceScoreResultCreateNestedManyWithoutDomainInput = {
    create?: XOR<RelevanceScoreResultCreateWithoutDomainInput, RelevanceScoreResultUncheckedCreateWithoutDomainInput> | RelevanceScoreResultCreateWithoutDomainInput[] | RelevanceScoreResultUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: RelevanceScoreResultCreateOrConnectWithoutDomainInput | RelevanceScoreResultCreateOrConnectWithoutDomainInput[]
    createMany?: RelevanceScoreResultCreateManyDomainInputEnvelope
    connect?: RelevanceScoreResultWhereUniqueInput | RelevanceScoreResultWhereUniqueInput[]
  }

  export type CrawlResultUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<CrawlResultCreateWithoutDomainInput, CrawlResultUncheckedCreateWithoutDomainInput> | CrawlResultCreateWithoutDomainInput[] | CrawlResultUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: CrawlResultCreateOrConnectWithoutDomainInput | CrawlResultCreateOrConnectWithoutDomainInput[]
    createMany?: CrawlResultCreateManyDomainInputEnvelope
    connect?: CrawlResultWhereUniqueInput | CrawlResultWhereUniqueInput[]
  }

  export type KeywordUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<KeywordCreateWithoutDomainInput, KeywordUncheckedCreateWithoutDomainInput> | KeywordCreateWithoutDomainInput[] | KeywordUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: KeywordCreateOrConnectWithoutDomainInput | KeywordCreateOrConnectWithoutDomainInput[]
    createMany?: KeywordCreateManyDomainInputEnvelope
    connect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
  }

  export type DashboardAnalysisUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<DashboardAnalysisCreateWithoutDomainInput, DashboardAnalysisUncheckedCreateWithoutDomainInput> | DashboardAnalysisCreateWithoutDomainInput[] | DashboardAnalysisUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: DashboardAnalysisCreateOrConnectWithoutDomainInput | DashboardAnalysisCreateOrConnectWithoutDomainInput[]
    createMany?: DashboardAnalysisCreateManyDomainInputEnvelope
    connect?: DashboardAnalysisWhereUniqueInput | DashboardAnalysisWhereUniqueInput[]
  }

  export type CompetitorAnalysisUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<CompetitorAnalysisCreateWithoutDomainInput, CompetitorAnalysisUncheckedCreateWithoutDomainInput> | CompetitorAnalysisCreateWithoutDomainInput[] | CompetitorAnalysisUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: CompetitorAnalysisCreateOrConnectWithoutDomainInput | CompetitorAnalysisCreateOrConnectWithoutDomainInput[]
    createMany?: CompetitorAnalysisCreateManyDomainInputEnvelope
    connect?: CompetitorAnalysisWhereUniqueInput | CompetitorAnalysisWhereUniqueInput[]
  }

  export type SuggestedCompetitorUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<SuggestedCompetitorCreateWithoutDomainInput, SuggestedCompetitorUncheckedCreateWithoutDomainInput> | SuggestedCompetitorCreateWithoutDomainInput[] | SuggestedCompetitorUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: SuggestedCompetitorCreateOrConnectWithoutDomainInput | SuggestedCompetitorCreateOrConnectWithoutDomainInput[]
    createMany?: SuggestedCompetitorCreateManyDomainInputEnvelope
    connect?: SuggestedCompetitorWhereUniqueInput | SuggestedCompetitorWhereUniqueInput[]
  }

  export type AnalysisPhaseUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<AnalysisPhaseCreateWithoutDomainInput, AnalysisPhaseUncheckedCreateWithoutDomainInput> | AnalysisPhaseCreateWithoutDomainInput[] | AnalysisPhaseUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: AnalysisPhaseCreateOrConnectWithoutDomainInput | AnalysisPhaseCreateOrConnectWithoutDomainInput[]
    createMany?: AnalysisPhaseCreateManyDomainInputEnvelope
    connect?: AnalysisPhaseWhereUniqueInput | AnalysisPhaseWhereUniqueInput[]
  }

  export type SemanticAnalysisUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<SemanticAnalysisCreateWithoutDomainInput, SemanticAnalysisUncheckedCreateWithoutDomainInput> | SemanticAnalysisCreateWithoutDomainInput[] | SemanticAnalysisUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: SemanticAnalysisCreateOrConnectWithoutDomainInput | SemanticAnalysisCreateOrConnectWithoutDomainInput[]
    createMany?: SemanticAnalysisCreateManyDomainInputEnvelope
    connect?: SemanticAnalysisWhereUniqueInput | SemanticAnalysisWhereUniqueInput[]
  }

  export type KeywordAnalysisUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<KeywordAnalysisCreateWithoutDomainInput, KeywordAnalysisUncheckedCreateWithoutDomainInput> | KeywordAnalysisCreateWithoutDomainInput[] | KeywordAnalysisUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: KeywordAnalysisCreateOrConnectWithoutDomainInput | KeywordAnalysisCreateOrConnectWithoutDomainInput[]
    createMany?: KeywordAnalysisCreateManyDomainInputEnvelope
    connect?: KeywordAnalysisWhereUniqueInput | KeywordAnalysisWhereUniqueInput[]
  }

  export type SearchVolumeClassificationUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<SearchVolumeClassificationCreateWithoutDomainInput, SearchVolumeClassificationUncheckedCreateWithoutDomainInput> | SearchVolumeClassificationCreateWithoutDomainInput[] | SearchVolumeClassificationUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: SearchVolumeClassificationCreateOrConnectWithoutDomainInput | SearchVolumeClassificationCreateOrConnectWithoutDomainInput[]
    createMany?: SearchVolumeClassificationCreateManyDomainInputEnvelope
    connect?: SearchVolumeClassificationWhereUniqueInput | SearchVolumeClassificationWhereUniqueInput[]
  }

  export type IntentClassificationUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<IntentClassificationCreateWithoutDomainInput, IntentClassificationUncheckedCreateWithoutDomainInput> | IntentClassificationCreateWithoutDomainInput[] | IntentClassificationUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: IntentClassificationCreateOrConnectWithoutDomainInput | IntentClassificationCreateOrConnectWithoutDomainInput[]
    createMany?: IntentClassificationCreateManyDomainInputEnvelope
    connect?: IntentClassificationWhereUniqueInput | IntentClassificationWhereUniqueInput[]
  }

  export type CommunityInsightUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<CommunityInsightCreateWithoutDomainInput, CommunityInsightUncheckedCreateWithoutDomainInput> | CommunityInsightCreateWithoutDomainInput[] | CommunityInsightUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: CommunityInsightCreateOrConnectWithoutDomainInput | CommunityInsightCreateOrConnectWithoutDomainInput[]
    createMany?: CommunityInsightCreateManyDomainInputEnvelope
    connect?: CommunityInsightWhereUniqueInput | CommunityInsightWhereUniqueInput[]
  }

  export type SearchPatternUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<SearchPatternCreateWithoutDomainInput, SearchPatternUncheckedCreateWithoutDomainInput> | SearchPatternCreateWithoutDomainInput[] | SearchPatternUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: SearchPatternCreateOrConnectWithoutDomainInput | SearchPatternCreateOrConnectWithoutDomainInput[]
    createMany?: SearchPatternCreateManyDomainInputEnvelope
    connect?: SearchPatternWhereUniqueInput | SearchPatternWhereUniqueInput[]
  }

  export type IntentPhraseGenerationUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<IntentPhraseGenerationCreateWithoutDomainInput, IntentPhraseGenerationUncheckedCreateWithoutDomainInput> | IntentPhraseGenerationCreateWithoutDomainInput[] | IntentPhraseGenerationUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: IntentPhraseGenerationCreateOrConnectWithoutDomainInput | IntentPhraseGenerationCreateOrConnectWithoutDomainInput[]
    createMany?: IntentPhraseGenerationCreateManyDomainInputEnvelope
    connect?: IntentPhraseGenerationWhereUniqueInput | IntentPhraseGenerationWhereUniqueInput[]
  }

  export type CommunityMiningResultUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<CommunityMiningResultCreateWithoutDomainInput, CommunityMiningResultUncheckedCreateWithoutDomainInput> | CommunityMiningResultCreateWithoutDomainInput[] | CommunityMiningResultUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: CommunityMiningResultCreateOrConnectWithoutDomainInput | CommunityMiningResultCreateOrConnectWithoutDomainInput[]
    createMany?: CommunityMiningResultCreateManyDomainInputEnvelope
    connect?: CommunityMiningResultWhereUniqueInput | CommunityMiningResultWhereUniqueInput[]
  }

  export type SearchPatternResultUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<SearchPatternResultCreateWithoutDomainInput, SearchPatternResultUncheckedCreateWithoutDomainInput> | SearchPatternResultCreateWithoutDomainInput[] | SearchPatternResultUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: SearchPatternResultCreateOrConnectWithoutDomainInput | SearchPatternResultCreateOrConnectWithoutDomainInput[]
    createMany?: SearchPatternResultCreateManyDomainInputEnvelope
    connect?: SearchPatternResultWhereUniqueInput | SearchPatternResultWhereUniqueInput[]
  }

  export type IntentClassificationResultUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<IntentClassificationResultCreateWithoutDomainInput, IntentClassificationResultUncheckedCreateWithoutDomainInput> | IntentClassificationResultCreateWithoutDomainInput[] | IntentClassificationResultUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: IntentClassificationResultCreateOrConnectWithoutDomainInput | IntentClassificationResultCreateOrConnectWithoutDomainInput[]
    createMany?: IntentClassificationResultCreateManyDomainInputEnvelope
    connect?: IntentClassificationResultWhereUniqueInput | IntentClassificationResultWhereUniqueInput[]
  }

  export type GeneratedIntentPhraseUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<GeneratedIntentPhraseCreateWithoutDomainInput, GeneratedIntentPhraseUncheckedCreateWithoutDomainInput> | GeneratedIntentPhraseCreateWithoutDomainInput[] | GeneratedIntentPhraseUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: GeneratedIntentPhraseCreateOrConnectWithoutDomainInput | GeneratedIntentPhraseCreateOrConnectWithoutDomainInput[]
    createMany?: GeneratedIntentPhraseCreateManyDomainInputEnvelope
    connect?: GeneratedIntentPhraseWhereUniqueInput | GeneratedIntentPhraseWhereUniqueInput[]
  }

  export type RelevanceScoreResultUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<RelevanceScoreResultCreateWithoutDomainInput, RelevanceScoreResultUncheckedCreateWithoutDomainInput> | RelevanceScoreResultCreateWithoutDomainInput[] | RelevanceScoreResultUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: RelevanceScoreResultCreateOrConnectWithoutDomainInput | RelevanceScoreResultCreateOrConnectWithoutDomainInput[]
    createMany?: RelevanceScoreResultCreateManyDomainInputEnvelope
    connect?: RelevanceScoreResultWhereUniqueInput | RelevanceScoreResultWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneWithoutDomainsNestedInput = {
    create?: XOR<UserCreateWithoutDomainsInput, UserUncheckedCreateWithoutDomainsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDomainsInput
    upsert?: UserUpsertWithoutDomainsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDomainsInput, UserUpdateWithoutDomainsInput>, UserUncheckedUpdateWithoutDomainsInput>
  }

  export type CrawlResultUpdateManyWithoutDomainNestedInput = {
    create?: XOR<CrawlResultCreateWithoutDomainInput, CrawlResultUncheckedCreateWithoutDomainInput> | CrawlResultCreateWithoutDomainInput[] | CrawlResultUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: CrawlResultCreateOrConnectWithoutDomainInput | CrawlResultCreateOrConnectWithoutDomainInput[]
    upsert?: CrawlResultUpsertWithWhereUniqueWithoutDomainInput | CrawlResultUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: CrawlResultCreateManyDomainInputEnvelope
    set?: CrawlResultWhereUniqueInput | CrawlResultWhereUniqueInput[]
    disconnect?: CrawlResultWhereUniqueInput | CrawlResultWhereUniqueInput[]
    delete?: CrawlResultWhereUniqueInput | CrawlResultWhereUniqueInput[]
    connect?: CrawlResultWhereUniqueInput | CrawlResultWhereUniqueInput[]
    update?: CrawlResultUpdateWithWhereUniqueWithoutDomainInput | CrawlResultUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: CrawlResultUpdateManyWithWhereWithoutDomainInput | CrawlResultUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: CrawlResultScalarWhereInput | CrawlResultScalarWhereInput[]
  }

  export type KeywordUpdateManyWithoutDomainNestedInput = {
    create?: XOR<KeywordCreateWithoutDomainInput, KeywordUncheckedCreateWithoutDomainInput> | KeywordCreateWithoutDomainInput[] | KeywordUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: KeywordCreateOrConnectWithoutDomainInput | KeywordCreateOrConnectWithoutDomainInput[]
    upsert?: KeywordUpsertWithWhereUniqueWithoutDomainInput | KeywordUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: KeywordCreateManyDomainInputEnvelope
    set?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    disconnect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    delete?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    connect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    update?: KeywordUpdateWithWhereUniqueWithoutDomainInput | KeywordUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: KeywordUpdateManyWithWhereWithoutDomainInput | KeywordUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: KeywordScalarWhereInput | KeywordScalarWhereInput[]
  }

  export type DashboardAnalysisUpdateManyWithoutDomainNestedInput = {
    create?: XOR<DashboardAnalysisCreateWithoutDomainInput, DashboardAnalysisUncheckedCreateWithoutDomainInput> | DashboardAnalysisCreateWithoutDomainInput[] | DashboardAnalysisUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: DashboardAnalysisCreateOrConnectWithoutDomainInput | DashboardAnalysisCreateOrConnectWithoutDomainInput[]
    upsert?: DashboardAnalysisUpsertWithWhereUniqueWithoutDomainInput | DashboardAnalysisUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: DashboardAnalysisCreateManyDomainInputEnvelope
    set?: DashboardAnalysisWhereUniqueInput | DashboardAnalysisWhereUniqueInput[]
    disconnect?: DashboardAnalysisWhereUniqueInput | DashboardAnalysisWhereUniqueInput[]
    delete?: DashboardAnalysisWhereUniqueInput | DashboardAnalysisWhereUniqueInput[]
    connect?: DashboardAnalysisWhereUniqueInput | DashboardAnalysisWhereUniqueInput[]
    update?: DashboardAnalysisUpdateWithWhereUniqueWithoutDomainInput | DashboardAnalysisUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: DashboardAnalysisUpdateManyWithWhereWithoutDomainInput | DashboardAnalysisUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: DashboardAnalysisScalarWhereInput | DashboardAnalysisScalarWhereInput[]
  }

  export type CompetitorAnalysisUpdateManyWithoutDomainNestedInput = {
    create?: XOR<CompetitorAnalysisCreateWithoutDomainInput, CompetitorAnalysisUncheckedCreateWithoutDomainInput> | CompetitorAnalysisCreateWithoutDomainInput[] | CompetitorAnalysisUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: CompetitorAnalysisCreateOrConnectWithoutDomainInput | CompetitorAnalysisCreateOrConnectWithoutDomainInput[]
    upsert?: CompetitorAnalysisUpsertWithWhereUniqueWithoutDomainInput | CompetitorAnalysisUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: CompetitorAnalysisCreateManyDomainInputEnvelope
    set?: CompetitorAnalysisWhereUniqueInput | CompetitorAnalysisWhereUniqueInput[]
    disconnect?: CompetitorAnalysisWhereUniqueInput | CompetitorAnalysisWhereUniqueInput[]
    delete?: CompetitorAnalysisWhereUniqueInput | CompetitorAnalysisWhereUniqueInput[]
    connect?: CompetitorAnalysisWhereUniqueInput | CompetitorAnalysisWhereUniqueInput[]
    update?: CompetitorAnalysisUpdateWithWhereUniqueWithoutDomainInput | CompetitorAnalysisUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: CompetitorAnalysisUpdateManyWithWhereWithoutDomainInput | CompetitorAnalysisUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: CompetitorAnalysisScalarWhereInput | CompetitorAnalysisScalarWhereInput[]
  }

  export type SuggestedCompetitorUpdateManyWithoutDomainNestedInput = {
    create?: XOR<SuggestedCompetitorCreateWithoutDomainInput, SuggestedCompetitorUncheckedCreateWithoutDomainInput> | SuggestedCompetitorCreateWithoutDomainInput[] | SuggestedCompetitorUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: SuggestedCompetitorCreateOrConnectWithoutDomainInput | SuggestedCompetitorCreateOrConnectWithoutDomainInput[]
    upsert?: SuggestedCompetitorUpsertWithWhereUniqueWithoutDomainInput | SuggestedCompetitorUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: SuggestedCompetitorCreateManyDomainInputEnvelope
    set?: SuggestedCompetitorWhereUniqueInput | SuggestedCompetitorWhereUniqueInput[]
    disconnect?: SuggestedCompetitorWhereUniqueInput | SuggestedCompetitorWhereUniqueInput[]
    delete?: SuggestedCompetitorWhereUniqueInput | SuggestedCompetitorWhereUniqueInput[]
    connect?: SuggestedCompetitorWhereUniqueInput | SuggestedCompetitorWhereUniqueInput[]
    update?: SuggestedCompetitorUpdateWithWhereUniqueWithoutDomainInput | SuggestedCompetitorUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: SuggestedCompetitorUpdateManyWithWhereWithoutDomainInput | SuggestedCompetitorUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: SuggestedCompetitorScalarWhereInput | SuggestedCompetitorScalarWhereInput[]
  }

  export type AnalysisPhaseUpdateManyWithoutDomainNestedInput = {
    create?: XOR<AnalysisPhaseCreateWithoutDomainInput, AnalysisPhaseUncheckedCreateWithoutDomainInput> | AnalysisPhaseCreateWithoutDomainInput[] | AnalysisPhaseUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: AnalysisPhaseCreateOrConnectWithoutDomainInput | AnalysisPhaseCreateOrConnectWithoutDomainInput[]
    upsert?: AnalysisPhaseUpsertWithWhereUniqueWithoutDomainInput | AnalysisPhaseUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: AnalysisPhaseCreateManyDomainInputEnvelope
    set?: AnalysisPhaseWhereUniqueInput | AnalysisPhaseWhereUniqueInput[]
    disconnect?: AnalysisPhaseWhereUniqueInput | AnalysisPhaseWhereUniqueInput[]
    delete?: AnalysisPhaseWhereUniqueInput | AnalysisPhaseWhereUniqueInput[]
    connect?: AnalysisPhaseWhereUniqueInput | AnalysisPhaseWhereUniqueInput[]
    update?: AnalysisPhaseUpdateWithWhereUniqueWithoutDomainInput | AnalysisPhaseUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: AnalysisPhaseUpdateManyWithWhereWithoutDomainInput | AnalysisPhaseUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: AnalysisPhaseScalarWhereInput | AnalysisPhaseScalarWhereInput[]
  }

  export type SemanticAnalysisUpdateManyWithoutDomainNestedInput = {
    create?: XOR<SemanticAnalysisCreateWithoutDomainInput, SemanticAnalysisUncheckedCreateWithoutDomainInput> | SemanticAnalysisCreateWithoutDomainInput[] | SemanticAnalysisUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: SemanticAnalysisCreateOrConnectWithoutDomainInput | SemanticAnalysisCreateOrConnectWithoutDomainInput[]
    upsert?: SemanticAnalysisUpsertWithWhereUniqueWithoutDomainInput | SemanticAnalysisUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: SemanticAnalysisCreateManyDomainInputEnvelope
    set?: SemanticAnalysisWhereUniqueInput | SemanticAnalysisWhereUniqueInput[]
    disconnect?: SemanticAnalysisWhereUniqueInput | SemanticAnalysisWhereUniqueInput[]
    delete?: SemanticAnalysisWhereUniqueInput | SemanticAnalysisWhereUniqueInput[]
    connect?: SemanticAnalysisWhereUniqueInput | SemanticAnalysisWhereUniqueInput[]
    update?: SemanticAnalysisUpdateWithWhereUniqueWithoutDomainInput | SemanticAnalysisUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: SemanticAnalysisUpdateManyWithWhereWithoutDomainInput | SemanticAnalysisUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: SemanticAnalysisScalarWhereInput | SemanticAnalysisScalarWhereInput[]
  }

  export type KeywordAnalysisUpdateManyWithoutDomainNestedInput = {
    create?: XOR<KeywordAnalysisCreateWithoutDomainInput, KeywordAnalysisUncheckedCreateWithoutDomainInput> | KeywordAnalysisCreateWithoutDomainInput[] | KeywordAnalysisUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: KeywordAnalysisCreateOrConnectWithoutDomainInput | KeywordAnalysisCreateOrConnectWithoutDomainInput[]
    upsert?: KeywordAnalysisUpsertWithWhereUniqueWithoutDomainInput | KeywordAnalysisUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: KeywordAnalysisCreateManyDomainInputEnvelope
    set?: KeywordAnalysisWhereUniqueInput | KeywordAnalysisWhereUniqueInput[]
    disconnect?: KeywordAnalysisWhereUniqueInput | KeywordAnalysisWhereUniqueInput[]
    delete?: KeywordAnalysisWhereUniqueInput | KeywordAnalysisWhereUniqueInput[]
    connect?: KeywordAnalysisWhereUniqueInput | KeywordAnalysisWhereUniqueInput[]
    update?: KeywordAnalysisUpdateWithWhereUniqueWithoutDomainInput | KeywordAnalysisUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: KeywordAnalysisUpdateManyWithWhereWithoutDomainInput | KeywordAnalysisUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: KeywordAnalysisScalarWhereInput | KeywordAnalysisScalarWhereInput[]
  }

  export type SearchVolumeClassificationUpdateManyWithoutDomainNestedInput = {
    create?: XOR<SearchVolumeClassificationCreateWithoutDomainInput, SearchVolumeClassificationUncheckedCreateWithoutDomainInput> | SearchVolumeClassificationCreateWithoutDomainInput[] | SearchVolumeClassificationUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: SearchVolumeClassificationCreateOrConnectWithoutDomainInput | SearchVolumeClassificationCreateOrConnectWithoutDomainInput[]
    upsert?: SearchVolumeClassificationUpsertWithWhereUniqueWithoutDomainInput | SearchVolumeClassificationUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: SearchVolumeClassificationCreateManyDomainInputEnvelope
    set?: SearchVolumeClassificationWhereUniqueInput | SearchVolumeClassificationWhereUniqueInput[]
    disconnect?: SearchVolumeClassificationWhereUniqueInput | SearchVolumeClassificationWhereUniqueInput[]
    delete?: SearchVolumeClassificationWhereUniqueInput | SearchVolumeClassificationWhereUniqueInput[]
    connect?: SearchVolumeClassificationWhereUniqueInput | SearchVolumeClassificationWhereUniqueInput[]
    update?: SearchVolumeClassificationUpdateWithWhereUniqueWithoutDomainInput | SearchVolumeClassificationUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: SearchVolumeClassificationUpdateManyWithWhereWithoutDomainInput | SearchVolumeClassificationUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: SearchVolumeClassificationScalarWhereInput | SearchVolumeClassificationScalarWhereInput[]
  }

  export type IntentClassificationUpdateManyWithoutDomainNestedInput = {
    create?: XOR<IntentClassificationCreateWithoutDomainInput, IntentClassificationUncheckedCreateWithoutDomainInput> | IntentClassificationCreateWithoutDomainInput[] | IntentClassificationUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: IntentClassificationCreateOrConnectWithoutDomainInput | IntentClassificationCreateOrConnectWithoutDomainInput[]
    upsert?: IntentClassificationUpsertWithWhereUniqueWithoutDomainInput | IntentClassificationUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: IntentClassificationCreateManyDomainInputEnvelope
    set?: IntentClassificationWhereUniqueInput | IntentClassificationWhereUniqueInput[]
    disconnect?: IntentClassificationWhereUniqueInput | IntentClassificationWhereUniqueInput[]
    delete?: IntentClassificationWhereUniqueInput | IntentClassificationWhereUniqueInput[]
    connect?: IntentClassificationWhereUniqueInput | IntentClassificationWhereUniqueInput[]
    update?: IntentClassificationUpdateWithWhereUniqueWithoutDomainInput | IntentClassificationUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: IntentClassificationUpdateManyWithWhereWithoutDomainInput | IntentClassificationUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: IntentClassificationScalarWhereInput | IntentClassificationScalarWhereInput[]
  }

  export type CommunityInsightUpdateManyWithoutDomainNestedInput = {
    create?: XOR<CommunityInsightCreateWithoutDomainInput, CommunityInsightUncheckedCreateWithoutDomainInput> | CommunityInsightCreateWithoutDomainInput[] | CommunityInsightUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: CommunityInsightCreateOrConnectWithoutDomainInput | CommunityInsightCreateOrConnectWithoutDomainInput[]
    upsert?: CommunityInsightUpsertWithWhereUniqueWithoutDomainInput | CommunityInsightUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: CommunityInsightCreateManyDomainInputEnvelope
    set?: CommunityInsightWhereUniqueInput | CommunityInsightWhereUniqueInput[]
    disconnect?: CommunityInsightWhereUniqueInput | CommunityInsightWhereUniqueInput[]
    delete?: CommunityInsightWhereUniqueInput | CommunityInsightWhereUniqueInput[]
    connect?: CommunityInsightWhereUniqueInput | CommunityInsightWhereUniqueInput[]
    update?: CommunityInsightUpdateWithWhereUniqueWithoutDomainInput | CommunityInsightUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: CommunityInsightUpdateManyWithWhereWithoutDomainInput | CommunityInsightUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: CommunityInsightScalarWhereInput | CommunityInsightScalarWhereInput[]
  }

  export type SearchPatternUpdateManyWithoutDomainNestedInput = {
    create?: XOR<SearchPatternCreateWithoutDomainInput, SearchPatternUncheckedCreateWithoutDomainInput> | SearchPatternCreateWithoutDomainInput[] | SearchPatternUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: SearchPatternCreateOrConnectWithoutDomainInput | SearchPatternCreateOrConnectWithoutDomainInput[]
    upsert?: SearchPatternUpsertWithWhereUniqueWithoutDomainInput | SearchPatternUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: SearchPatternCreateManyDomainInputEnvelope
    set?: SearchPatternWhereUniqueInput | SearchPatternWhereUniqueInput[]
    disconnect?: SearchPatternWhereUniqueInput | SearchPatternWhereUniqueInput[]
    delete?: SearchPatternWhereUniqueInput | SearchPatternWhereUniqueInput[]
    connect?: SearchPatternWhereUniqueInput | SearchPatternWhereUniqueInput[]
    update?: SearchPatternUpdateWithWhereUniqueWithoutDomainInput | SearchPatternUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: SearchPatternUpdateManyWithWhereWithoutDomainInput | SearchPatternUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: SearchPatternScalarWhereInput | SearchPatternScalarWhereInput[]
  }

  export type IntentPhraseGenerationUpdateManyWithoutDomainNestedInput = {
    create?: XOR<IntentPhraseGenerationCreateWithoutDomainInput, IntentPhraseGenerationUncheckedCreateWithoutDomainInput> | IntentPhraseGenerationCreateWithoutDomainInput[] | IntentPhraseGenerationUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: IntentPhraseGenerationCreateOrConnectWithoutDomainInput | IntentPhraseGenerationCreateOrConnectWithoutDomainInput[]
    upsert?: IntentPhraseGenerationUpsertWithWhereUniqueWithoutDomainInput | IntentPhraseGenerationUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: IntentPhraseGenerationCreateManyDomainInputEnvelope
    set?: IntentPhraseGenerationWhereUniqueInput | IntentPhraseGenerationWhereUniqueInput[]
    disconnect?: IntentPhraseGenerationWhereUniqueInput | IntentPhraseGenerationWhereUniqueInput[]
    delete?: IntentPhraseGenerationWhereUniqueInput | IntentPhraseGenerationWhereUniqueInput[]
    connect?: IntentPhraseGenerationWhereUniqueInput | IntentPhraseGenerationWhereUniqueInput[]
    update?: IntentPhraseGenerationUpdateWithWhereUniqueWithoutDomainInput | IntentPhraseGenerationUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: IntentPhraseGenerationUpdateManyWithWhereWithoutDomainInput | IntentPhraseGenerationUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: IntentPhraseGenerationScalarWhereInput | IntentPhraseGenerationScalarWhereInput[]
  }

  export type CommunityMiningResultUpdateManyWithoutDomainNestedInput = {
    create?: XOR<CommunityMiningResultCreateWithoutDomainInput, CommunityMiningResultUncheckedCreateWithoutDomainInput> | CommunityMiningResultCreateWithoutDomainInput[] | CommunityMiningResultUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: CommunityMiningResultCreateOrConnectWithoutDomainInput | CommunityMiningResultCreateOrConnectWithoutDomainInput[]
    upsert?: CommunityMiningResultUpsertWithWhereUniqueWithoutDomainInput | CommunityMiningResultUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: CommunityMiningResultCreateManyDomainInputEnvelope
    set?: CommunityMiningResultWhereUniqueInput | CommunityMiningResultWhereUniqueInput[]
    disconnect?: CommunityMiningResultWhereUniqueInput | CommunityMiningResultWhereUniqueInput[]
    delete?: CommunityMiningResultWhereUniqueInput | CommunityMiningResultWhereUniqueInput[]
    connect?: CommunityMiningResultWhereUniqueInput | CommunityMiningResultWhereUniqueInput[]
    update?: CommunityMiningResultUpdateWithWhereUniqueWithoutDomainInput | CommunityMiningResultUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: CommunityMiningResultUpdateManyWithWhereWithoutDomainInput | CommunityMiningResultUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: CommunityMiningResultScalarWhereInput | CommunityMiningResultScalarWhereInput[]
  }

  export type SearchPatternResultUpdateManyWithoutDomainNestedInput = {
    create?: XOR<SearchPatternResultCreateWithoutDomainInput, SearchPatternResultUncheckedCreateWithoutDomainInput> | SearchPatternResultCreateWithoutDomainInput[] | SearchPatternResultUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: SearchPatternResultCreateOrConnectWithoutDomainInput | SearchPatternResultCreateOrConnectWithoutDomainInput[]
    upsert?: SearchPatternResultUpsertWithWhereUniqueWithoutDomainInput | SearchPatternResultUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: SearchPatternResultCreateManyDomainInputEnvelope
    set?: SearchPatternResultWhereUniqueInput | SearchPatternResultWhereUniqueInput[]
    disconnect?: SearchPatternResultWhereUniqueInput | SearchPatternResultWhereUniqueInput[]
    delete?: SearchPatternResultWhereUniqueInput | SearchPatternResultWhereUniqueInput[]
    connect?: SearchPatternResultWhereUniqueInput | SearchPatternResultWhereUniqueInput[]
    update?: SearchPatternResultUpdateWithWhereUniqueWithoutDomainInput | SearchPatternResultUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: SearchPatternResultUpdateManyWithWhereWithoutDomainInput | SearchPatternResultUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: SearchPatternResultScalarWhereInput | SearchPatternResultScalarWhereInput[]
  }

  export type IntentClassificationResultUpdateManyWithoutDomainNestedInput = {
    create?: XOR<IntentClassificationResultCreateWithoutDomainInput, IntentClassificationResultUncheckedCreateWithoutDomainInput> | IntentClassificationResultCreateWithoutDomainInput[] | IntentClassificationResultUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: IntentClassificationResultCreateOrConnectWithoutDomainInput | IntentClassificationResultCreateOrConnectWithoutDomainInput[]
    upsert?: IntentClassificationResultUpsertWithWhereUniqueWithoutDomainInput | IntentClassificationResultUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: IntentClassificationResultCreateManyDomainInputEnvelope
    set?: IntentClassificationResultWhereUniqueInput | IntentClassificationResultWhereUniqueInput[]
    disconnect?: IntentClassificationResultWhereUniqueInput | IntentClassificationResultWhereUniqueInput[]
    delete?: IntentClassificationResultWhereUniqueInput | IntentClassificationResultWhereUniqueInput[]
    connect?: IntentClassificationResultWhereUniqueInput | IntentClassificationResultWhereUniqueInput[]
    update?: IntentClassificationResultUpdateWithWhereUniqueWithoutDomainInput | IntentClassificationResultUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: IntentClassificationResultUpdateManyWithWhereWithoutDomainInput | IntentClassificationResultUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: IntentClassificationResultScalarWhereInput | IntentClassificationResultScalarWhereInput[]
  }

  export type GeneratedIntentPhraseUpdateManyWithoutDomainNestedInput = {
    create?: XOR<GeneratedIntentPhraseCreateWithoutDomainInput, GeneratedIntentPhraseUncheckedCreateWithoutDomainInput> | GeneratedIntentPhraseCreateWithoutDomainInput[] | GeneratedIntentPhraseUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: GeneratedIntentPhraseCreateOrConnectWithoutDomainInput | GeneratedIntentPhraseCreateOrConnectWithoutDomainInput[]
    upsert?: GeneratedIntentPhraseUpsertWithWhereUniqueWithoutDomainInput | GeneratedIntentPhraseUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: GeneratedIntentPhraseCreateManyDomainInputEnvelope
    set?: GeneratedIntentPhraseWhereUniqueInput | GeneratedIntentPhraseWhereUniqueInput[]
    disconnect?: GeneratedIntentPhraseWhereUniqueInput | GeneratedIntentPhraseWhereUniqueInput[]
    delete?: GeneratedIntentPhraseWhereUniqueInput | GeneratedIntentPhraseWhereUniqueInput[]
    connect?: GeneratedIntentPhraseWhereUniqueInput | GeneratedIntentPhraseWhereUniqueInput[]
    update?: GeneratedIntentPhraseUpdateWithWhereUniqueWithoutDomainInput | GeneratedIntentPhraseUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: GeneratedIntentPhraseUpdateManyWithWhereWithoutDomainInput | GeneratedIntentPhraseUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: GeneratedIntentPhraseScalarWhereInput | GeneratedIntentPhraseScalarWhereInput[]
  }

  export type RelevanceScoreResultUpdateManyWithoutDomainNestedInput = {
    create?: XOR<RelevanceScoreResultCreateWithoutDomainInput, RelevanceScoreResultUncheckedCreateWithoutDomainInput> | RelevanceScoreResultCreateWithoutDomainInput[] | RelevanceScoreResultUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: RelevanceScoreResultCreateOrConnectWithoutDomainInput | RelevanceScoreResultCreateOrConnectWithoutDomainInput[]
    upsert?: RelevanceScoreResultUpsertWithWhereUniqueWithoutDomainInput | RelevanceScoreResultUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: RelevanceScoreResultCreateManyDomainInputEnvelope
    set?: RelevanceScoreResultWhereUniqueInput | RelevanceScoreResultWhereUniqueInput[]
    disconnect?: RelevanceScoreResultWhereUniqueInput | RelevanceScoreResultWhereUniqueInput[]
    delete?: RelevanceScoreResultWhereUniqueInput | RelevanceScoreResultWhereUniqueInput[]
    connect?: RelevanceScoreResultWhereUniqueInput | RelevanceScoreResultWhereUniqueInput[]
    update?: RelevanceScoreResultUpdateWithWhereUniqueWithoutDomainInput | RelevanceScoreResultUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: RelevanceScoreResultUpdateManyWithWhereWithoutDomainInput | RelevanceScoreResultUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: RelevanceScoreResultScalarWhereInput | RelevanceScoreResultScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CrawlResultUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<CrawlResultCreateWithoutDomainInput, CrawlResultUncheckedCreateWithoutDomainInput> | CrawlResultCreateWithoutDomainInput[] | CrawlResultUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: CrawlResultCreateOrConnectWithoutDomainInput | CrawlResultCreateOrConnectWithoutDomainInput[]
    upsert?: CrawlResultUpsertWithWhereUniqueWithoutDomainInput | CrawlResultUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: CrawlResultCreateManyDomainInputEnvelope
    set?: CrawlResultWhereUniqueInput | CrawlResultWhereUniqueInput[]
    disconnect?: CrawlResultWhereUniqueInput | CrawlResultWhereUniqueInput[]
    delete?: CrawlResultWhereUniqueInput | CrawlResultWhereUniqueInput[]
    connect?: CrawlResultWhereUniqueInput | CrawlResultWhereUniqueInput[]
    update?: CrawlResultUpdateWithWhereUniqueWithoutDomainInput | CrawlResultUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: CrawlResultUpdateManyWithWhereWithoutDomainInput | CrawlResultUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: CrawlResultScalarWhereInput | CrawlResultScalarWhereInput[]
  }

  export type KeywordUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<KeywordCreateWithoutDomainInput, KeywordUncheckedCreateWithoutDomainInput> | KeywordCreateWithoutDomainInput[] | KeywordUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: KeywordCreateOrConnectWithoutDomainInput | KeywordCreateOrConnectWithoutDomainInput[]
    upsert?: KeywordUpsertWithWhereUniqueWithoutDomainInput | KeywordUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: KeywordCreateManyDomainInputEnvelope
    set?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    disconnect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    delete?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    connect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    update?: KeywordUpdateWithWhereUniqueWithoutDomainInput | KeywordUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: KeywordUpdateManyWithWhereWithoutDomainInput | KeywordUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: KeywordScalarWhereInput | KeywordScalarWhereInput[]
  }

  export type DashboardAnalysisUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<DashboardAnalysisCreateWithoutDomainInput, DashboardAnalysisUncheckedCreateWithoutDomainInput> | DashboardAnalysisCreateWithoutDomainInput[] | DashboardAnalysisUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: DashboardAnalysisCreateOrConnectWithoutDomainInput | DashboardAnalysisCreateOrConnectWithoutDomainInput[]
    upsert?: DashboardAnalysisUpsertWithWhereUniqueWithoutDomainInput | DashboardAnalysisUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: DashboardAnalysisCreateManyDomainInputEnvelope
    set?: DashboardAnalysisWhereUniqueInput | DashboardAnalysisWhereUniqueInput[]
    disconnect?: DashboardAnalysisWhereUniqueInput | DashboardAnalysisWhereUniqueInput[]
    delete?: DashboardAnalysisWhereUniqueInput | DashboardAnalysisWhereUniqueInput[]
    connect?: DashboardAnalysisWhereUniqueInput | DashboardAnalysisWhereUniqueInput[]
    update?: DashboardAnalysisUpdateWithWhereUniqueWithoutDomainInput | DashboardAnalysisUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: DashboardAnalysisUpdateManyWithWhereWithoutDomainInput | DashboardAnalysisUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: DashboardAnalysisScalarWhereInput | DashboardAnalysisScalarWhereInput[]
  }

  export type CompetitorAnalysisUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<CompetitorAnalysisCreateWithoutDomainInput, CompetitorAnalysisUncheckedCreateWithoutDomainInput> | CompetitorAnalysisCreateWithoutDomainInput[] | CompetitorAnalysisUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: CompetitorAnalysisCreateOrConnectWithoutDomainInput | CompetitorAnalysisCreateOrConnectWithoutDomainInput[]
    upsert?: CompetitorAnalysisUpsertWithWhereUniqueWithoutDomainInput | CompetitorAnalysisUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: CompetitorAnalysisCreateManyDomainInputEnvelope
    set?: CompetitorAnalysisWhereUniqueInput | CompetitorAnalysisWhereUniqueInput[]
    disconnect?: CompetitorAnalysisWhereUniqueInput | CompetitorAnalysisWhereUniqueInput[]
    delete?: CompetitorAnalysisWhereUniqueInput | CompetitorAnalysisWhereUniqueInput[]
    connect?: CompetitorAnalysisWhereUniqueInput | CompetitorAnalysisWhereUniqueInput[]
    update?: CompetitorAnalysisUpdateWithWhereUniqueWithoutDomainInput | CompetitorAnalysisUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: CompetitorAnalysisUpdateManyWithWhereWithoutDomainInput | CompetitorAnalysisUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: CompetitorAnalysisScalarWhereInput | CompetitorAnalysisScalarWhereInput[]
  }

  export type SuggestedCompetitorUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<SuggestedCompetitorCreateWithoutDomainInput, SuggestedCompetitorUncheckedCreateWithoutDomainInput> | SuggestedCompetitorCreateWithoutDomainInput[] | SuggestedCompetitorUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: SuggestedCompetitorCreateOrConnectWithoutDomainInput | SuggestedCompetitorCreateOrConnectWithoutDomainInput[]
    upsert?: SuggestedCompetitorUpsertWithWhereUniqueWithoutDomainInput | SuggestedCompetitorUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: SuggestedCompetitorCreateManyDomainInputEnvelope
    set?: SuggestedCompetitorWhereUniqueInput | SuggestedCompetitorWhereUniqueInput[]
    disconnect?: SuggestedCompetitorWhereUniqueInput | SuggestedCompetitorWhereUniqueInput[]
    delete?: SuggestedCompetitorWhereUniqueInput | SuggestedCompetitorWhereUniqueInput[]
    connect?: SuggestedCompetitorWhereUniqueInput | SuggestedCompetitorWhereUniqueInput[]
    update?: SuggestedCompetitorUpdateWithWhereUniqueWithoutDomainInput | SuggestedCompetitorUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: SuggestedCompetitorUpdateManyWithWhereWithoutDomainInput | SuggestedCompetitorUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: SuggestedCompetitorScalarWhereInput | SuggestedCompetitorScalarWhereInput[]
  }

  export type AnalysisPhaseUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<AnalysisPhaseCreateWithoutDomainInput, AnalysisPhaseUncheckedCreateWithoutDomainInput> | AnalysisPhaseCreateWithoutDomainInput[] | AnalysisPhaseUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: AnalysisPhaseCreateOrConnectWithoutDomainInput | AnalysisPhaseCreateOrConnectWithoutDomainInput[]
    upsert?: AnalysisPhaseUpsertWithWhereUniqueWithoutDomainInput | AnalysisPhaseUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: AnalysisPhaseCreateManyDomainInputEnvelope
    set?: AnalysisPhaseWhereUniqueInput | AnalysisPhaseWhereUniqueInput[]
    disconnect?: AnalysisPhaseWhereUniqueInput | AnalysisPhaseWhereUniqueInput[]
    delete?: AnalysisPhaseWhereUniqueInput | AnalysisPhaseWhereUniqueInput[]
    connect?: AnalysisPhaseWhereUniqueInput | AnalysisPhaseWhereUniqueInput[]
    update?: AnalysisPhaseUpdateWithWhereUniqueWithoutDomainInput | AnalysisPhaseUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: AnalysisPhaseUpdateManyWithWhereWithoutDomainInput | AnalysisPhaseUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: AnalysisPhaseScalarWhereInput | AnalysisPhaseScalarWhereInput[]
  }

  export type SemanticAnalysisUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<SemanticAnalysisCreateWithoutDomainInput, SemanticAnalysisUncheckedCreateWithoutDomainInput> | SemanticAnalysisCreateWithoutDomainInput[] | SemanticAnalysisUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: SemanticAnalysisCreateOrConnectWithoutDomainInput | SemanticAnalysisCreateOrConnectWithoutDomainInput[]
    upsert?: SemanticAnalysisUpsertWithWhereUniqueWithoutDomainInput | SemanticAnalysisUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: SemanticAnalysisCreateManyDomainInputEnvelope
    set?: SemanticAnalysisWhereUniqueInput | SemanticAnalysisWhereUniqueInput[]
    disconnect?: SemanticAnalysisWhereUniqueInput | SemanticAnalysisWhereUniqueInput[]
    delete?: SemanticAnalysisWhereUniqueInput | SemanticAnalysisWhereUniqueInput[]
    connect?: SemanticAnalysisWhereUniqueInput | SemanticAnalysisWhereUniqueInput[]
    update?: SemanticAnalysisUpdateWithWhereUniqueWithoutDomainInput | SemanticAnalysisUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: SemanticAnalysisUpdateManyWithWhereWithoutDomainInput | SemanticAnalysisUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: SemanticAnalysisScalarWhereInput | SemanticAnalysisScalarWhereInput[]
  }

  export type KeywordAnalysisUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<KeywordAnalysisCreateWithoutDomainInput, KeywordAnalysisUncheckedCreateWithoutDomainInput> | KeywordAnalysisCreateWithoutDomainInput[] | KeywordAnalysisUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: KeywordAnalysisCreateOrConnectWithoutDomainInput | KeywordAnalysisCreateOrConnectWithoutDomainInput[]
    upsert?: KeywordAnalysisUpsertWithWhereUniqueWithoutDomainInput | KeywordAnalysisUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: KeywordAnalysisCreateManyDomainInputEnvelope
    set?: KeywordAnalysisWhereUniqueInput | KeywordAnalysisWhereUniqueInput[]
    disconnect?: KeywordAnalysisWhereUniqueInput | KeywordAnalysisWhereUniqueInput[]
    delete?: KeywordAnalysisWhereUniqueInput | KeywordAnalysisWhereUniqueInput[]
    connect?: KeywordAnalysisWhereUniqueInput | KeywordAnalysisWhereUniqueInput[]
    update?: KeywordAnalysisUpdateWithWhereUniqueWithoutDomainInput | KeywordAnalysisUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: KeywordAnalysisUpdateManyWithWhereWithoutDomainInput | KeywordAnalysisUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: KeywordAnalysisScalarWhereInput | KeywordAnalysisScalarWhereInput[]
  }

  export type SearchVolumeClassificationUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<SearchVolumeClassificationCreateWithoutDomainInput, SearchVolumeClassificationUncheckedCreateWithoutDomainInput> | SearchVolumeClassificationCreateWithoutDomainInput[] | SearchVolumeClassificationUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: SearchVolumeClassificationCreateOrConnectWithoutDomainInput | SearchVolumeClassificationCreateOrConnectWithoutDomainInput[]
    upsert?: SearchVolumeClassificationUpsertWithWhereUniqueWithoutDomainInput | SearchVolumeClassificationUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: SearchVolumeClassificationCreateManyDomainInputEnvelope
    set?: SearchVolumeClassificationWhereUniqueInput | SearchVolumeClassificationWhereUniqueInput[]
    disconnect?: SearchVolumeClassificationWhereUniqueInput | SearchVolumeClassificationWhereUniqueInput[]
    delete?: SearchVolumeClassificationWhereUniqueInput | SearchVolumeClassificationWhereUniqueInput[]
    connect?: SearchVolumeClassificationWhereUniqueInput | SearchVolumeClassificationWhereUniqueInput[]
    update?: SearchVolumeClassificationUpdateWithWhereUniqueWithoutDomainInput | SearchVolumeClassificationUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: SearchVolumeClassificationUpdateManyWithWhereWithoutDomainInput | SearchVolumeClassificationUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: SearchVolumeClassificationScalarWhereInput | SearchVolumeClassificationScalarWhereInput[]
  }

  export type IntentClassificationUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<IntentClassificationCreateWithoutDomainInput, IntentClassificationUncheckedCreateWithoutDomainInput> | IntentClassificationCreateWithoutDomainInput[] | IntentClassificationUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: IntentClassificationCreateOrConnectWithoutDomainInput | IntentClassificationCreateOrConnectWithoutDomainInput[]
    upsert?: IntentClassificationUpsertWithWhereUniqueWithoutDomainInput | IntentClassificationUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: IntentClassificationCreateManyDomainInputEnvelope
    set?: IntentClassificationWhereUniqueInput | IntentClassificationWhereUniqueInput[]
    disconnect?: IntentClassificationWhereUniqueInput | IntentClassificationWhereUniqueInput[]
    delete?: IntentClassificationWhereUniqueInput | IntentClassificationWhereUniqueInput[]
    connect?: IntentClassificationWhereUniqueInput | IntentClassificationWhereUniqueInput[]
    update?: IntentClassificationUpdateWithWhereUniqueWithoutDomainInput | IntentClassificationUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: IntentClassificationUpdateManyWithWhereWithoutDomainInput | IntentClassificationUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: IntentClassificationScalarWhereInput | IntentClassificationScalarWhereInput[]
  }

  export type CommunityInsightUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<CommunityInsightCreateWithoutDomainInput, CommunityInsightUncheckedCreateWithoutDomainInput> | CommunityInsightCreateWithoutDomainInput[] | CommunityInsightUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: CommunityInsightCreateOrConnectWithoutDomainInput | CommunityInsightCreateOrConnectWithoutDomainInput[]
    upsert?: CommunityInsightUpsertWithWhereUniqueWithoutDomainInput | CommunityInsightUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: CommunityInsightCreateManyDomainInputEnvelope
    set?: CommunityInsightWhereUniqueInput | CommunityInsightWhereUniqueInput[]
    disconnect?: CommunityInsightWhereUniqueInput | CommunityInsightWhereUniqueInput[]
    delete?: CommunityInsightWhereUniqueInput | CommunityInsightWhereUniqueInput[]
    connect?: CommunityInsightWhereUniqueInput | CommunityInsightWhereUniqueInput[]
    update?: CommunityInsightUpdateWithWhereUniqueWithoutDomainInput | CommunityInsightUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: CommunityInsightUpdateManyWithWhereWithoutDomainInput | CommunityInsightUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: CommunityInsightScalarWhereInput | CommunityInsightScalarWhereInput[]
  }

  export type SearchPatternUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<SearchPatternCreateWithoutDomainInput, SearchPatternUncheckedCreateWithoutDomainInput> | SearchPatternCreateWithoutDomainInput[] | SearchPatternUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: SearchPatternCreateOrConnectWithoutDomainInput | SearchPatternCreateOrConnectWithoutDomainInput[]
    upsert?: SearchPatternUpsertWithWhereUniqueWithoutDomainInput | SearchPatternUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: SearchPatternCreateManyDomainInputEnvelope
    set?: SearchPatternWhereUniqueInput | SearchPatternWhereUniqueInput[]
    disconnect?: SearchPatternWhereUniqueInput | SearchPatternWhereUniqueInput[]
    delete?: SearchPatternWhereUniqueInput | SearchPatternWhereUniqueInput[]
    connect?: SearchPatternWhereUniqueInput | SearchPatternWhereUniqueInput[]
    update?: SearchPatternUpdateWithWhereUniqueWithoutDomainInput | SearchPatternUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: SearchPatternUpdateManyWithWhereWithoutDomainInput | SearchPatternUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: SearchPatternScalarWhereInput | SearchPatternScalarWhereInput[]
  }

  export type IntentPhraseGenerationUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<IntentPhraseGenerationCreateWithoutDomainInput, IntentPhraseGenerationUncheckedCreateWithoutDomainInput> | IntentPhraseGenerationCreateWithoutDomainInput[] | IntentPhraseGenerationUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: IntentPhraseGenerationCreateOrConnectWithoutDomainInput | IntentPhraseGenerationCreateOrConnectWithoutDomainInput[]
    upsert?: IntentPhraseGenerationUpsertWithWhereUniqueWithoutDomainInput | IntentPhraseGenerationUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: IntentPhraseGenerationCreateManyDomainInputEnvelope
    set?: IntentPhraseGenerationWhereUniqueInput | IntentPhraseGenerationWhereUniqueInput[]
    disconnect?: IntentPhraseGenerationWhereUniqueInput | IntentPhraseGenerationWhereUniqueInput[]
    delete?: IntentPhraseGenerationWhereUniqueInput | IntentPhraseGenerationWhereUniqueInput[]
    connect?: IntentPhraseGenerationWhereUniqueInput | IntentPhraseGenerationWhereUniqueInput[]
    update?: IntentPhraseGenerationUpdateWithWhereUniqueWithoutDomainInput | IntentPhraseGenerationUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: IntentPhraseGenerationUpdateManyWithWhereWithoutDomainInput | IntentPhraseGenerationUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: IntentPhraseGenerationScalarWhereInput | IntentPhraseGenerationScalarWhereInput[]
  }

  export type CommunityMiningResultUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<CommunityMiningResultCreateWithoutDomainInput, CommunityMiningResultUncheckedCreateWithoutDomainInput> | CommunityMiningResultCreateWithoutDomainInput[] | CommunityMiningResultUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: CommunityMiningResultCreateOrConnectWithoutDomainInput | CommunityMiningResultCreateOrConnectWithoutDomainInput[]
    upsert?: CommunityMiningResultUpsertWithWhereUniqueWithoutDomainInput | CommunityMiningResultUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: CommunityMiningResultCreateManyDomainInputEnvelope
    set?: CommunityMiningResultWhereUniqueInput | CommunityMiningResultWhereUniqueInput[]
    disconnect?: CommunityMiningResultWhereUniqueInput | CommunityMiningResultWhereUniqueInput[]
    delete?: CommunityMiningResultWhereUniqueInput | CommunityMiningResultWhereUniqueInput[]
    connect?: CommunityMiningResultWhereUniqueInput | CommunityMiningResultWhereUniqueInput[]
    update?: CommunityMiningResultUpdateWithWhereUniqueWithoutDomainInput | CommunityMiningResultUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: CommunityMiningResultUpdateManyWithWhereWithoutDomainInput | CommunityMiningResultUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: CommunityMiningResultScalarWhereInput | CommunityMiningResultScalarWhereInput[]
  }

  export type SearchPatternResultUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<SearchPatternResultCreateWithoutDomainInput, SearchPatternResultUncheckedCreateWithoutDomainInput> | SearchPatternResultCreateWithoutDomainInput[] | SearchPatternResultUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: SearchPatternResultCreateOrConnectWithoutDomainInput | SearchPatternResultCreateOrConnectWithoutDomainInput[]
    upsert?: SearchPatternResultUpsertWithWhereUniqueWithoutDomainInput | SearchPatternResultUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: SearchPatternResultCreateManyDomainInputEnvelope
    set?: SearchPatternResultWhereUniqueInput | SearchPatternResultWhereUniqueInput[]
    disconnect?: SearchPatternResultWhereUniqueInput | SearchPatternResultWhereUniqueInput[]
    delete?: SearchPatternResultWhereUniqueInput | SearchPatternResultWhereUniqueInput[]
    connect?: SearchPatternResultWhereUniqueInput | SearchPatternResultWhereUniqueInput[]
    update?: SearchPatternResultUpdateWithWhereUniqueWithoutDomainInput | SearchPatternResultUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: SearchPatternResultUpdateManyWithWhereWithoutDomainInput | SearchPatternResultUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: SearchPatternResultScalarWhereInput | SearchPatternResultScalarWhereInput[]
  }

  export type IntentClassificationResultUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<IntentClassificationResultCreateWithoutDomainInput, IntentClassificationResultUncheckedCreateWithoutDomainInput> | IntentClassificationResultCreateWithoutDomainInput[] | IntentClassificationResultUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: IntentClassificationResultCreateOrConnectWithoutDomainInput | IntentClassificationResultCreateOrConnectWithoutDomainInput[]
    upsert?: IntentClassificationResultUpsertWithWhereUniqueWithoutDomainInput | IntentClassificationResultUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: IntentClassificationResultCreateManyDomainInputEnvelope
    set?: IntentClassificationResultWhereUniqueInput | IntentClassificationResultWhereUniqueInput[]
    disconnect?: IntentClassificationResultWhereUniqueInput | IntentClassificationResultWhereUniqueInput[]
    delete?: IntentClassificationResultWhereUniqueInput | IntentClassificationResultWhereUniqueInput[]
    connect?: IntentClassificationResultWhereUniqueInput | IntentClassificationResultWhereUniqueInput[]
    update?: IntentClassificationResultUpdateWithWhereUniqueWithoutDomainInput | IntentClassificationResultUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: IntentClassificationResultUpdateManyWithWhereWithoutDomainInput | IntentClassificationResultUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: IntentClassificationResultScalarWhereInput | IntentClassificationResultScalarWhereInput[]
  }

  export type GeneratedIntentPhraseUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<GeneratedIntentPhraseCreateWithoutDomainInput, GeneratedIntentPhraseUncheckedCreateWithoutDomainInput> | GeneratedIntentPhraseCreateWithoutDomainInput[] | GeneratedIntentPhraseUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: GeneratedIntentPhraseCreateOrConnectWithoutDomainInput | GeneratedIntentPhraseCreateOrConnectWithoutDomainInput[]
    upsert?: GeneratedIntentPhraseUpsertWithWhereUniqueWithoutDomainInput | GeneratedIntentPhraseUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: GeneratedIntentPhraseCreateManyDomainInputEnvelope
    set?: GeneratedIntentPhraseWhereUniqueInput | GeneratedIntentPhraseWhereUniqueInput[]
    disconnect?: GeneratedIntentPhraseWhereUniqueInput | GeneratedIntentPhraseWhereUniqueInput[]
    delete?: GeneratedIntentPhraseWhereUniqueInput | GeneratedIntentPhraseWhereUniqueInput[]
    connect?: GeneratedIntentPhraseWhereUniqueInput | GeneratedIntentPhraseWhereUniqueInput[]
    update?: GeneratedIntentPhraseUpdateWithWhereUniqueWithoutDomainInput | GeneratedIntentPhraseUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: GeneratedIntentPhraseUpdateManyWithWhereWithoutDomainInput | GeneratedIntentPhraseUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: GeneratedIntentPhraseScalarWhereInput | GeneratedIntentPhraseScalarWhereInput[]
  }

  export type RelevanceScoreResultUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<RelevanceScoreResultCreateWithoutDomainInput, RelevanceScoreResultUncheckedCreateWithoutDomainInput> | RelevanceScoreResultCreateWithoutDomainInput[] | RelevanceScoreResultUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: RelevanceScoreResultCreateOrConnectWithoutDomainInput | RelevanceScoreResultCreateOrConnectWithoutDomainInput[]
    upsert?: RelevanceScoreResultUpsertWithWhereUniqueWithoutDomainInput | RelevanceScoreResultUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: RelevanceScoreResultCreateManyDomainInputEnvelope
    set?: RelevanceScoreResultWhereUniqueInput | RelevanceScoreResultWhereUniqueInput[]
    disconnect?: RelevanceScoreResultWhereUniqueInput | RelevanceScoreResultWhereUniqueInput[]
    delete?: RelevanceScoreResultWhereUniqueInput | RelevanceScoreResultWhereUniqueInput[]
    connect?: RelevanceScoreResultWhereUniqueInput | RelevanceScoreResultWhereUniqueInput[]
    update?: RelevanceScoreResultUpdateWithWhereUniqueWithoutDomainInput | RelevanceScoreResultUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: RelevanceScoreResultUpdateManyWithWhereWithoutDomainInput | RelevanceScoreResultUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: RelevanceScoreResultScalarWhereInput | RelevanceScoreResultScalarWhereInput[]
  }

  export type DomainCreateNestedOneWithoutCrawlResultsInput = {
    create?: XOR<DomainCreateWithoutCrawlResultsInput, DomainUncheckedCreateWithoutCrawlResultsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutCrawlResultsInput
    connect?: DomainWhereUniqueInput
  }

  export type DomainUpdateOneWithoutCrawlResultsNestedInput = {
    create?: XOR<DomainCreateWithoutCrawlResultsInput, DomainUncheckedCreateWithoutCrawlResultsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutCrawlResultsInput
    upsert?: DomainUpsertWithoutCrawlResultsInput
    disconnect?: DomainWhereInput | boolean
    delete?: DomainWhereInput | boolean
    connect?: DomainWhereUniqueInput
    update?: XOR<XOR<DomainUpdateToOneWithWhereWithoutCrawlResultsInput, DomainUpdateWithoutCrawlResultsInput>, DomainUncheckedUpdateWithoutCrawlResultsInput>
  }

  export type DomainCreateNestedOneWithoutKeywordsInput = {
    create?: XOR<DomainCreateWithoutKeywordsInput, DomainUncheckedCreateWithoutKeywordsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutKeywordsInput
    connect?: DomainWhereUniqueInput
  }

  export type PhraseCreateNestedManyWithoutKeywordInput = {
    create?: XOR<PhraseCreateWithoutKeywordInput, PhraseUncheckedCreateWithoutKeywordInput> | PhraseCreateWithoutKeywordInput[] | PhraseUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: PhraseCreateOrConnectWithoutKeywordInput | PhraseCreateOrConnectWithoutKeywordInput[]
    createMany?: PhraseCreateManyKeywordInputEnvelope
    connect?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
  }

  export type CommunityInsightCreateNestedManyWithoutKeywordInput = {
    create?: XOR<CommunityInsightCreateWithoutKeywordInput, CommunityInsightUncheckedCreateWithoutKeywordInput> | CommunityInsightCreateWithoutKeywordInput[] | CommunityInsightUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: CommunityInsightCreateOrConnectWithoutKeywordInput | CommunityInsightCreateOrConnectWithoutKeywordInput[]
    createMany?: CommunityInsightCreateManyKeywordInputEnvelope
    connect?: CommunityInsightWhereUniqueInput | CommunityInsightWhereUniqueInput[]
  }

  export type SearchPatternCreateNestedManyWithoutKeywordInput = {
    create?: XOR<SearchPatternCreateWithoutKeywordInput, SearchPatternUncheckedCreateWithoutKeywordInput> | SearchPatternCreateWithoutKeywordInput[] | SearchPatternUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: SearchPatternCreateOrConnectWithoutKeywordInput | SearchPatternCreateOrConnectWithoutKeywordInput[]
    createMany?: SearchPatternCreateManyKeywordInputEnvelope
    connect?: SearchPatternWhereUniqueInput | SearchPatternWhereUniqueInput[]
  }

  export type CommunityMiningResultCreateNestedManyWithoutKeywordInput = {
    create?: XOR<CommunityMiningResultCreateWithoutKeywordInput, CommunityMiningResultUncheckedCreateWithoutKeywordInput> | CommunityMiningResultCreateWithoutKeywordInput[] | CommunityMiningResultUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: CommunityMiningResultCreateOrConnectWithoutKeywordInput | CommunityMiningResultCreateOrConnectWithoutKeywordInput[]
    createMany?: CommunityMiningResultCreateManyKeywordInputEnvelope
    connect?: CommunityMiningResultWhereUniqueInput | CommunityMiningResultWhereUniqueInput[]
  }

  export type SearchPatternResultCreateNestedManyWithoutKeywordInput = {
    create?: XOR<SearchPatternResultCreateWithoutKeywordInput, SearchPatternResultUncheckedCreateWithoutKeywordInput> | SearchPatternResultCreateWithoutKeywordInput[] | SearchPatternResultUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: SearchPatternResultCreateOrConnectWithoutKeywordInput | SearchPatternResultCreateOrConnectWithoutKeywordInput[]
    createMany?: SearchPatternResultCreateManyKeywordInputEnvelope
    connect?: SearchPatternResultWhereUniqueInput | SearchPatternResultWhereUniqueInput[]
  }

  export type IntentClassificationResultCreateNestedManyWithoutKeywordInput = {
    create?: XOR<IntentClassificationResultCreateWithoutKeywordInput, IntentClassificationResultUncheckedCreateWithoutKeywordInput> | IntentClassificationResultCreateWithoutKeywordInput[] | IntentClassificationResultUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: IntentClassificationResultCreateOrConnectWithoutKeywordInput | IntentClassificationResultCreateOrConnectWithoutKeywordInput[]
    createMany?: IntentClassificationResultCreateManyKeywordInputEnvelope
    connect?: IntentClassificationResultWhereUniqueInput | IntentClassificationResultWhereUniqueInput[]
  }

  export type GeneratedIntentPhraseCreateNestedManyWithoutKeywordInput = {
    create?: XOR<GeneratedIntentPhraseCreateWithoutKeywordInput, GeneratedIntentPhraseUncheckedCreateWithoutKeywordInput> | GeneratedIntentPhraseCreateWithoutKeywordInput[] | GeneratedIntentPhraseUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: GeneratedIntentPhraseCreateOrConnectWithoutKeywordInput | GeneratedIntentPhraseCreateOrConnectWithoutKeywordInput[]
    createMany?: GeneratedIntentPhraseCreateManyKeywordInputEnvelope
    connect?: GeneratedIntentPhraseWhereUniqueInput | GeneratedIntentPhraseWhereUniqueInput[]
  }

  export type PhraseUncheckedCreateNestedManyWithoutKeywordInput = {
    create?: XOR<PhraseCreateWithoutKeywordInput, PhraseUncheckedCreateWithoutKeywordInput> | PhraseCreateWithoutKeywordInput[] | PhraseUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: PhraseCreateOrConnectWithoutKeywordInput | PhraseCreateOrConnectWithoutKeywordInput[]
    createMany?: PhraseCreateManyKeywordInputEnvelope
    connect?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
  }

  export type CommunityInsightUncheckedCreateNestedManyWithoutKeywordInput = {
    create?: XOR<CommunityInsightCreateWithoutKeywordInput, CommunityInsightUncheckedCreateWithoutKeywordInput> | CommunityInsightCreateWithoutKeywordInput[] | CommunityInsightUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: CommunityInsightCreateOrConnectWithoutKeywordInput | CommunityInsightCreateOrConnectWithoutKeywordInput[]
    createMany?: CommunityInsightCreateManyKeywordInputEnvelope
    connect?: CommunityInsightWhereUniqueInput | CommunityInsightWhereUniqueInput[]
  }

  export type SearchPatternUncheckedCreateNestedManyWithoutKeywordInput = {
    create?: XOR<SearchPatternCreateWithoutKeywordInput, SearchPatternUncheckedCreateWithoutKeywordInput> | SearchPatternCreateWithoutKeywordInput[] | SearchPatternUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: SearchPatternCreateOrConnectWithoutKeywordInput | SearchPatternCreateOrConnectWithoutKeywordInput[]
    createMany?: SearchPatternCreateManyKeywordInputEnvelope
    connect?: SearchPatternWhereUniqueInput | SearchPatternWhereUniqueInput[]
  }

  export type CommunityMiningResultUncheckedCreateNestedManyWithoutKeywordInput = {
    create?: XOR<CommunityMiningResultCreateWithoutKeywordInput, CommunityMiningResultUncheckedCreateWithoutKeywordInput> | CommunityMiningResultCreateWithoutKeywordInput[] | CommunityMiningResultUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: CommunityMiningResultCreateOrConnectWithoutKeywordInput | CommunityMiningResultCreateOrConnectWithoutKeywordInput[]
    createMany?: CommunityMiningResultCreateManyKeywordInputEnvelope
    connect?: CommunityMiningResultWhereUniqueInput | CommunityMiningResultWhereUniqueInput[]
  }

  export type SearchPatternResultUncheckedCreateNestedManyWithoutKeywordInput = {
    create?: XOR<SearchPatternResultCreateWithoutKeywordInput, SearchPatternResultUncheckedCreateWithoutKeywordInput> | SearchPatternResultCreateWithoutKeywordInput[] | SearchPatternResultUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: SearchPatternResultCreateOrConnectWithoutKeywordInput | SearchPatternResultCreateOrConnectWithoutKeywordInput[]
    createMany?: SearchPatternResultCreateManyKeywordInputEnvelope
    connect?: SearchPatternResultWhereUniqueInput | SearchPatternResultWhereUniqueInput[]
  }

  export type IntentClassificationResultUncheckedCreateNestedManyWithoutKeywordInput = {
    create?: XOR<IntentClassificationResultCreateWithoutKeywordInput, IntentClassificationResultUncheckedCreateWithoutKeywordInput> | IntentClassificationResultCreateWithoutKeywordInput[] | IntentClassificationResultUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: IntentClassificationResultCreateOrConnectWithoutKeywordInput | IntentClassificationResultCreateOrConnectWithoutKeywordInput[]
    createMany?: IntentClassificationResultCreateManyKeywordInputEnvelope
    connect?: IntentClassificationResultWhereUniqueInput | IntentClassificationResultWhereUniqueInput[]
  }

  export type GeneratedIntentPhraseUncheckedCreateNestedManyWithoutKeywordInput = {
    create?: XOR<GeneratedIntentPhraseCreateWithoutKeywordInput, GeneratedIntentPhraseUncheckedCreateWithoutKeywordInput> | GeneratedIntentPhraseCreateWithoutKeywordInput[] | GeneratedIntentPhraseUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: GeneratedIntentPhraseCreateOrConnectWithoutKeywordInput | GeneratedIntentPhraseCreateOrConnectWithoutKeywordInput[]
    createMany?: GeneratedIntentPhraseCreateManyKeywordInputEnvelope
    connect?: GeneratedIntentPhraseWhereUniqueInput | GeneratedIntentPhraseWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DomainUpdateOneWithoutKeywordsNestedInput = {
    create?: XOR<DomainCreateWithoutKeywordsInput, DomainUncheckedCreateWithoutKeywordsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutKeywordsInput
    upsert?: DomainUpsertWithoutKeywordsInput
    disconnect?: DomainWhereInput | boolean
    delete?: DomainWhereInput | boolean
    connect?: DomainWhereUniqueInput
    update?: XOR<XOR<DomainUpdateToOneWithWhereWithoutKeywordsInput, DomainUpdateWithoutKeywordsInput>, DomainUncheckedUpdateWithoutKeywordsInput>
  }

  export type PhraseUpdateManyWithoutKeywordNestedInput = {
    create?: XOR<PhraseCreateWithoutKeywordInput, PhraseUncheckedCreateWithoutKeywordInput> | PhraseCreateWithoutKeywordInput[] | PhraseUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: PhraseCreateOrConnectWithoutKeywordInput | PhraseCreateOrConnectWithoutKeywordInput[]
    upsert?: PhraseUpsertWithWhereUniqueWithoutKeywordInput | PhraseUpsertWithWhereUniqueWithoutKeywordInput[]
    createMany?: PhraseCreateManyKeywordInputEnvelope
    set?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
    disconnect?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
    delete?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
    connect?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
    update?: PhraseUpdateWithWhereUniqueWithoutKeywordInput | PhraseUpdateWithWhereUniqueWithoutKeywordInput[]
    updateMany?: PhraseUpdateManyWithWhereWithoutKeywordInput | PhraseUpdateManyWithWhereWithoutKeywordInput[]
    deleteMany?: PhraseScalarWhereInput | PhraseScalarWhereInput[]
  }

  export type CommunityInsightUpdateManyWithoutKeywordNestedInput = {
    create?: XOR<CommunityInsightCreateWithoutKeywordInput, CommunityInsightUncheckedCreateWithoutKeywordInput> | CommunityInsightCreateWithoutKeywordInput[] | CommunityInsightUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: CommunityInsightCreateOrConnectWithoutKeywordInput | CommunityInsightCreateOrConnectWithoutKeywordInput[]
    upsert?: CommunityInsightUpsertWithWhereUniqueWithoutKeywordInput | CommunityInsightUpsertWithWhereUniqueWithoutKeywordInput[]
    createMany?: CommunityInsightCreateManyKeywordInputEnvelope
    set?: CommunityInsightWhereUniqueInput | CommunityInsightWhereUniqueInput[]
    disconnect?: CommunityInsightWhereUniqueInput | CommunityInsightWhereUniqueInput[]
    delete?: CommunityInsightWhereUniqueInput | CommunityInsightWhereUniqueInput[]
    connect?: CommunityInsightWhereUniqueInput | CommunityInsightWhereUniqueInput[]
    update?: CommunityInsightUpdateWithWhereUniqueWithoutKeywordInput | CommunityInsightUpdateWithWhereUniqueWithoutKeywordInput[]
    updateMany?: CommunityInsightUpdateManyWithWhereWithoutKeywordInput | CommunityInsightUpdateManyWithWhereWithoutKeywordInput[]
    deleteMany?: CommunityInsightScalarWhereInput | CommunityInsightScalarWhereInput[]
  }

  export type SearchPatternUpdateManyWithoutKeywordNestedInput = {
    create?: XOR<SearchPatternCreateWithoutKeywordInput, SearchPatternUncheckedCreateWithoutKeywordInput> | SearchPatternCreateWithoutKeywordInput[] | SearchPatternUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: SearchPatternCreateOrConnectWithoutKeywordInput | SearchPatternCreateOrConnectWithoutKeywordInput[]
    upsert?: SearchPatternUpsertWithWhereUniqueWithoutKeywordInput | SearchPatternUpsertWithWhereUniqueWithoutKeywordInput[]
    createMany?: SearchPatternCreateManyKeywordInputEnvelope
    set?: SearchPatternWhereUniqueInput | SearchPatternWhereUniqueInput[]
    disconnect?: SearchPatternWhereUniqueInput | SearchPatternWhereUniqueInput[]
    delete?: SearchPatternWhereUniqueInput | SearchPatternWhereUniqueInput[]
    connect?: SearchPatternWhereUniqueInput | SearchPatternWhereUniqueInput[]
    update?: SearchPatternUpdateWithWhereUniqueWithoutKeywordInput | SearchPatternUpdateWithWhereUniqueWithoutKeywordInput[]
    updateMany?: SearchPatternUpdateManyWithWhereWithoutKeywordInput | SearchPatternUpdateManyWithWhereWithoutKeywordInput[]
    deleteMany?: SearchPatternScalarWhereInput | SearchPatternScalarWhereInput[]
  }

  export type CommunityMiningResultUpdateManyWithoutKeywordNestedInput = {
    create?: XOR<CommunityMiningResultCreateWithoutKeywordInput, CommunityMiningResultUncheckedCreateWithoutKeywordInput> | CommunityMiningResultCreateWithoutKeywordInput[] | CommunityMiningResultUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: CommunityMiningResultCreateOrConnectWithoutKeywordInput | CommunityMiningResultCreateOrConnectWithoutKeywordInput[]
    upsert?: CommunityMiningResultUpsertWithWhereUniqueWithoutKeywordInput | CommunityMiningResultUpsertWithWhereUniqueWithoutKeywordInput[]
    createMany?: CommunityMiningResultCreateManyKeywordInputEnvelope
    set?: CommunityMiningResultWhereUniqueInput | CommunityMiningResultWhereUniqueInput[]
    disconnect?: CommunityMiningResultWhereUniqueInput | CommunityMiningResultWhereUniqueInput[]
    delete?: CommunityMiningResultWhereUniqueInput | CommunityMiningResultWhereUniqueInput[]
    connect?: CommunityMiningResultWhereUniqueInput | CommunityMiningResultWhereUniqueInput[]
    update?: CommunityMiningResultUpdateWithWhereUniqueWithoutKeywordInput | CommunityMiningResultUpdateWithWhereUniqueWithoutKeywordInput[]
    updateMany?: CommunityMiningResultUpdateManyWithWhereWithoutKeywordInput | CommunityMiningResultUpdateManyWithWhereWithoutKeywordInput[]
    deleteMany?: CommunityMiningResultScalarWhereInput | CommunityMiningResultScalarWhereInput[]
  }

  export type SearchPatternResultUpdateManyWithoutKeywordNestedInput = {
    create?: XOR<SearchPatternResultCreateWithoutKeywordInput, SearchPatternResultUncheckedCreateWithoutKeywordInput> | SearchPatternResultCreateWithoutKeywordInput[] | SearchPatternResultUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: SearchPatternResultCreateOrConnectWithoutKeywordInput | SearchPatternResultCreateOrConnectWithoutKeywordInput[]
    upsert?: SearchPatternResultUpsertWithWhereUniqueWithoutKeywordInput | SearchPatternResultUpsertWithWhereUniqueWithoutKeywordInput[]
    createMany?: SearchPatternResultCreateManyKeywordInputEnvelope
    set?: SearchPatternResultWhereUniqueInput | SearchPatternResultWhereUniqueInput[]
    disconnect?: SearchPatternResultWhereUniqueInput | SearchPatternResultWhereUniqueInput[]
    delete?: SearchPatternResultWhereUniqueInput | SearchPatternResultWhereUniqueInput[]
    connect?: SearchPatternResultWhereUniqueInput | SearchPatternResultWhereUniqueInput[]
    update?: SearchPatternResultUpdateWithWhereUniqueWithoutKeywordInput | SearchPatternResultUpdateWithWhereUniqueWithoutKeywordInput[]
    updateMany?: SearchPatternResultUpdateManyWithWhereWithoutKeywordInput | SearchPatternResultUpdateManyWithWhereWithoutKeywordInput[]
    deleteMany?: SearchPatternResultScalarWhereInput | SearchPatternResultScalarWhereInput[]
  }

  export type IntentClassificationResultUpdateManyWithoutKeywordNestedInput = {
    create?: XOR<IntentClassificationResultCreateWithoutKeywordInput, IntentClassificationResultUncheckedCreateWithoutKeywordInput> | IntentClassificationResultCreateWithoutKeywordInput[] | IntentClassificationResultUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: IntentClassificationResultCreateOrConnectWithoutKeywordInput | IntentClassificationResultCreateOrConnectWithoutKeywordInput[]
    upsert?: IntentClassificationResultUpsertWithWhereUniqueWithoutKeywordInput | IntentClassificationResultUpsertWithWhereUniqueWithoutKeywordInput[]
    createMany?: IntentClassificationResultCreateManyKeywordInputEnvelope
    set?: IntentClassificationResultWhereUniqueInput | IntentClassificationResultWhereUniqueInput[]
    disconnect?: IntentClassificationResultWhereUniqueInput | IntentClassificationResultWhereUniqueInput[]
    delete?: IntentClassificationResultWhereUniqueInput | IntentClassificationResultWhereUniqueInput[]
    connect?: IntentClassificationResultWhereUniqueInput | IntentClassificationResultWhereUniqueInput[]
    update?: IntentClassificationResultUpdateWithWhereUniqueWithoutKeywordInput | IntentClassificationResultUpdateWithWhereUniqueWithoutKeywordInput[]
    updateMany?: IntentClassificationResultUpdateManyWithWhereWithoutKeywordInput | IntentClassificationResultUpdateManyWithWhereWithoutKeywordInput[]
    deleteMany?: IntentClassificationResultScalarWhereInput | IntentClassificationResultScalarWhereInput[]
  }

  export type GeneratedIntentPhraseUpdateManyWithoutKeywordNestedInput = {
    create?: XOR<GeneratedIntentPhraseCreateWithoutKeywordInput, GeneratedIntentPhraseUncheckedCreateWithoutKeywordInput> | GeneratedIntentPhraseCreateWithoutKeywordInput[] | GeneratedIntentPhraseUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: GeneratedIntentPhraseCreateOrConnectWithoutKeywordInput | GeneratedIntentPhraseCreateOrConnectWithoutKeywordInput[]
    upsert?: GeneratedIntentPhraseUpsertWithWhereUniqueWithoutKeywordInput | GeneratedIntentPhraseUpsertWithWhereUniqueWithoutKeywordInput[]
    createMany?: GeneratedIntentPhraseCreateManyKeywordInputEnvelope
    set?: GeneratedIntentPhraseWhereUniqueInput | GeneratedIntentPhraseWhereUniqueInput[]
    disconnect?: GeneratedIntentPhraseWhereUniqueInput | GeneratedIntentPhraseWhereUniqueInput[]
    delete?: GeneratedIntentPhraseWhereUniqueInput | GeneratedIntentPhraseWhereUniqueInput[]
    connect?: GeneratedIntentPhraseWhereUniqueInput | GeneratedIntentPhraseWhereUniqueInput[]
    update?: GeneratedIntentPhraseUpdateWithWhereUniqueWithoutKeywordInput | GeneratedIntentPhraseUpdateWithWhereUniqueWithoutKeywordInput[]
    updateMany?: GeneratedIntentPhraseUpdateManyWithWhereWithoutKeywordInput | GeneratedIntentPhraseUpdateManyWithWhereWithoutKeywordInput[]
    deleteMany?: GeneratedIntentPhraseScalarWhereInput | GeneratedIntentPhraseScalarWhereInput[]
  }

  export type PhraseUncheckedUpdateManyWithoutKeywordNestedInput = {
    create?: XOR<PhraseCreateWithoutKeywordInput, PhraseUncheckedCreateWithoutKeywordInput> | PhraseCreateWithoutKeywordInput[] | PhraseUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: PhraseCreateOrConnectWithoutKeywordInput | PhraseCreateOrConnectWithoutKeywordInput[]
    upsert?: PhraseUpsertWithWhereUniqueWithoutKeywordInput | PhraseUpsertWithWhereUniqueWithoutKeywordInput[]
    createMany?: PhraseCreateManyKeywordInputEnvelope
    set?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
    disconnect?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
    delete?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
    connect?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
    update?: PhraseUpdateWithWhereUniqueWithoutKeywordInput | PhraseUpdateWithWhereUniqueWithoutKeywordInput[]
    updateMany?: PhraseUpdateManyWithWhereWithoutKeywordInput | PhraseUpdateManyWithWhereWithoutKeywordInput[]
    deleteMany?: PhraseScalarWhereInput | PhraseScalarWhereInput[]
  }

  export type CommunityInsightUncheckedUpdateManyWithoutKeywordNestedInput = {
    create?: XOR<CommunityInsightCreateWithoutKeywordInput, CommunityInsightUncheckedCreateWithoutKeywordInput> | CommunityInsightCreateWithoutKeywordInput[] | CommunityInsightUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: CommunityInsightCreateOrConnectWithoutKeywordInput | CommunityInsightCreateOrConnectWithoutKeywordInput[]
    upsert?: CommunityInsightUpsertWithWhereUniqueWithoutKeywordInput | CommunityInsightUpsertWithWhereUniqueWithoutKeywordInput[]
    createMany?: CommunityInsightCreateManyKeywordInputEnvelope
    set?: CommunityInsightWhereUniqueInput | CommunityInsightWhereUniqueInput[]
    disconnect?: CommunityInsightWhereUniqueInput | CommunityInsightWhereUniqueInput[]
    delete?: CommunityInsightWhereUniqueInput | CommunityInsightWhereUniqueInput[]
    connect?: CommunityInsightWhereUniqueInput | CommunityInsightWhereUniqueInput[]
    update?: CommunityInsightUpdateWithWhereUniqueWithoutKeywordInput | CommunityInsightUpdateWithWhereUniqueWithoutKeywordInput[]
    updateMany?: CommunityInsightUpdateManyWithWhereWithoutKeywordInput | CommunityInsightUpdateManyWithWhereWithoutKeywordInput[]
    deleteMany?: CommunityInsightScalarWhereInput | CommunityInsightScalarWhereInput[]
  }

  export type SearchPatternUncheckedUpdateManyWithoutKeywordNestedInput = {
    create?: XOR<SearchPatternCreateWithoutKeywordInput, SearchPatternUncheckedCreateWithoutKeywordInput> | SearchPatternCreateWithoutKeywordInput[] | SearchPatternUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: SearchPatternCreateOrConnectWithoutKeywordInput | SearchPatternCreateOrConnectWithoutKeywordInput[]
    upsert?: SearchPatternUpsertWithWhereUniqueWithoutKeywordInput | SearchPatternUpsertWithWhereUniqueWithoutKeywordInput[]
    createMany?: SearchPatternCreateManyKeywordInputEnvelope
    set?: SearchPatternWhereUniqueInput | SearchPatternWhereUniqueInput[]
    disconnect?: SearchPatternWhereUniqueInput | SearchPatternWhereUniqueInput[]
    delete?: SearchPatternWhereUniqueInput | SearchPatternWhereUniqueInput[]
    connect?: SearchPatternWhereUniqueInput | SearchPatternWhereUniqueInput[]
    update?: SearchPatternUpdateWithWhereUniqueWithoutKeywordInput | SearchPatternUpdateWithWhereUniqueWithoutKeywordInput[]
    updateMany?: SearchPatternUpdateManyWithWhereWithoutKeywordInput | SearchPatternUpdateManyWithWhereWithoutKeywordInput[]
    deleteMany?: SearchPatternScalarWhereInput | SearchPatternScalarWhereInput[]
  }

  export type CommunityMiningResultUncheckedUpdateManyWithoutKeywordNestedInput = {
    create?: XOR<CommunityMiningResultCreateWithoutKeywordInput, CommunityMiningResultUncheckedCreateWithoutKeywordInput> | CommunityMiningResultCreateWithoutKeywordInput[] | CommunityMiningResultUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: CommunityMiningResultCreateOrConnectWithoutKeywordInput | CommunityMiningResultCreateOrConnectWithoutKeywordInput[]
    upsert?: CommunityMiningResultUpsertWithWhereUniqueWithoutKeywordInput | CommunityMiningResultUpsertWithWhereUniqueWithoutKeywordInput[]
    createMany?: CommunityMiningResultCreateManyKeywordInputEnvelope
    set?: CommunityMiningResultWhereUniqueInput | CommunityMiningResultWhereUniqueInput[]
    disconnect?: CommunityMiningResultWhereUniqueInput | CommunityMiningResultWhereUniqueInput[]
    delete?: CommunityMiningResultWhereUniqueInput | CommunityMiningResultWhereUniqueInput[]
    connect?: CommunityMiningResultWhereUniqueInput | CommunityMiningResultWhereUniqueInput[]
    update?: CommunityMiningResultUpdateWithWhereUniqueWithoutKeywordInput | CommunityMiningResultUpdateWithWhereUniqueWithoutKeywordInput[]
    updateMany?: CommunityMiningResultUpdateManyWithWhereWithoutKeywordInput | CommunityMiningResultUpdateManyWithWhereWithoutKeywordInput[]
    deleteMany?: CommunityMiningResultScalarWhereInput | CommunityMiningResultScalarWhereInput[]
  }

  export type SearchPatternResultUncheckedUpdateManyWithoutKeywordNestedInput = {
    create?: XOR<SearchPatternResultCreateWithoutKeywordInput, SearchPatternResultUncheckedCreateWithoutKeywordInput> | SearchPatternResultCreateWithoutKeywordInput[] | SearchPatternResultUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: SearchPatternResultCreateOrConnectWithoutKeywordInput | SearchPatternResultCreateOrConnectWithoutKeywordInput[]
    upsert?: SearchPatternResultUpsertWithWhereUniqueWithoutKeywordInput | SearchPatternResultUpsertWithWhereUniqueWithoutKeywordInput[]
    createMany?: SearchPatternResultCreateManyKeywordInputEnvelope
    set?: SearchPatternResultWhereUniqueInput | SearchPatternResultWhereUniqueInput[]
    disconnect?: SearchPatternResultWhereUniqueInput | SearchPatternResultWhereUniqueInput[]
    delete?: SearchPatternResultWhereUniqueInput | SearchPatternResultWhereUniqueInput[]
    connect?: SearchPatternResultWhereUniqueInput | SearchPatternResultWhereUniqueInput[]
    update?: SearchPatternResultUpdateWithWhereUniqueWithoutKeywordInput | SearchPatternResultUpdateWithWhereUniqueWithoutKeywordInput[]
    updateMany?: SearchPatternResultUpdateManyWithWhereWithoutKeywordInput | SearchPatternResultUpdateManyWithWhereWithoutKeywordInput[]
    deleteMany?: SearchPatternResultScalarWhereInput | SearchPatternResultScalarWhereInput[]
  }

  export type IntentClassificationResultUncheckedUpdateManyWithoutKeywordNestedInput = {
    create?: XOR<IntentClassificationResultCreateWithoutKeywordInput, IntentClassificationResultUncheckedCreateWithoutKeywordInput> | IntentClassificationResultCreateWithoutKeywordInput[] | IntentClassificationResultUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: IntentClassificationResultCreateOrConnectWithoutKeywordInput | IntentClassificationResultCreateOrConnectWithoutKeywordInput[]
    upsert?: IntentClassificationResultUpsertWithWhereUniqueWithoutKeywordInput | IntentClassificationResultUpsertWithWhereUniqueWithoutKeywordInput[]
    createMany?: IntentClassificationResultCreateManyKeywordInputEnvelope
    set?: IntentClassificationResultWhereUniqueInput | IntentClassificationResultWhereUniqueInput[]
    disconnect?: IntentClassificationResultWhereUniqueInput | IntentClassificationResultWhereUniqueInput[]
    delete?: IntentClassificationResultWhereUniqueInput | IntentClassificationResultWhereUniqueInput[]
    connect?: IntentClassificationResultWhereUniqueInput | IntentClassificationResultWhereUniqueInput[]
    update?: IntentClassificationResultUpdateWithWhereUniqueWithoutKeywordInput | IntentClassificationResultUpdateWithWhereUniqueWithoutKeywordInput[]
    updateMany?: IntentClassificationResultUpdateManyWithWhereWithoutKeywordInput | IntentClassificationResultUpdateManyWithWhereWithoutKeywordInput[]
    deleteMany?: IntentClassificationResultScalarWhereInput | IntentClassificationResultScalarWhereInput[]
  }

  export type GeneratedIntentPhraseUncheckedUpdateManyWithoutKeywordNestedInput = {
    create?: XOR<GeneratedIntentPhraseCreateWithoutKeywordInput, GeneratedIntentPhraseUncheckedCreateWithoutKeywordInput> | GeneratedIntentPhraseCreateWithoutKeywordInput[] | GeneratedIntentPhraseUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: GeneratedIntentPhraseCreateOrConnectWithoutKeywordInput | GeneratedIntentPhraseCreateOrConnectWithoutKeywordInput[]
    upsert?: GeneratedIntentPhraseUpsertWithWhereUniqueWithoutKeywordInput | GeneratedIntentPhraseUpsertWithWhereUniqueWithoutKeywordInput[]
    createMany?: GeneratedIntentPhraseCreateManyKeywordInputEnvelope
    set?: GeneratedIntentPhraseWhereUniqueInput | GeneratedIntentPhraseWhereUniqueInput[]
    disconnect?: GeneratedIntentPhraseWhereUniqueInput | GeneratedIntentPhraseWhereUniqueInput[]
    delete?: GeneratedIntentPhraseWhereUniqueInput | GeneratedIntentPhraseWhereUniqueInput[]
    connect?: GeneratedIntentPhraseWhereUniqueInput | GeneratedIntentPhraseWhereUniqueInput[]
    update?: GeneratedIntentPhraseUpdateWithWhereUniqueWithoutKeywordInput | GeneratedIntentPhraseUpdateWithWhereUniqueWithoutKeywordInput[]
    updateMany?: GeneratedIntentPhraseUpdateManyWithWhereWithoutKeywordInput | GeneratedIntentPhraseUpdateManyWithWhereWithoutKeywordInput[]
    deleteMany?: GeneratedIntentPhraseScalarWhereInput | GeneratedIntentPhraseScalarWhereInput[]
  }

  export type KeywordCreateNestedOneWithoutPhrasesInput = {
    create?: XOR<KeywordCreateWithoutPhrasesInput, KeywordUncheckedCreateWithoutPhrasesInput>
    connectOrCreate?: KeywordCreateOrConnectWithoutPhrasesInput
    connect?: KeywordWhereUniqueInput
  }

  export type PhraseIntentClassificationCreateNestedManyWithoutPhraseInput = {
    create?: XOR<PhraseIntentClassificationCreateWithoutPhraseInput, PhraseIntentClassificationUncheckedCreateWithoutPhraseInput> | PhraseIntentClassificationCreateWithoutPhraseInput[] | PhraseIntentClassificationUncheckedCreateWithoutPhraseInput[]
    connectOrCreate?: PhraseIntentClassificationCreateOrConnectWithoutPhraseInput | PhraseIntentClassificationCreateOrConnectWithoutPhraseInput[]
    createMany?: PhraseIntentClassificationCreateManyPhraseInputEnvelope
    connect?: PhraseIntentClassificationWhereUniqueInput | PhraseIntentClassificationWhereUniqueInput[]
  }

  export type PhraseScoreCreateNestedManyWithoutPhraseInput = {
    create?: XOR<PhraseScoreCreateWithoutPhraseInput, PhraseScoreUncheckedCreateWithoutPhraseInput> | PhraseScoreCreateWithoutPhraseInput[] | PhraseScoreUncheckedCreateWithoutPhraseInput[]
    connectOrCreate?: PhraseScoreCreateOrConnectWithoutPhraseInput | PhraseScoreCreateOrConnectWithoutPhraseInput[]
    createMany?: PhraseScoreCreateManyPhraseInputEnvelope
    connect?: PhraseScoreWhereUniqueInput | PhraseScoreWhereUniqueInput[]
  }

  export type PhraseIntentClassificationUncheckedCreateNestedManyWithoutPhraseInput = {
    create?: XOR<PhraseIntentClassificationCreateWithoutPhraseInput, PhraseIntentClassificationUncheckedCreateWithoutPhraseInput> | PhraseIntentClassificationCreateWithoutPhraseInput[] | PhraseIntentClassificationUncheckedCreateWithoutPhraseInput[]
    connectOrCreate?: PhraseIntentClassificationCreateOrConnectWithoutPhraseInput | PhraseIntentClassificationCreateOrConnectWithoutPhraseInput[]
    createMany?: PhraseIntentClassificationCreateManyPhraseInputEnvelope
    connect?: PhraseIntentClassificationWhereUniqueInput | PhraseIntentClassificationWhereUniqueInput[]
  }

  export type PhraseScoreUncheckedCreateNestedManyWithoutPhraseInput = {
    create?: XOR<PhraseScoreCreateWithoutPhraseInput, PhraseScoreUncheckedCreateWithoutPhraseInput> | PhraseScoreCreateWithoutPhraseInput[] | PhraseScoreUncheckedCreateWithoutPhraseInput[]
    connectOrCreate?: PhraseScoreCreateOrConnectWithoutPhraseInput | PhraseScoreCreateOrConnectWithoutPhraseInput[]
    createMany?: PhraseScoreCreateManyPhraseInputEnvelope
    connect?: PhraseScoreWhereUniqueInput | PhraseScoreWhereUniqueInput[]
  }

  export type KeywordUpdateOneRequiredWithoutPhrasesNestedInput = {
    create?: XOR<KeywordCreateWithoutPhrasesInput, KeywordUncheckedCreateWithoutPhrasesInput>
    connectOrCreate?: KeywordCreateOrConnectWithoutPhrasesInput
    upsert?: KeywordUpsertWithoutPhrasesInput
    connect?: KeywordWhereUniqueInput
    update?: XOR<XOR<KeywordUpdateToOneWithWhereWithoutPhrasesInput, KeywordUpdateWithoutPhrasesInput>, KeywordUncheckedUpdateWithoutPhrasesInput>
  }

  export type PhraseIntentClassificationUpdateManyWithoutPhraseNestedInput = {
    create?: XOR<PhraseIntentClassificationCreateWithoutPhraseInput, PhraseIntentClassificationUncheckedCreateWithoutPhraseInput> | PhraseIntentClassificationCreateWithoutPhraseInput[] | PhraseIntentClassificationUncheckedCreateWithoutPhraseInput[]
    connectOrCreate?: PhraseIntentClassificationCreateOrConnectWithoutPhraseInput | PhraseIntentClassificationCreateOrConnectWithoutPhraseInput[]
    upsert?: PhraseIntentClassificationUpsertWithWhereUniqueWithoutPhraseInput | PhraseIntentClassificationUpsertWithWhereUniqueWithoutPhraseInput[]
    createMany?: PhraseIntentClassificationCreateManyPhraseInputEnvelope
    set?: PhraseIntentClassificationWhereUniqueInput | PhraseIntentClassificationWhereUniqueInput[]
    disconnect?: PhraseIntentClassificationWhereUniqueInput | PhraseIntentClassificationWhereUniqueInput[]
    delete?: PhraseIntentClassificationWhereUniqueInput | PhraseIntentClassificationWhereUniqueInput[]
    connect?: PhraseIntentClassificationWhereUniqueInput | PhraseIntentClassificationWhereUniqueInput[]
    update?: PhraseIntentClassificationUpdateWithWhereUniqueWithoutPhraseInput | PhraseIntentClassificationUpdateWithWhereUniqueWithoutPhraseInput[]
    updateMany?: PhraseIntentClassificationUpdateManyWithWhereWithoutPhraseInput | PhraseIntentClassificationUpdateManyWithWhereWithoutPhraseInput[]
    deleteMany?: PhraseIntentClassificationScalarWhereInput | PhraseIntentClassificationScalarWhereInput[]
  }

  export type PhraseScoreUpdateManyWithoutPhraseNestedInput = {
    create?: XOR<PhraseScoreCreateWithoutPhraseInput, PhraseScoreUncheckedCreateWithoutPhraseInput> | PhraseScoreCreateWithoutPhraseInput[] | PhraseScoreUncheckedCreateWithoutPhraseInput[]
    connectOrCreate?: PhraseScoreCreateOrConnectWithoutPhraseInput | PhraseScoreCreateOrConnectWithoutPhraseInput[]
    upsert?: PhraseScoreUpsertWithWhereUniqueWithoutPhraseInput | PhraseScoreUpsertWithWhereUniqueWithoutPhraseInput[]
    createMany?: PhraseScoreCreateManyPhraseInputEnvelope
    set?: PhraseScoreWhereUniqueInput | PhraseScoreWhereUniqueInput[]
    disconnect?: PhraseScoreWhereUniqueInput | PhraseScoreWhereUniqueInput[]
    delete?: PhraseScoreWhereUniqueInput | PhraseScoreWhereUniqueInput[]
    connect?: PhraseScoreWhereUniqueInput | PhraseScoreWhereUniqueInput[]
    update?: PhraseScoreUpdateWithWhereUniqueWithoutPhraseInput | PhraseScoreUpdateWithWhereUniqueWithoutPhraseInput[]
    updateMany?: PhraseScoreUpdateManyWithWhereWithoutPhraseInput | PhraseScoreUpdateManyWithWhereWithoutPhraseInput[]
    deleteMany?: PhraseScoreScalarWhereInput | PhraseScoreScalarWhereInput[]
  }

  export type PhraseIntentClassificationUncheckedUpdateManyWithoutPhraseNestedInput = {
    create?: XOR<PhraseIntentClassificationCreateWithoutPhraseInput, PhraseIntentClassificationUncheckedCreateWithoutPhraseInput> | PhraseIntentClassificationCreateWithoutPhraseInput[] | PhraseIntentClassificationUncheckedCreateWithoutPhraseInput[]
    connectOrCreate?: PhraseIntentClassificationCreateOrConnectWithoutPhraseInput | PhraseIntentClassificationCreateOrConnectWithoutPhraseInput[]
    upsert?: PhraseIntentClassificationUpsertWithWhereUniqueWithoutPhraseInput | PhraseIntentClassificationUpsertWithWhereUniqueWithoutPhraseInput[]
    createMany?: PhraseIntentClassificationCreateManyPhraseInputEnvelope
    set?: PhraseIntentClassificationWhereUniqueInput | PhraseIntentClassificationWhereUniqueInput[]
    disconnect?: PhraseIntentClassificationWhereUniqueInput | PhraseIntentClassificationWhereUniqueInput[]
    delete?: PhraseIntentClassificationWhereUniqueInput | PhraseIntentClassificationWhereUniqueInput[]
    connect?: PhraseIntentClassificationWhereUniqueInput | PhraseIntentClassificationWhereUniqueInput[]
    update?: PhraseIntentClassificationUpdateWithWhereUniqueWithoutPhraseInput | PhraseIntentClassificationUpdateWithWhereUniqueWithoutPhraseInput[]
    updateMany?: PhraseIntentClassificationUpdateManyWithWhereWithoutPhraseInput | PhraseIntentClassificationUpdateManyWithWhereWithoutPhraseInput[]
    deleteMany?: PhraseIntentClassificationScalarWhereInput | PhraseIntentClassificationScalarWhereInput[]
  }

  export type PhraseScoreUncheckedUpdateManyWithoutPhraseNestedInput = {
    create?: XOR<PhraseScoreCreateWithoutPhraseInput, PhraseScoreUncheckedCreateWithoutPhraseInput> | PhraseScoreCreateWithoutPhraseInput[] | PhraseScoreUncheckedCreateWithoutPhraseInput[]
    connectOrCreate?: PhraseScoreCreateOrConnectWithoutPhraseInput | PhraseScoreCreateOrConnectWithoutPhraseInput[]
    upsert?: PhraseScoreUpsertWithWhereUniqueWithoutPhraseInput | PhraseScoreUpsertWithWhereUniqueWithoutPhraseInput[]
    createMany?: PhraseScoreCreateManyPhraseInputEnvelope
    set?: PhraseScoreWhereUniqueInput | PhraseScoreWhereUniqueInput[]
    disconnect?: PhraseScoreWhereUniqueInput | PhraseScoreWhereUniqueInput[]
    delete?: PhraseScoreWhereUniqueInput | PhraseScoreWhereUniqueInput[]
    connect?: PhraseScoreWhereUniqueInput | PhraseScoreWhereUniqueInput[]
    update?: PhraseScoreUpdateWithWhereUniqueWithoutPhraseInput | PhraseScoreUpdateWithWhereUniqueWithoutPhraseInput[]
    updateMany?: PhraseScoreUpdateManyWithWhereWithoutPhraseInput | PhraseScoreUpdateManyWithWhereWithoutPhraseInput[]
    deleteMany?: PhraseScoreScalarWhereInput | PhraseScoreScalarWhereInput[]
  }

  export type GeneratedIntentPhraseCreateNestedOneWithoutAiQueryResultsInput = {
    create?: XOR<GeneratedIntentPhraseCreateWithoutAiQueryResultsInput, GeneratedIntentPhraseUncheckedCreateWithoutAiQueryResultsInput>
    connectOrCreate?: GeneratedIntentPhraseCreateOrConnectWithoutAiQueryResultsInput
    connect?: GeneratedIntentPhraseWhereUniqueInput
  }

  export type GeneratedIntentPhraseUpdateOneRequiredWithoutAiQueryResultsNestedInput = {
    create?: XOR<GeneratedIntentPhraseCreateWithoutAiQueryResultsInput, GeneratedIntentPhraseUncheckedCreateWithoutAiQueryResultsInput>
    connectOrCreate?: GeneratedIntentPhraseCreateOrConnectWithoutAiQueryResultsInput
    upsert?: GeneratedIntentPhraseUpsertWithoutAiQueryResultsInput
    connect?: GeneratedIntentPhraseWhereUniqueInput
    update?: XOR<XOR<GeneratedIntentPhraseUpdateToOneWithWhereWithoutAiQueryResultsInput, GeneratedIntentPhraseUpdateWithoutAiQueryResultsInput>, GeneratedIntentPhraseUncheckedUpdateWithoutAiQueryResultsInput>
  }

  export type DomainCreateNestedOneWithoutDashboardAnalysesInput = {
    create?: XOR<DomainCreateWithoutDashboardAnalysesInput, DomainUncheckedCreateWithoutDashboardAnalysesInput>
    connectOrCreate?: DomainCreateOrConnectWithoutDashboardAnalysesInput
    connect?: DomainWhereUniqueInput
  }

  export type DomainUpdateOneWithoutDashboardAnalysesNestedInput = {
    create?: XOR<DomainCreateWithoutDashboardAnalysesInput, DomainUncheckedCreateWithoutDashboardAnalysesInput>
    connectOrCreate?: DomainCreateOrConnectWithoutDashboardAnalysesInput
    upsert?: DomainUpsertWithoutDashboardAnalysesInput
    disconnect?: DomainWhereInput | boolean
    delete?: DomainWhereInput | boolean
    connect?: DomainWhereUniqueInput
    update?: XOR<XOR<DomainUpdateToOneWithWhereWithoutDashboardAnalysesInput, DomainUpdateWithoutDashboardAnalysesInput>, DomainUncheckedUpdateWithoutDashboardAnalysesInput>
  }

  export type DomainCreateNestedOneWithoutCompetitorAnalysesInput = {
    create?: XOR<DomainCreateWithoutCompetitorAnalysesInput, DomainUncheckedCreateWithoutCompetitorAnalysesInput>
    connectOrCreate?: DomainCreateOrConnectWithoutCompetitorAnalysesInput
    connect?: DomainWhereUniqueInput
  }

  export type DomainUpdateOneWithoutCompetitorAnalysesNestedInput = {
    create?: XOR<DomainCreateWithoutCompetitorAnalysesInput, DomainUncheckedCreateWithoutCompetitorAnalysesInput>
    connectOrCreate?: DomainCreateOrConnectWithoutCompetitorAnalysesInput
    upsert?: DomainUpsertWithoutCompetitorAnalysesInput
    disconnect?: DomainWhereInput | boolean
    delete?: DomainWhereInput | boolean
    connect?: DomainWhereUniqueInput
    update?: XOR<XOR<DomainUpdateToOneWithWhereWithoutCompetitorAnalysesInput, DomainUpdateWithoutCompetitorAnalysesInput>, DomainUncheckedUpdateWithoutCompetitorAnalysesInput>
  }

  export type DomainCreateNestedOneWithoutSuggestedCompetitorsInput = {
    create?: XOR<DomainCreateWithoutSuggestedCompetitorsInput, DomainUncheckedCreateWithoutSuggestedCompetitorsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutSuggestedCompetitorsInput
    connect?: DomainWhereUniqueInput
  }

  export type DomainUpdateOneWithoutSuggestedCompetitorsNestedInput = {
    create?: XOR<DomainCreateWithoutSuggestedCompetitorsInput, DomainUncheckedCreateWithoutSuggestedCompetitorsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutSuggestedCompetitorsInput
    upsert?: DomainUpsertWithoutSuggestedCompetitorsInput
    disconnect?: DomainWhereInput | boolean
    delete?: DomainWhereInput | boolean
    connect?: DomainWhereUniqueInput
    update?: XOR<XOR<DomainUpdateToOneWithWhereWithoutSuggestedCompetitorsInput, DomainUpdateWithoutSuggestedCompetitorsInput>, DomainUncheckedUpdateWithoutSuggestedCompetitorsInput>
  }

  export type DomainCreateNestedOneWithoutAnalysisPhasesInput = {
    create?: XOR<DomainCreateWithoutAnalysisPhasesInput, DomainUncheckedCreateWithoutAnalysisPhasesInput>
    connectOrCreate?: DomainCreateOrConnectWithoutAnalysisPhasesInput
    connect?: DomainWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DomainUpdateOneWithoutAnalysisPhasesNestedInput = {
    create?: XOR<DomainCreateWithoutAnalysisPhasesInput, DomainUncheckedCreateWithoutAnalysisPhasesInput>
    connectOrCreate?: DomainCreateOrConnectWithoutAnalysisPhasesInput
    upsert?: DomainUpsertWithoutAnalysisPhasesInput
    disconnect?: DomainWhereInput | boolean
    delete?: DomainWhereInput | boolean
    connect?: DomainWhereUniqueInput
    update?: XOR<XOR<DomainUpdateToOneWithWhereWithoutAnalysisPhasesInput, DomainUpdateWithoutAnalysisPhasesInput>, DomainUncheckedUpdateWithoutAnalysisPhasesInput>
  }

  export type DomainCreateNestedOneWithoutSemanticAnalysesInput = {
    create?: XOR<DomainCreateWithoutSemanticAnalysesInput, DomainUncheckedCreateWithoutSemanticAnalysesInput>
    connectOrCreate?: DomainCreateOrConnectWithoutSemanticAnalysesInput
    connect?: DomainWhereUniqueInput
  }

  export type DomainUpdateOneWithoutSemanticAnalysesNestedInput = {
    create?: XOR<DomainCreateWithoutSemanticAnalysesInput, DomainUncheckedCreateWithoutSemanticAnalysesInput>
    connectOrCreate?: DomainCreateOrConnectWithoutSemanticAnalysesInput
    upsert?: DomainUpsertWithoutSemanticAnalysesInput
    disconnect?: DomainWhereInput | boolean
    delete?: DomainWhereInput | boolean
    connect?: DomainWhereUniqueInput
    update?: XOR<XOR<DomainUpdateToOneWithWhereWithoutSemanticAnalysesInput, DomainUpdateWithoutSemanticAnalysesInput>, DomainUncheckedUpdateWithoutSemanticAnalysesInput>
  }

  export type DomainCreateNestedOneWithoutKeywordAnalysesInput = {
    create?: XOR<DomainCreateWithoutKeywordAnalysesInput, DomainUncheckedCreateWithoutKeywordAnalysesInput>
    connectOrCreate?: DomainCreateOrConnectWithoutKeywordAnalysesInput
    connect?: DomainWhereUniqueInput
  }

  export type DomainUpdateOneWithoutKeywordAnalysesNestedInput = {
    create?: XOR<DomainCreateWithoutKeywordAnalysesInput, DomainUncheckedCreateWithoutKeywordAnalysesInput>
    connectOrCreate?: DomainCreateOrConnectWithoutKeywordAnalysesInput
    upsert?: DomainUpsertWithoutKeywordAnalysesInput
    disconnect?: DomainWhereInput | boolean
    delete?: DomainWhereInput | boolean
    connect?: DomainWhereUniqueInput
    update?: XOR<XOR<DomainUpdateToOneWithWhereWithoutKeywordAnalysesInput, DomainUpdateWithoutKeywordAnalysesInput>, DomainUncheckedUpdateWithoutKeywordAnalysesInput>
  }

  export type DomainCreateNestedOneWithoutSearchVolumeClassificationsInput = {
    create?: XOR<DomainCreateWithoutSearchVolumeClassificationsInput, DomainUncheckedCreateWithoutSearchVolumeClassificationsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutSearchVolumeClassificationsInput
    connect?: DomainWhereUniqueInput
  }

  export type DomainUpdateOneWithoutSearchVolumeClassificationsNestedInput = {
    create?: XOR<DomainCreateWithoutSearchVolumeClassificationsInput, DomainUncheckedCreateWithoutSearchVolumeClassificationsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutSearchVolumeClassificationsInput
    upsert?: DomainUpsertWithoutSearchVolumeClassificationsInput
    disconnect?: DomainWhereInput | boolean
    delete?: DomainWhereInput | boolean
    connect?: DomainWhereUniqueInput
    update?: XOR<XOR<DomainUpdateToOneWithWhereWithoutSearchVolumeClassificationsInput, DomainUpdateWithoutSearchVolumeClassificationsInput>, DomainUncheckedUpdateWithoutSearchVolumeClassificationsInput>
  }

  export type DomainCreateNestedOneWithoutIntentClassificationsInput = {
    create?: XOR<DomainCreateWithoutIntentClassificationsInput, DomainUncheckedCreateWithoutIntentClassificationsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutIntentClassificationsInput
    connect?: DomainWhereUniqueInput
  }

  export type DomainUpdateOneWithoutIntentClassificationsNestedInput = {
    create?: XOR<DomainCreateWithoutIntentClassificationsInput, DomainUncheckedCreateWithoutIntentClassificationsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutIntentClassificationsInput
    upsert?: DomainUpsertWithoutIntentClassificationsInput
    disconnect?: DomainWhereInput | boolean
    delete?: DomainWhereInput | boolean
    connect?: DomainWhereUniqueInput
    update?: XOR<XOR<DomainUpdateToOneWithWhereWithoutIntentClassificationsInput, DomainUpdateWithoutIntentClassificationsInput>, DomainUncheckedUpdateWithoutIntentClassificationsInput>
  }

  export type DomainCreateNestedOneWithoutCommunityInsightsInput = {
    create?: XOR<DomainCreateWithoutCommunityInsightsInput, DomainUncheckedCreateWithoutCommunityInsightsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutCommunityInsightsInput
    connect?: DomainWhereUniqueInput
  }

  export type KeywordCreateNestedOneWithoutCommunityInsightsInput = {
    create?: XOR<KeywordCreateWithoutCommunityInsightsInput, KeywordUncheckedCreateWithoutCommunityInsightsInput>
    connectOrCreate?: KeywordCreateOrConnectWithoutCommunityInsightsInput
    connect?: KeywordWhereUniqueInput
  }

  export type DomainUpdateOneWithoutCommunityInsightsNestedInput = {
    create?: XOR<DomainCreateWithoutCommunityInsightsInput, DomainUncheckedCreateWithoutCommunityInsightsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutCommunityInsightsInput
    upsert?: DomainUpsertWithoutCommunityInsightsInput
    disconnect?: DomainWhereInput | boolean
    delete?: DomainWhereInput | boolean
    connect?: DomainWhereUniqueInput
    update?: XOR<XOR<DomainUpdateToOneWithWhereWithoutCommunityInsightsInput, DomainUpdateWithoutCommunityInsightsInput>, DomainUncheckedUpdateWithoutCommunityInsightsInput>
  }

  export type KeywordUpdateOneWithoutCommunityInsightsNestedInput = {
    create?: XOR<KeywordCreateWithoutCommunityInsightsInput, KeywordUncheckedCreateWithoutCommunityInsightsInput>
    connectOrCreate?: KeywordCreateOrConnectWithoutCommunityInsightsInput
    upsert?: KeywordUpsertWithoutCommunityInsightsInput
    disconnect?: KeywordWhereInput | boolean
    delete?: KeywordWhereInput | boolean
    connect?: KeywordWhereUniqueInput
    update?: XOR<XOR<KeywordUpdateToOneWithWhereWithoutCommunityInsightsInput, KeywordUpdateWithoutCommunityInsightsInput>, KeywordUncheckedUpdateWithoutCommunityInsightsInput>
  }

  export type DomainCreateNestedOneWithoutSearchPatternsInput = {
    create?: XOR<DomainCreateWithoutSearchPatternsInput, DomainUncheckedCreateWithoutSearchPatternsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutSearchPatternsInput
    connect?: DomainWhereUniqueInput
  }

  export type KeywordCreateNestedOneWithoutSearchPatternsInput = {
    create?: XOR<KeywordCreateWithoutSearchPatternsInput, KeywordUncheckedCreateWithoutSearchPatternsInput>
    connectOrCreate?: KeywordCreateOrConnectWithoutSearchPatternsInput
    connect?: KeywordWhereUniqueInput
  }

  export type DomainUpdateOneWithoutSearchPatternsNestedInput = {
    create?: XOR<DomainCreateWithoutSearchPatternsInput, DomainUncheckedCreateWithoutSearchPatternsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutSearchPatternsInput
    upsert?: DomainUpsertWithoutSearchPatternsInput
    disconnect?: DomainWhereInput | boolean
    delete?: DomainWhereInput | boolean
    connect?: DomainWhereUniqueInput
    update?: XOR<XOR<DomainUpdateToOneWithWhereWithoutSearchPatternsInput, DomainUpdateWithoutSearchPatternsInput>, DomainUncheckedUpdateWithoutSearchPatternsInput>
  }

  export type KeywordUpdateOneWithoutSearchPatternsNestedInput = {
    create?: XOR<KeywordCreateWithoutSearchPatternsInput, KeywordUncheckedCreateWithoutSearchPatternsInput>
    connectOrCreate?: KeywordCreateOrConnectWithoutSearchPatternsInput
    upsert?: KeywordUpsertWithoutSearchPatternsInput
    disconnect?: KeywordWhereInput | boolean
    delete?: KeywordWhereInput | boolean
    connect?: KeywordWhereUniqueInput
    update?: XOR<XOR<KeywordUpdateToOneWithWhereWithoutSearchPatternsInput, KeywordUpdateWithoutSearchPatternsInput>, KeywordUncheckedUpdateWithoutSearchPatternsInput>
  }

  export type PhraseCreateNestedOneWithoutPhraseIntentClassificationsInput = {
    create?: XOR<PhraseCreateWithoutPhraseIntentClassificationsInput, PhraseUncheckedCreateWithoutPhraseIntentClassificationsInput>
    connectOrCreate?: PhraseCreateOrConnectWithoutPhraseIntentClassificationsInput
    connect?: PhraseWhereUniqueInput
  }

  export type PhraseUpdateOneRequiredWithoutPhraseIntentClassificationsNestedInput = {
    create?: XOR<PhraseCreateWithoutPhraseIntentClassificationsInput, PhraseUncheckedCreateWithoutPhraseIntentClassificationsInput>
    connectOrCreate?: PhraseCreateOrConnectWithoutPhraseIntentClassificationsInput
    upsert?: PhraseUpsertWithoutPhraseIntentClassificationsInput
    connect?: PhraseWhereUniqueInput
    update?: XOR<XOR<PhraseUpdateToOneWithWhereWithoutPhraseIntentClassificationsInput, PhraseUpdateWithoutPhraseIntentClassificationsInput>, PhraseUncheckedUpdateWithoutPhraseIntentClassificationsInput>
  }

  export type PhraseCreateNestedOneWithoutPhraseScoresInput = {
    create?: XOR<PhraseCreateWithoutPhraseScoresInput, PhraseUncheckedCreateWithoutPhraseScoresInput>
    connectOrCreate?: PhraseCreateOrConnectWithoutPhraseScoresInput
    connect?: PhraseWhereUniqueInput
  }

  export type PhraseUpdateOneRequiredWithoutPhraseScoresNestedInput = {
    create?: XOR<PhraseCreateWithoutPhraseScoresInput, PhraseUncheckedCreateWithoutPhraseScoresInput>
    connectOrCreate?: PhraseCreateOrConnectWithoutPhraseScoresInput
    upsert?: PhraseUpsertWithoutPhraseScoresInput
    connect?: PhraseWhereUniqueInput
    update?: XOR<XOR<PhraseUpdateToOneWithWhereWithoutPhraseScoresInput, PhraseUpdateWithoutPhraseScoresInput>, PhraseUncheckedUpdateWithoutPhraseScoresInput>
  }

  export type DomainCreateNestedOneWithoutIntentPhraseGenerationsInput = {
    create?: XOR<DomainCreateWithoutIntentPhraseGenerationsInput, DomainUncheckedCreateWithoutIntentPhraseGenerationsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutIntentPhraseGenerationsInput
    connect?: DomainWhereUniqueInput
  }

  export type DomainUpdateOneWithoutIntentPhraseGenerationsNestedInput = {
    create?: XOR<DomainCreateWithoutIntentPhraseGenerationsInput, DomainUncheckedCreateWithoutIntentPhraseGenerationsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutIntentPhraseGenerationsInput
    upsert?: DomainUpsertWithoutIntentPhraseGenerationsInput
    disconnect?: DomainWhereInput | boolean
    delete?: DomainWhereInput | boolean
    connect?: DomainWhereUniqueInput
    update?: XOR<XOR<DomainUpdateToOneWithWhereWithoutIntentPhraseGenerationsInput, DomainUpdateWithoutIntentPhraseGenerationsInput>, DomainUncheckedUpdateWithoutIntentPhraseGenerationsInput>
  }

  export type DomainCreateNestedOneWithoutCommunityMiningResultsInput = {
    create?: XOR<DomainCreateWithoutCommunityMiningResultsInput, DomainUncheckedCreateWithoutCommunityMiningResultsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutCommunityMiningResultsInput
    connect?: DomainWhereUniqueInput
  }

  export type KeywordCreateNestedOneWithoutCommunityMiningResultsInput = {
    create?: XOR<KeywordCreateWithoutCommunityMiningResultsInput, KeywordUncheckedCreateWithoutCommunityMiningResultsInput>
    connectOrCreate?: KeywordCreateOrConnectWithoutCommunityMiningResultsInput
    connect?: KeywordWhereUniqueInput
  }

  export type DomainUpdateOneWithoutCommunityMiningResultsNestedInput = {
    create?: XOR<DomainCreateWithoutCommunityMiningResultsInput, DomainUncheckedCreateWithoutCommunityMiningResultsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutCommunityMiningResultsInput
    upsert?: DomainUpsertWithoutCommunityMiningResultsInput
    disconnect?: DomainWhereInput | boolean
    delete?: DomainWhereInput | boolean
    connect?: DomainWhereUniqueInput
    update?: XOR<XOR<DomainUpdateToOneWithWhereWithoutCommunityMiningResultsInput, DomainUpdateWithoutCommunityMiningResultsInput>, DomainUncheckedUpdateWithoutCommunityMiningResultsInput>
  }

  export type KeywordUpdateOneWithoutCommunityMiningResultsNestedInput = {
    create?: XOR<KeywordCreateWithoutCommunityMiningResultsInput, KeywordUncheckedCreateWithoutCommunityMiningResultsInput>
    connectOrCreate?: KeywordCreateOrConnectWithoutCommunityMiningResultsInput
    upsert?: KeywordUpsertWithoutCommunityMiningResultsInput
    disconnect?: KeywordWhereInput | boolean
    delete?: KeywordWhereInput | boolean
    connect?: KeywordWhereUniqueInput
    update?: XOR<XOR<KeywordUpdateToOneWithWhereWithoutCommunityMiningResultsInput, KeywordUpdateWithoutCommunityMiningResultsInput>, KeywordUncheckedUpdateWithoutCommunityMiningResultsInput>
  }

  export type DomainCreateNestedOneWithoutSearchPatternResultsInput = {
    create?: XOR<DomainCreateWithoutSearchPatternResultsInput, DomainUncheckedCreateWithoutSearchPatternResultsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutSearchPatternResultsInput
    connect?: DomainWhereUniqueInput
  }

  export type KeywordCreateNestedOneWithoutSearchPatternResultsInput = {
    create?: XOR<KeywordCreateWithoutSearchPatternResultsInput, KeywordUncheckedCreateWithoutSearchPatternResultsInput>
    connectOrCreate?: KeywordCreateOrConnectWithoutSearchPatternResultsInput
    connect?: KeywordWhereUniqueInput
  }

  export type DomainUpdateOneWithoutSearchPatternResultsNestedInput = {
    create?: XOR<DomainCreateWithoutSearchPatternResultsInput, DomainUncheckedCreateWithoutSearchPatternResultsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutSearchPatternResultsInput
    upsert?: DomainUpsertWithoutSearchPatternResultsInput
    disconnect?: DomainWhereInput | boolean
    delete?: DomainWhereInput | boolean
    connect?: DomainWhereUniqueInput
    update?: XOR<XOR<DomainUpdateToOneWithWhereWithoutSearchPatternResultsInput, DomainUpdateWithoutSearchPatternResultsInput>, DomainUncheckedUpdateWithoutSearchPatternResultsInput>
  }

  export type KeywordUpdateOneWithoutSearchPatternResultsNestedInput = {
    create?: XOR<KeywordCreateWithoutSearchPatternResultsInput, KeywordUncheckedCreateWithoutSearchPatternResultsInput>
    connectOrCreate?: KeywordCreateOrConnectWithoutSearchPatternResultsInput
    upsert?: KeywordUpsertWithoutSearchPatternResultsInput
    disconnect?: KeywordWhereInput | boolean
    delete?: KeywordWhereInput | boolean
    connect?: KeywordWhereUniqueInput
    update?: XOR<XOR<KeywordUpdateToOneWithWhereWithoutSearchPatternResultsInput, KeywordUpdateWithoutSearchPatternResultsInput>, KeywordUncheckedUpdateWithoutSearchPatternResultsInput>
  }

  export type DomainCreateNestedOneWithoutIntentClassificationResultsInput = {
    create?: XOR<DomainCreateWithoutIntentClassificationResultsInput, DomainUncheckedCreateWithoutIntentClassificationResultsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutIntentClassificationResultsInput
    connect?: DomainWhereUniqueInput
  }

  export type KeywordCreateNestedOneWithoutIntentClassificationResultsInput = {
    create?: XOR<KeywordCreateWithoutIntentClassificationResultsInput, KeywordUncheckedCreateWithoutIntentClassificationResultsInput>
    connectOrCreate?: KeywordCreateOrConnectWithoutIntentClassificationResultsInput
    connect?: KeywordWhereUniqueInput
  }

  export type DomainUpdateOneWithoutIntentClassificationResultsNestedInput = {
    create?: XOR<DomainCreateWithoutIntentClassificationResultsInput, DomainUncheckedCreateWithoutIntentClassificationResultsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutIntentClassificationResultsInput
    upsert?: DomainUpsertWithoutIntentClassificationResultsInput
    disconnect?: DomainWhereInput | boolean
    delete?: DomainWhereInput | boolean
    connect?: DomainWhereUniqueInput
    update?: XOR<XOR<DomainUpdateToOneWithWhereWithoutIntentClassificationResultsInput, DomainUpdateWithoutIntentClassificationResultsInput>, DomainUncheckedUpdateWithoutIntentClassificationResultsInput>
  }

  export type KeywordUpdateOneWithoutIntentClassificationResultsNestedInput = {
    create?: XOR<KeywordCreateWithoutIntentClassificationResultsInput, KeywordUncheckedCreateWithoutIntentClassificationResultsInput>
    connectOrCreate?: KeywordCreateOrConnectWithoutIntentClassificationResultsInput
    upsert?: KeywordUpsertWithoutIntentClassificationResultsInput
    disconnect?: KeywordWhereInput | boolean
    delete?: KeywordWhereInput | boolean
    connect?: KeywordWhereUniqueInput
    update?: XOR<XOR<KeywordUpdateToOneWithWhereWithoutIntentClassificationResultsInput, KeywordUpdateWithoutIntentClassificationResultsInput>, KeywordUncheckedUpdateWithoutIntentClassificationResultsInput>
  }

  export type DomainCreateNestedOneWithoutGeneratedIntentPhrasesInput = {
    create?: XOR<DomainCreateWithoutGeneratedIntentPhrasesInput, DomainUncheckedCreateWithoutGeneratedIntentPhrasesInput>
    connectOrCreate?: DomainCreateOrConnectWithoutGeneratedIntentPhrasesInput
    connect?: DomainWhereUniqueInput
  }

  export type KeywordCreateNestedOneWithoutGeneratedIntentPhrasesInput = {
    create?: XOR<KeywordCreateWithoutGeneratedIntentPhrasesInput, KeywordUncheckedCreateWithoutGeneratedIntentPhrasesInput>
    connectOrCreate?: KeywordCreateOrConnectWithoutGeneratedIntentPhrasesInput
    connect?: KeywordWhereUniqueInput
  }

  export type RelevanceScoreResultCreateNestedManyWithoutPhraseInput = {
    create?: XOR<RelevanceScoreResultCreateWithoutPhraseInput, RelevanceScoreResultUncheckedCreateWithoutPhraseInput> | RelevanceScoreResultCreateWithoutPhraseInput[] | RelevanceScoreResultUncheckedCreateWithoutPhraseInput[]
    connectOrCreate?: RelevanceScoreResultCreateOrConnectWithoutPhraseInput | RelevanceScoreResultCreateOrConnectWithoutPhraseInput[]
    createMany?: RelevanceScoreResultCreateManyPhraseInputEnvelope
    connect?: RelevanceScoreResultWhereUniqueInput | RelevanceScoreResultWhereUniqueInput[]
  }

  export type AIQueryResultCreateNestedManyWithoutPhraseInput = {
    create?: XOR<AIQueryResultCreateWithoutPhraseInput, AIQueryResultUncheckedCreateWithoutPhraseInput> | AIQueryResultCreateWithoutPhraseInput[] | AIQueryResultUncheckedCreateWithoutPhraseInput[]
    connectOrCreate?: AIQueryResultCreateOrConnectWithoutPhraseInput | AIQueryResultCreateOrConnectWithoutPhraseInput[]
    createMany?: AIQueryResultCreateManyPhraseInputEnvelope
    connect?: AIQueryResultWhereUniqueInput | AIQueryResultWhereUniqueInput[]
  }

  export type RelevanceScoreResultUncheckedCreateNestedManyWithoutPhraseInput = {
    create?: XOR<RelevanceScoreResultCreateWithoutPhraseInput, RelevanceScoreResultUncheckedCreateWithoutPhraseInput> | RelevanceScoreResultCreateWithoutPhraseInput[] | RelevanceScoreResultUncheckedCreateWithoutPhraseInput[]
    connectOrCreate?: RelevanceScoreResultCreateOrConnectWithoutPhraseInput | RelevanceScoreResultCreateOrConnectWithoutPhraseInput[]
    createMany?: RelevanceScoreResultCreateManyPhraseInputEnvelope
    connect?: RelevanceScoreResultWhereUniqueInput | RelevanceScoreResultWhereUniqueInput[]
  }

  export type AIQueryResultUncheckedCreateNestedManyWithoutPhraseInput = {
    create?: XOR<AIQueryResultCreateWithoutPhraseInput, AIQueryResultUncheckedCreateWithoutPhraseInput> | AIQueryResultCreateWithoutPhraseInput[] | AIQueryResultUncheckedCreateWithoutPhraseInput[]
    connectOrCreate?: AIQueryResultCreateOrConnectWithoutPhraseInput | AIQueryResultCreateOrConnectWithoutPhraseInput[]
    createMany?: AIQueryResultCreateManyPhraseInputEnvelope
    connect?: AIQueryResultWhereUniqueInput | AIQueryResultWhereUniqueInput[]
  }

  export type DomainUpdateOneWithoutGeneratedIntentPhrasesNestedInput = {
    create?: XOR<DomainCreateWithoutGeneratedIntentPhrasesInput, DomainUncheckedCreateWithoutGeneratedIntentPhrasesInput>
    connectOrCreate?: DomainCreateOrConnectWithoutGeneratedIntentPhrasesInput
    upsert?: DomainUpsertWithoutGeneratedIntentPhrasesInput
    disconnect?: DomainWhereInput | boolean
    delete?: DomainWhereInput | boolean
    connect?: DomainWhereUniqueInput
    update?: XOR<XOR<DomainUpdateToOneWithWhereWithoutGeneratedIntentPhrasesInput, DomainUpdateWithoutGeneratedIntentPhrasesInput>, DomainUncheckedUpdateWithoutGeneratedIntentPhrasesInput>
  }

  export type KeywordUpdateOneWithoutGeneratedIntentPhrasesNestedInput = {
    create?: XOR<KeywordCreateWithoutGeneratedIntentPhrasesInput, KeywordUncheckedCreateWithoutGeneratedIntentPhrasesInput>
    connectOrCreate?: KeywordCreateOrConnectWithoutGeneratedIntentPhrasesInput
    upsert?: KeywordUpsertWithoutGeneratedIntentPhrasesInput
    disconnect?: KeywordWhereInput | boolean
    delete?: KeywordWhereInput | boolean
    connect?: KeywordWhereUniqueInput
    update?: XOR<XOR<KeywordUpdateToOneWithWhereWithoutGeneratedIntentPhrasesInput, KeywordUpdateWithoutGeneratedIntentPhrasesInput>, KeywordUncheckedUpdateWithoutGeneratedIntentPhrasesInput>
  }

  export type RelevanceScoreResultUpdateManyWithoutPhraseNestedInput = {
    create?: XOR<RelevanceScoreResultCreateWithoutPhraseInput, RelevanceScoreResultUncheckedCreateWithoutPhraseInput> | RelevanceScoreResultCreateWithoutPhraseInput[] | RelevanceScoreResultUncheckedCreateWithoutPhraseInput[]
    connectOrCreate?: RelevanceScoreResultCreateOrConnectWithoutPhraseInput | RelevanceScoreResultCreateOrConnectWithoutPhraseInput[]
    upsert?: RelevanceScoreResultUpsertWithWhereUniqueWithoutPhraseInput | RelevanceScoreResultUpsertWithWhereUniqueWithoutPhraseInput[]
    createMany?: RelevanceScoreResultCreateManyPhraseInputEnvelope
    set?: RelevanceScoreResultWhereUniqueInput | RelevanceScoreResultWhereUniqueInput[]
    disconnect?: RelevanceScoreResultWhereUniqueInput | RelevanceScoreResultWhereUniqueInput[]
    delete?: RelevanceScoreResultWhereUniqueInput | RelevanceScoreResultWhereUniqueInput[]
    connect?: RelevanceScoreResultWhereUniqueInput | RelevanceScoreResultWhereUniqueInput[]
    update?: RelevanceScoreResultUpdateWithWhereUniqueWithoutPhraseInput | RelevanceScoreResultUpdateWithWhereUniqueWithoutPhraseInput[]
    updateMany?: RelevanceScoreResultUpdateManyWithWhereWithoutPhraseInput | RelevanceScoreResultUpdateManyWithWhereWithoutPhraseInput[]
    deleteMany?: RelevanceScoreResultScalarWhereInput | RelevanceScoreResultScalarWhereInput[]
  }

  export type AIQueryResultUpdateManyWithoutPhraseNestedInput = {
    create?: XOR<AIQueryResultCreateWithoutPhraseInput, AIQueryResultUncheckedCreateWithoutPhraseInput> | AIQueryResultCreateWithoutPhraseInput[] | AIQueryResultUncheckedCreateWithoutPhraseInput[]
    connectOrCreate?: AIQueryResultCreateOrConnectWithoutPhraseInput | AIQueryResultCreateOrConnectWithoutPhraseInput[]
    upsert?: AIQueryResultUpsertWithWhereUniqueWithoutPhraseInput | AIQueryResultUpsertWithWhereUniqueWithoutPhraseInput[]
    createMany?: AIQueryResultCreateManyPhraseInputEnvelope
    set?: AIQueryResultWhereUniqueInput | AIQueryResultWhereUniqueInput[]
    disconnect?: AIQueryResultWhereUniqueInput | AIQueryResultWhereUniqueInput[]
    delete?: AIQueryResultWhereUniqueInput | AIQueryResultWhereUniqueInput[]
    connect?: AIQueryResultWhereUniqueInput | AIQueryResultWhereUniqueInput[]
    update?: AIQueryResultUpdateWithWhereUniqueWithoutPhraseInput | AIQueryResultUpdateWithWhereUniqueWithoutPhraseInput[]
    updateMany?: AIQueryResultUpdateManyWithWhereWithoutPhraseInput | AIQueryResultUpdateManyWithWhereWithoutPhraseInput[]
    deleteMany?: AIQueryResultScalarWhereInput | AIQueryResultScalarWhereInput[]
  }

  export type RelevanceScoreResultUncheckedUpdateManyWithoutPhraseNestedInput = {
    create?: XOR<RelevanceScoreResultCreateWithoutPhraseInput, RelevanceScoreResultUncheckedCreateWithoutPhraseInput> | RelevanceScoreResultCreateWithoutPhraseInput[] | RelevanceScoreResultUncheckedCreateWithoutPhraseInput[]
    connectOrCreate?: RelevanceScoreResultCreateOrConnectWithoutPhraseInput | RelevanceScoreResultCreateOrConnectWithoutPhraseInput[]
    upsert?: RelevanceScoreResultUpsertWithWhereUniqueWithoutPhraseInput | RelevanceScoreResultUpsertWithWhereUniqueWithoutPhraseInput[]
    createMany?: RelevanceScoreResultCreateManyPhraseInputEnvelope
    set?: RelevanceScoreResultWhereUniqueInput | RelevanceScoreResultWhereUniqueInput[]
    disconnect?: RelevanceScoreResultWhereUniqueInput | RelevanceScoreResultWhereUniqueInput[]
    delete?: RelevanceScoreResultWhereUniqueInput | RelevanceScoreResultWhereUniqueInput[]
    connect?: RelevanceScoreResultWhereUniqueInput | RelevanceScoreResultWhereUniqueInput[]
    update?: RelevanceScoreResultUpdateWithWhereUniqueWithoutPhraseInput | RelevanceScoreResultUpdateWithWhereUniqueWithoutPhraseInput[]
    updateMany?: RelevanceScoreResultUpdateManyWithWhereWithoutPhraseInput | RelevanceScoreResultUpdateManyWithWhereWithoutPhraseInput[]
    deleteMany?: RelevanceScoreResultScalarWhereInput | RelevanceScoreResultScalarWhereInput[]
  }

  export type AIQueryResultUncheckedUpdateManyWithoutPhraseNestedInput = {
    create?: XOR<AIQueryResultCreateWithoutPhraseInput, AIQueryResultUncheckedCreateWithoutPhraseInput> | AIQueryResultCreateWithoutPhraseInput[] | AIQueryResultUncheckedCreateWithoutPhraseInput[]
    connectOrCreate?: AIQueryResultCreateOrConnectWithoutPhraseInput | AIQueryResultCreateOrConnectWithoutPhraseInput[]
    upsert?: AIQueryResultUpsertWithWhereUniqueWithoutPhraseInput | AIQueryResultUpsertWithWhereUniqueWithoutPhraseInput[]
    createMany?: AIQueryResultCreateManyPhraseInputEnvelope
    set?: AIQueryResultWhereUniqueInput | AIQueryResultWhereUniqueInput[]
    disconnect?: AIQueryResultWhereUniqueInput | AIQueryResultWhereUniqueInput[]
    delete?: AIQueryResultWhereUniqueInput | AIQueryResultWhereUniqueInput[]
    connect?: AIQueryResultWhereUniqueInput | AIQueryResultWhereUniqueInput[]
    update?: AIQueryResultUpdateWithWhereUniqueWithoutPhraseInput | AIQueryResultUpdateWithWhereUniqueWithoutPhraseInput[]
    updateMany?: AIQueryResultUpdateManyWithWhereWithoutPhraseInput | AIQueryResultUpdateManyWithWhereWithoutPhraseInput[]
    deleteMany?: AIQueryResultScalarWhereInput | AIQueryResultScalarWhereInput[]
  }

  export type DomainCreateNestedOneWithoutRelevanceScoreResultsInput = {
    create?: XOR<DomainCreateWithoutRelevanceScoreResultsInput, DomainUncheckedCreateWithoutRelevanceScoreResultsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutRelevanceScoreResultsInput
    connect?: DomainWhereUniqueInput
  }

  export type GeneratedIntentPhraseCreateNestedOneWithoutRelevanceScoreResultsInput = {
    create?: XOR<GeneratedIntentPhraseCreateWithoutRelevanceScoreResultsInput, GeneratedIntentPhraseUncheckedCreateWithoutRelevanceScoreResultsInput>
    connectOrCreate?: GeneratedIntentPhraseCreateOrConnectWithoutRelevanceScoreResultsInput
    connect?: GeneratedIntentPhraseWhereUniqueInput
  }

  export type DomainUpdateOneWithoutRelevanceScoreResultsNestedInput = {
    create?: XOR<DomainCreateWithoutRelevanceScoreResultsInput, DomainUncheckedCreateWithoutRelevanceScoreResultsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutRelevanceScoreResultsInput
    upsert?: DomainUpsertWithoutRelevanceScoreResultsInput
    disconnect?: DomainWhereInput | boolean
    delete?: DomainWhereInput | boolean
    connect?: DomainWhereUniqueInput
    update?: XOR<XOR<DomainUpdateToOneWithWhereWithoutRelevanceScoreResultsInput, DomainUpdateWithoutRelevanceScoreResultsInput>, DomainUncheckedUpdateWithoutRelevanceScoreResultsInput>
  }

  export type GeneratedIntentPhraseUpdateOneWithoutRelevanceScoreResultsNestedInput = {
    create?: XOR<GeneratedIntentPhraseCreateWithoutRelevanceScoreResultsInput, GeneratedIntentPhraseUncheckedCreateWithoutRelevanceScoreResultsInput>
    connectOrCreate?: GeneratedIntentPhraseCreateOrConnectWithoutRelevanceScoreResultsInput
    upsert?: GeneratedIntentPhraseUpsertWithoutRelevanceScoreResultsInput
    disconnect?: GeneratedIntentPhraseWhereInput | boolean
    delete?: GeneratedIntentPhraseWhereInput | boolean
    connect?: GeneratedIntentPhraseWhereUniqueInput
    update?: XOR<XOR<GeneratedIntentPhraseUpdateToOneWithWhereWithoutRelevanceScoreResultsInput, GeneratedIntentPhraseUpdateWithoutRelevanceScoreResultsInput>, GeneratedIntentPhraseUncheckedUpdateWithoutRelevanceScoreResultsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DomainCreateWithoutUserInput = {
    url: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    crawlResults?: CrawlResultCreateNestedManyWithoutDomainInput
    keywords?: KeywordCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultCreateNestedManyWithoutDomainInput
  }

  export type DomainUncheckedCreateWithoutUserInput = {
    id?: number
    url: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    crawlResults?: CrawlResultUncheckedCreateNestedManyWithoutDomainInput
    keywords?: KeywordUncheckedCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisUncheckedCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisUncheckedCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseUncheckedCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisUncheckedCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisUncheckedCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationUncheckedCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedCreateNestedManyWithoutDomainInput
  }

  export type DomainCreateOrConnectWithoutUserInput = {
    where: DomainWhereUniqueInput
    create: XOR<DomainCreateWithoutUserInput, DomainUncheckedCreateWithoutUserInput>
  }

  export type DomainCreateManyUserInputEnvelope = {
    data: DomainCreateManyUserInput | DomainCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DomainUpsertWithWhereUniqueWithoutUserInput = {
    where: DomainWhereUniqueInput
    update: XOR<DomainUpdateWithoutUserInput, DomainUncheckedUpdateWithoutUserInput>
    create: XOR<DomainCreateWithoutUserInput, DomainUncheckedCreateWithoutUserInput>
  }

  export type DomainUpdateWithWhereUniqueWithoutUserInput = {
    where: DomainWhereUniqueInput
    data: XOR<DomainUpdateWithoutUserInput, DomainUncheckedUpdateWithoutUserInput>
  }

  export type DomainUpdateManyWithWhereWithoutUserInput = {
    where: DomainScalarWhereInput
    data: XOR<DomainUpdateManyMutationInput, DomainUncheckedUpdateManyWithoutUserInput>
  }

  export type DomainScalarWhereInput = {
    AND?: DomainScalarWhereInput | DomainScalarWhereInput[]
    OR?: DomainScalarWhereInput[]
    NOT?: DomainScalarWhereInput | DomainScalarWhereInput[]
    id?: IntFilter<"Domain"> | number
    url?: StringFilter<"Domain"> | string
    context?: StringNullableFilter<"Domain"> | string | null
    userId?: IntNullableFilter<"Domain"> | number | null
    createdAt?: DateTimeFilter<"Domain"> | Date | string
    updatedAt?: DateTimeFilter<"Domain"> | Date | string
    location?: StringNullableFilter<"Domain"> | string | null
    customKeywords?: StringNullableFilter<"Domain"> | string | null
    intentPhrases?: StringNullableFilter<"Domain"> | string | null
    chatModel?: StringNullableFilter<"Domain"> | string | null
    runAllModels?: BoolFilter<"Domain"> | boolean
    locationContext?: StringNullableFilter<"Domain"> | string | null
  }

  export type UserCreateWithoutDomainsInput = {
    email: string
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutDomainsInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutDomainsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDomainsInput, UserUncheckedCreateWithoutDomainsInput>
  }

  export type CrawlResultCreateWithoutDomainInput = {
    pagesScanned: number
    analyzedUrls: string
    extractedContext: string
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type CrawlResultUncheckedCreateWithoutDomainInput = {
    id?: number
    pagesScanned: number
    analyzedUrls: string
    extractedContext: string
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type CrawlResultCreateOrConnectWithoutDomainInput = {
    where: CrawlResultWhereUniqueInput
    create: XOR<CrawlResultCreateWithoutDomainInput, CrawlResultUncheckedCreateWithoutDomainInput>
  }

  export type CrawlResultCreateManyDomainInputEnvelope = {
    data: CrawlResultCreateManyDomainInput | CrawlResultCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type KeywordCreateWithoutDomainInput = {
    term: string
    volume: number
    difficulty: string
    cpc: number
    intent?: string | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    phrases?: PhraseCreateNestedManyWithoutKeywordInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutKeywordInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutKeywordInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutKeywordInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutKeywordInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutKeywordInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutKeywordInput
  }

  export type KeywordUncheckedCreateWithoutDomainInput = {
    id?: number
    term: string
    volume: number
    difficulty: string
    cpc: number
    intent?: string | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    phrases?: PhraseUncheckedCreateNestedManyWithoutKeywordInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutKeywordInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutKeywordInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutKeywordInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutKeywordInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutKeywordInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutKeywordInput
  }

  export type KeywordCreateOrConnectWithoutDomainInput = {
    where: KeywordWhereUniqueInput
    create: XOR<KeywordCreateWithoutDomainInput, KeywordUncheckedCreateWithoutDomainInput>
  }

  export type KeywordCreateManyDomainInputEnvelope = {
    data: KeywordCreateManyDomainInput | KeywordCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type DashboardAnalysisCreateWithoutDomainInput = {
    metrics: JsonNullValueInput | InputJsonValue
    insights: JsonNullValueInput | InputJsonValue
    industryAnalysis: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardAnalysisUncheckedCreateWithoutDomainInput = {
    id?: number
    metrics: JsonNullValueInput | InputJsonValue
    insights: JsonNullValueInput | InputJsonValue
    industryAnalysis: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardAnalysisCreateOrConnectWithoutDomainInput = {
    where: DashboardAnalysisWhereUniqueInput
    create: XOR<DashboardAnalysisCreateWithoutDomainInput, DashboardAnalysisUncheckedCreateWithoutDomainInput>
  }

  export type DashboardAnalysisCreateManyDomainInputEnvelope = {
    data: DashboardAnalysisCreateManyDomainInput | DashboardAnalysisCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type CompetitorAnalysisCreateWithoutDomainInput = {
    competitors: JsonNullValueInput | InputJsonValue
    marketInsights: JsonNullValueInput | InputJsonValue
    strategicRecommendations: JsonNullValueInput | InputJsonValue
    competitiveAnalysis: JsonNullValueInput | InputJsonValue
    competitorList: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompetitorAnalysisUncheckedCreateWithoutDomainInput = {
    id?: number
    competitors: JsonNullValueInput | InputJsonValue
    marketInsights: JsonNullValueInput | InputJsonValue
    strategicRecommendations: JsonNullValueInput | InputJsonValue
    competitiveAnalysis: JsonNullValueInput | InputJsonValue
    competitorList: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompetitorAnalysisCreateOrConnectWithoutDomainInput = {
    where: CompetitorAnalysisWhereUniqueInput
    create: XOR<CompetitorAnalysisCreateWithoutDomainInput, CompetitorAnalysisUncheckedCreateWithoutDomainInput>
  }

  export type CompetitorAnalysisCreateManyDomainInputEnvelope = {
    data: CompetitorAnalysisCreateManyDomainInput | CompetitorAnalysisCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type SuggestedCompetitorCreateWithoutDomainInput = {
    name: string
    competitorDomain: string
    reason: string
    type: string
    createdAt?: Date | string
  }

  export type SuggestedCompetitorUncheckedCreateWithoutDomainInput = {
    id?: number
    name: string
    competitorDomain: string
    reason: string
    type: string
    createdAt?: Date | string
  }

  export type SuggestedCompetitorCreateOrConnectWithoutDomainInput = {
    where: SuggestedCompetitorWhereUniqueInput
    create: XOR<SuggestedCompetitorCreateWithoutDomainInput, SuggestedCompetitorUncheckedCreateWithoutDomainInput>
  }

  export type SuggestedCompetitorCreateManyDomainInputEnvelope = {
    data: SuggestedCompetitorCreateManyDomainInput | SuggestedCompetitorCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type AnalysisPhaseCreateWithoutDomainInput = {
    phase: string
    status: string
    progress?: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalysisPhaseUncheckedCreateWithoutDomainInput = {
    id?: number
    phase: string
    status: string
    progress?: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalysisPhaseCreateOrConnectWithoutDomainInput = {
    where: AnalysisPhaseWhereUniqueInput
    create: XOR<AnalysisPhaseCreateWithoutDomainInput, AnalysisPhaseUncheckedCreateWithoutDomainInput>
  }

  export type AnalysisPhaseCreateManyDomainInputEnvelope = {
    data: AnalysisPhaseCreateManyDomainInput | AnalysisPhaseCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type SemanticAnalysisCreateWithoutDomainInput = {
    contentSummary: string
    keyThemes: JsonNullValueInput | InputJsonValue
    brandVoice: string
    targetAudience: JsonNullValueInput | InputJsonValue
    contentGaps: JsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SemanticAnalysisUncheckedCreateWithoutDomainInput = {
    id?: number
    contentSummary: string
    keyThemes: JsonNullValueInput | InputJsonValue
    brandVoice: string
    targetAudience: JsonNullValueInput | InputJsonValue
    contentGaps: JsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SemanticAnalysisCreateOrConnectWithoutDomainInput = {
    where: SemanticAnalysisWhereUniqueInput
    create: XOR<SemanticAnalysisCreateWithoutDomainInput, SemanticAnalysisUncheckedCreateWithoutDomainInput>
  }

  export type SemanticAnalysisCreateManyDomainInputEnvelope = {
    data: SemanticAnalysisCreateManyDomainInput | SemanticAnalysisCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type KeywordAnalysisCreateWithoutDomainInput = {
    keywords: JsonNullValueInput | InputJsonValue
    searchVolumeData: JsonNullValueInput | InputJsonValue
    intentClassification: JsonNullValueInput | InputJsonValue
    competitiveAnalysis: JsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeywordAnalysisUncheckedCreateWithoutDomainInput = {
    id?: number
    keywords: JsonNullValueInput | InputJsonValue
    searchVolumeData: JsonNullValueInput | InputJsonValue
    intentClassification: JsonNullValueInput | InputJsonValue
    competitiveAnalysis: JsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeywordAnalysisCreateOrConnectWithoutDomainInput = {
    where: KeywordAnalysisWhereUniqueInput
    create: XOR<KeywordAnalysisCreateWithoutDomainInput, KeywordAnalysisUncheckedCreateWithoutDomainInput>
  }

  export type KeywordAnalysisCreateManyDomainInputEnvelope = {
    data: KeywordAnalysisCreateManyDomainInput | KeywordAnalysisCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type SearchVolumeClassificationCreateWithoutDomainInput = {
    highVolumeKeywords: JsonNullValueInput | InputJsonValue
    mediumVolumeKeywords: JsonNullValueInput | InputJsonValue
    lowVolumeKeywords: JsonNullValueInput | InputJsonValue
    volumeTrends: JsonNullValueInput | InputJsonValue
    seasonalPatterns: JsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SearchVolumeClassificationUncheckedCreateWithoutDomainInput = {
    id?: number
    highVolumeKeywords: JsonNullValueInput | InputJsonValue
    mediumVolumeKeywords: JsonNullValueInput | InputJsonValue
    lowVolumeKeywords: JsonNullValueInput | InputJsonValue
    volumeTrends: JsonNullValueInput | InputJsonValue
    seasonalPatterns: JsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SearchVolumeClassificationCreateOrConnectWithoutDomainInput = {
    where: SearchVolumeClassificationWhereUniqueInput
    create: XOR<SearchVolumeClassificationCreateWithoutDomainInput, SearchVolumeClassificationUncheckedCreateWithoutDomainInput>
  }

  export type SearchVolumeClassificationCreateManyDomainInputEnvelope = {
    data: SearchVolumeClassificationCreateManyDomainInput | SearchVolumeClassificationCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type IntentClassificationCreateWithoutDomainInput = {
    informationalKeywords: JsonNullValueInput | InputJsonValue
    navigationalKeywords: JsonNullValueInput | InputJsonValue
    transactionalKeywords: JsonNullValueInput | InputJsonValue
    commercialKeywords: JsonNullValueInput | InputJsonValue
    intentDistribution: JsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntentClassificationUncheckedCreateWithoutDomainInput = {
    id?: number
    informationalKeywords: JsonNullValueInput | InputJsonValue
    navigationalKeywords: JsonNullValueInput | InputJsonValue
    transactionalKeywords: JsonNullValueInput | InputJsonValue
    commercialKeywords: JsonNullValueInput | InputJsonValue
    intentDistribution: JsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntentClassificationCreateOrConnectWithoutDomainInput = {
    where: IntentClassificationWhereUniqueInput
    create: XOR<IntentClassificationCreateWithoutDomainInput, IntentClassificationUncheckedCreateWithoutDomainInput>
  }

  export type IntentClassificationCreateManyDomainInputEnvelope = {
    data: IntentClassificationCreateManyDomainInput | IntentClassificationCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type CommunityInsightCreateWithoutDomainInput = {
    sources: JsonNullValueInput | InputJsonValue
    summary: string
    tokenUsage?: number | null
    createdAt?: Date | string
    keyword?: KeywordCreateNestedOneWithoutCommunityInsightsInput
  }

  export type CommunityInsightUncheckedCreateWithoutDomainInput = {
    id?: number
    keywordId?: number | null
    sources: JsonNullValueInput | InputJsonValue
    summary: string
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type CommunityInsightCreateOrConnectWithoutDomainInput = {
    where: CommunityInsightWhereUniqueInput
    create: XOR<CommunityInsightCreateWithoutDomainInput, CommunityInsightUncheckedCreateWithoutDomainInput>
  }

  export type CommunityInsightCreateManyDomainInputEnvelope = {
    data: CommunityInsightCreateManyDomainInput | CommunityInsightCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type SearchPatternCreateWithoutDomainInput = {
    patterns: JsonNullValueInput | InputJsonValue
    summary: string
    tokenUsage?: number | null
    createdAt?: Date | string
    keyword?: KeywordCreateNestedOneWithoutSearchPatternsInput
  }

  export type SearchPatternUncheckedCreateWithoutDomainInput = {
    id?: number
    keywordId?: number | null
    patterns: JsonNullValueInput | InputJsonValue
    summary: string
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type SearchPatternCreateOrConnectWithoutDomainInput = {
    where: SearchPatternWhereUniqueInput
    create: XOR<SearchPatternCreateWithoutDomainInput, SearchPatternUncheckedCreateWithoutDomainInput>
  }

  export type SearchPatternCreateManyDomainInputEnvelope = {
    data: SearchPatternCreateManyDomainInput | SearchPatternCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type IntentPhraseGenerationCreateWithoutDomainInput = {
    status?: string
    phase: string
    progress?: number
    startTime?: Date | string
    endTime?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntentPhraseGenerationUncheckedCreateWithoutDomainInput = {
    id?: number
    status?: string
    phase: string
    progress?: number
    startTime?: Date | string
    endTime?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntentPhraseGenerationCreateOrConnectWithoutDomainInput = {
    where: IntentPhraseGenerationWhereUniqueInput
    create: XOR<IntentPhraseGenerationCreateWithoutDomainInput, IntentPhraseGenerationUncheckedCreateWithoutDomainInput>
  }

  export type IntentPhraseGenerationCreateManyDomainInputEnvelope = {
    data: IntentPhraseGenerationCreateManyDomainInput | IntentPhraseGenerationCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type CommunityMiningResultCreateWithoutDomainInput = {
    platform: string
    insights: JsonNullValueInput | InputJsonValue
    sentiment?: string | null
    frequency?: number | null
    tokenUsage?: number | null
    createdAt?: Date | string
    keyword?: KeywordCreateNestedOneWithoutCommunityMiningResultsInput
  }

  export type CommunityMiningResultUncheckedCreateWithoutDomainInput = {
    id?: number
    keywordId?: number | null
    platform: string
    insights: JsonNullValueInput | InputJsonValue
    sentiment?: string | null
    frequency?: number | null
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type CommunityMiningResultCreateOrConnectWithoutDomainInput = {
    where: CommunityMiningResultWhereUniqueInput
    create: XOR<CommunityMiningResultCreateWithoutDomainInput, CommunityMiningResultUncheckedCreateWithoutDomainInput>
  }

  export type CommunityMiningResultCreateManyDomainInputEnvelope = {
    data: CommunityMiningResultCreateManyDomainInput | CommunityMiningResultCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type SearchPatternResultCreateWithoutDomainInput = {
    patterns: JsonNullValueInput | InputJsonValue
    volume?: number | null
    seasonality?: NullableJsonNullValueInput | InputJsonValue
    trends?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    keyword?: KeywordCreateNestedOneWithoutSearchPatternResultsInput
  }

  export type SearchPatternResultUncheckedCreateWithoutDomainInput = {
    id?: number
    keywordId?: number | null
    patterns: JsonNullValueInput | InputJsonValue
    volume?: number | null
    seasonality?: NullableJsonNullValueInput | InputJsonValue
    trends?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type SearchPatternResultCreateOrConnectWithoutDomainInput = {
    where: SearchPatternResultWhereUniqueInput
    create: XOR<SearchPatternResultCreateWithoutDomainInput, SearchPatternResultUncheckedCreateWithoutDomainInput>
  }

  export type SearchPatternResultCreateManyDomainInputEnvelope = {
    data: SearchPatternResultCreateManyDomainInput | SearchPatternResultCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type IntentClassificationResultCreateWithoutDomainInput = {
    intent: string
    confidence?: number | null
    patterns?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    keyword?: KeywordCreateNestedOneWithoutIntentClassificationResultsInput
  }

  export type IntentClassificationResultUncheckedCreateWithoutDomainInput = {
    id?: number
    keywordId?: number | null
    intent: string
    confidence?: number | null
    patterns?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type IntentClassificationResultCreateOrConnectWithoutDomainInput = {
    where: IntentClassificationResultWhereUniqueInput
    create: XOR<IntentClassificationResultCreateWithoutDomainInput, IntentClassificationResultUncheckedCreateWithoutDomainInput>
  }

  export type IntentClassificationResultCreateManyDomainInputEnvelope = {
    data: IntentClassificationResultCreateManyDomainInput | IntentClassificationResultCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type GeneratedIntentPhraseCreateWithoutDomainInput = {
    phrase: string
    relevanceScore?: number | null
    intent?: string | null
    intentConfidence?: number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: boolean
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    keyword?: KeywordCreateNestedOneWithoutGeneratedIntentPhrasesInput
    relevanceScoreResults?: RelevanceScoreResultCreateNestedManyWithoutPhraseInput
    aiQueryResults?: AIQueryResultCreateNestedManyWithoutPhraseInput
  }

  export type GeneratedIntentPhraseUncheckedCreateWithoutDomainInput = {
    id?: number
    keywordId?: number | null
    phrase: string
    relevanceScore?: number | null
    intent?: string | null
    intentConfidence?: number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: boolean
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    relevanceScoreResults?: RelevanceScoreResultUncheckedCreateNestedManyWithoutPhraseInput
    aiQueryResults?: AIQueryResultUncheckedCreateNestedManyWithoutPhraseInput
  }

  export type GeneratedIntentPhraseCreateOrConnectWithoutDomainInput = {
    where: GeneratedIntentPhraseWhereUniqueInput
    create: XOR<GeneratedIntentPhraseCreateWithoutDomainInput, GeneratedIntentPhraseUncheckedCreateWithoutDomainInput>
  }

  export type GeneratedIntentPhraseCreateManyDomainInputEnvelope = {
    data: GeneratedIntentPhraseCreateManyDomainInput | GeneratedIntentPhraseCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type RelevanceScoreResultCreateWithoutDomainInput = {
    score: number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    factors?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    phrase?: GeneratedIntentPhraseCreateNestedOneWithoutRelevanceScoreResultsInput
  }

  export type RelevanceScoreResultUncheckedCreateWithoutDomainInput = {
    id?: number
    phraseId?: number | null
    score: number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    factors?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type RelevanceScoreResultCreateOrConnectWithoutDomainInput = {
    where: RelevanceScoreResultWhereUniqueInput
    create: XOR<RelevanceScoreResultCreateWithoutDomainInput, RelevanceScoreResultUncheckedCreateWithoutDomainInput>
  }

  export type RelevanceScoreResultCreateManyDomainInputEnvelope = {
    data: RelevanceScoreResultCreateManyDomainInput | RelevanceScoreResultCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDomainsInput = {
    update: XOR<UserUpdateWithoutDomainsInput, UserUncheckedUpdateWithoutDomainsInput>
    create: XOR<UserCreateWithoutDomainsInput, UserUncheckedCreateWithoutDomainsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDomainsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDomainsInput, UserUncheckedUpdateWithoutDomainsInput>
  }

  export type UserUpdateWithoutDomainsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutDomainsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrawlResultUpsertWithWhereUniqueWithoutDomainInput = {
    where: CrawlResultWhereUniqueInput
    update: XOR<CrawlResultUpdateWithoutDomainInput, CrawlResultUncheckedUpdateWithoutDomainInput>
    create: XOR<CrawlResultCreateWithoutDomainInput, CrawlResultUncheckedCreateWithoutDomainInput>
  }

  export type CrawlResultUpdateWithWhereUniqueWithoutDomainInput = {
    where: CrawlResultWhereUniqueInput
    data: XOR<CrawlResultUpdateWithoutDomainInput, CrawlResultUncheckedUpdateWithoutDomainInput>
  }

  export type CrawlResultUpdateManyWithWhereWithoutDomainInput = {
    where: CrawlResultScalarWhereInput
    data: XOR<CrawlResultUpdateManyMutationInput, CrawlResultUncheckedUpdateManyWithoutDomainInput>
  }

  export type CrawlResultScalarWhereInput = {
    AND?: CrawlResultScalarWhereInput | CrawlResultScalarWhereInput[]
    OR?: CrawlResultScalarWhereInput[]
    NOT?: CrawlResultScalarWhereInput | CrawlResultScalarWhereInput[]
    id?: IntFilter<"CrawlResult"> | number
    domainId?: IntNullableFilter<"CrawlResult"> | number | null
    pagesScanned?: IntFilter<"CrawlResult"> | number
    analyzedUrls?: StringFilter<"CrawlResult"> | string
    extractedContext?: StringFilter<"CrawlResult"> | string
    tokenUsage?: IntNullableFilter<"CrawlResult"> | number | null
    createdAt?: DateTimeFilter<"CrawlResult"> | Date | string
  }

  export type KeywordUpsertWithWhereUniqueWithoutDomainInput = {
    where: KeywordWhereUniqueInput
    update: XOR<KeywordUpdateWithoutDomainInput, KeywordUncheckedUpdateWithoutDomainInput>
    create: XOR<KeywordCreateWithoutDomainInput, KeywordUncheckedCreateWithoutDomainInput>
  }

  export type KeywordUpdateWithWhereUniqueWithoutDomainInput = {
    where: KeywordWhereUniqueInput
    data: XOR<KeywordUpdateWithoutDomainInput, KeywordUncheckedUpdateWithoutDomainInput>
  }

  export type KeywordUpdateManyWithWhereWithoutDomainInput = {
    where: KeywordScalarWhereInput
    data: XOR<KeywordUpdateManyMutationInput, KeywordUncheckedUpdateManyWithoutDomainInput>
  }

  export type KeywordScalarWhereInput = {
    AND?: KeywordScalarWhereInput | KeywordScalarWhereInput[]
    OR?: KeywordScalarWhereInput[]
    NOT?: KeywordScalarWhereInput | KeywordScalarWhereInput[]
    id?: IntFilter<"Keyword"> | number
    term?: StringFilter<"Keyword"> | string
    volume?: IntFilter<"Keyword"> | number
    difficulty?: StringFilter<"Keyword"> | string
    cpc?: FloatFilter<"Keyword"> | number
    intent?: StringNullableFilter<"Keyword"> | string | null
    domainId?: IntNullableFilter<"Keyword"> | number | null
    isSelected?: BoolFilter<"Keyword"> | boolean
    createdAt?: DateTimeFilter<"Keyword"> | Date | string
    updatedAt?: DateTimeFilter<"Keyword"> | Date | string
  }

  export type DashboardAnalysisUpsertWithWhereUniqueWithoutDomainInput = {
    where: DashboardAnalysisWhereUniqueInput
    update: XOR<DashboardAnalysisUpdateWithoutDomainInput, DashboardAnalysisUncheckedUpdateWithoutDomainInput>
    create: XOR<DashboardAnalysisCreateWithoutDomainInput, DashboardAnalysisUncheckedCreateWithoutDomainInput>
  }

  export type DashboardAnalysisUpdateWithWhereUniqueWithoutDomainInput = {
    where: DashboardAnalysisWhereUniqueInput
    data: XOR<DashboardAnalysisUpdateWithoutDomainInput, DashboardAnalysisUncheckedUpdateWithoutDomainInput>
  }

  export type DashboardAnalysisUpdateManyWithWhereWithoutDomainInput = {
    where: DashboardAnalysisScalarWhereInput
    data: XOR<DashboardAnalysisUpdateManyMutationInput, DashboardAnalysisUncheckedUpdateManyWithoutDomainInput>
  }

  export type DashboardAnalysisScalarWhereInput = {
    AND?: DashboardAnalysisScalarWhereInput | DashboardAnalysisScalarWhereInput[]
    OR?: DashboardAnalysisScalarWhereInput[]
    NOT?: DashboardAnalysisScalarWhereInput | DashboardAnalysisScalarWhereInput[]
    id?: IntFilter<"DashboardAnalysis"> | number
    domainId?: IntNullableFilter<"DashboardAnalysis"> | number | null
    metrics?: JsonFilter<"DashboardAnalysis">
    insights?: JsonFilter<"DashboardAnalysis">
    industryAnalysis?: JsonFilter<"DashboardAnalysis">
    createdAt?: DateTimeFilter<"DashboardAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"DashboardAnalysis"> | Date | string
  }

  export type CompetitorAnalysisUpsertWithWhereUniqueWithoutDomainInput = {
    where: CompetitorAnalysisWhereUniqueInput
    update: XOR<CompetitorAnalysisUpdateWithoutDomainInput, CompetitorAnalysisUncheckedUpdateWithoutDomainInput>
    create: XOR<CompetitorAnalysisCreateWithoutDomainInput, CompetitorAnalysisUncheckedCreateWithoutDomainInput>
  }

  export type CompetitorAnalysisUpdateWithWhereUniqueWithoutDomainInput = {
    where: CompetitorAnalysisWhereUniqueInput
    data: XOR<CompetitorAnalysisUpdateWithoutDomainInput, CompetitorAnalysisUncheckedUpdateWithoutDomainInput>
  }

  export type CompetitorAnalysisUpdateManyWithWhereWithoutDomainInput = {
    where: CompetitorAnalysisScalarWhereInput
    data: XOR<CompetitorAnalysisUpdateManyMutationInput, CompetitorAnalysisUncheckedUpdateManyWithoutDomainInput>
  }

  export type CompetitorAnalysisScalarWhereInput = {
    AND?: CompetitorAnalysisScalarWhereInput | CompetitorAnalysisScalarWhereInput[]
    OR?: CompetitorAnalysisScalarWhereInput[]
    NOT?: CompetitorAnalysisScalarWhereInput | CompetitorAnalysisScalarWhereInput[]
    id?: IntFilter<"CompetitorAnalysis"> | number
    domainId?: IntNullableFilter<"CompetitorAnalysis"> | number | null
    competitors?: JsonFilter<"CompetitorAnalysis">
    marketInsights?: JsonFilter<"CompetitorAnalysis">
    strategicRecommendations?: JsonFilter<"CompetitorAnalysis">
    competitiveAnalysis?: JsonFilter<"CompetitorAnalysis">
    competitorList?: StringFilter<"CompetitorAnalysis"> | string
    createdAt?: DateTimeFilter<"CompetitorAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"CompetitorAnalysis"> | Date | string
  }

  export type SuggestedCompetitorUpsertWithWhereUniqueWithoutDomainInput = {
    where: SuggestedCompetitorWhereUniqueInput
    update: XOR<SuggestedCompetitorUpdateWithoutDomainInput, SuggestedCompetitorUncheckedUpdateWithoutDomainInput>
    create: XOR<SuggestedCompetitorCreateWithoutDomainInput, SuggestedCompetitorUncheckedCreateWithoutDomainInput>
  }

  export type SuggestedCompetitorUpdateWithWhereUniqueWithoutDomainInput = {
    where: SuggestedCompetitorWhereUniqueInput
    data: XOR<SuggestedCompetitorUpdateWithoutDomainInput, SuggestedCompetitorUncheckedUpdateWithoutDomainInput>
  }

  export type SuggestedCompetitorUpdateManyWithWhereWithoutDomainInput = {
    where: SuggestedCompetitorScalarWhereInput
    data: XOR<SuggestedCompetitorUpdateManyMutationInput, SuggestedCompetitorUncheckedUpdateManyWithoutDomainInput>
  }

  export type SuggestedCompetitorScalarWhereInput = {
    AND?: SuggestedCompetitorScalarWhereInput | SuggestedCompetitorScalarWhereInput[]
    OR?: SuggestedCompetitorScalarWhereInput[]
    NOT?: SuggestedCompetitorScalarWhereInput | SuggestedCompetitorScalarWhereInput[]
    id?: IntFilter<"SuggestedCompetitor"> | number
    domainId?: IntNullableFilter<"SuggestedCompetitor"> | number | null
    name?: StringFilter<"SuggestedCompetitor"> | string
    competitorDomain?: StringFilter<"SuggestedCompetitor"> | string
    reason?: StringFilter<"SuggestedCompetitor"> | string
    type?: StringFilter<"SuggestedCompetitor"> | string
    createdAt?: DateTimeFilter<"SuggestedCompetitor"> | Date | string
  }

  export type AnalysisPhaseUpsertWithWhereUniqueWithoutDomainInput = {
    where: AnalysisPhaseWhereUniqueInput
    update: XOR<AnalysisPhaseUpdateWithoutDomainInput, AnalysisPhaseUncheckedUpdateWithoutDomainInput>
    create: XOR<AnalysisPhaseCreateWithoutDomainInput, AnalysisPhaseUncheckedCreateWithoutDomainInput>
  }

  export type AnalysisPhaseUpdateWithWhereUniqueWithoutDomainInput = {
    where: AnalysisPhaseWhereUniqueInput
    data: XOR<AnalysisPhaseUpdateWithoutDomainInput, AnalysisPhaseUncheckedUpdateWithoutDomainInput>
  }

  export type AnalysisPhaseUpdateManyWithWhereWithoutDomainInput = {
    where: AnalysisPhaseScalarWhereInput
    data: XOR<AnalysisPhaseUpdateManyMutationInput, AnalysisPhaseUncheckedUpdateManyWithoutDomainInput>
  }

  export type AnalysisPhaseScalarWhereInput = {
    AND?: AnalysisPhaseScalarWhereInput | AnalysisPhaseScalarWhereInput[]
    OR?: AnalysisPhaseScalarWhereInput[]
    NOT?: AnalysisPhaseScalarWhereInput | AnalysisPhaseScalarWhereInput[]
    id?: IntFilter<"AnalysisPhase"> | number
    domainId?: IntNullableFilter<"AnalysisPhase"> | number | null
    phase?: StringFilter<"AnalysisPhase"> | string
    status?: StringFilter<"AnalysisPhase"> | string
    progress?: IntFilter<"AnalysisPhase"> | number
    startTime?: DateTimeNullableFilter<"AnalysisPhase"> | Date | string | null
    endTime?: DateTimeNullableFilter<"AnalysisPhase"> | Date | string | null
    result?: JsonNullableFilter<"AnalysisPhase">
    error?: StringNullableFilter<"AnalysisPhase"> | string | null
    tokenUsage?: IntNullableFilter<"AnalysisPhase"> | number | null
    createdAt?: DateTimeFilter<"AnalysisPhase"> | Date | string
    updatedAt?: DateTimeFilter<"AnalysisPhase"> | Date | string
  }

  export type SemanticAnalysisUpsertWithWhereUniqueWithoutDomainInput = {
    where: SemanticAnalysisWhereUniqueInput
    update: XOR<SemanticAnalysisUpdateWithoutDomainInput, SemanticAnalysisUncheckedUpdateWithoutDomainInput>
    create: XOR<SemanticAnalysisCreateWithoutDomainInput, SemanticAnalysisUncheckedCreateWithoutDomainInput>
  }

  export type SemanticAnalysisUpdateWithWhereUniqueWithoutDomainInput = {
    where: SemanticAnalysisWhereUniqueInput
    data: XOR<SemanticAnalysisUpdateWithoutDomainInput, SemanticAnalysisUncheckedUpdateWithoutDomainInput>
  }

  export type SemanticAnalysisUpdateManyWithWhereWithoutDomainInput = {
    where: SemanticAnalysisScalarWhereInput
    data: XOR<SemanticAnalysisUpdateManyMutationInput, SemanticAnalysisUncheckedUpdateManyWithoutDomainInput>
  }

  export type SemanticAnalysisScalarWhereInput = {
    AND?: SemanticAnalysisScalarWhereInput | SemanticAnalysisScalarWhereInput[]
    OR?: SemanticAnalysisScalarWhereInput[]
    NOT?: SemanticAnalysisScalarWhereInput | SemanticAnalysisScalarWhereInput[]
    id?: IntFilter<"SemanticAnalysis"> | number
    domainId?: IntNullableFilter<"SemanticAnalysis"> | number | null
    contentSummary?: StringFilter<"SemanticAnalysis"> | string
    keyThemes?: JsonFilter<"SemanticAnalysis">
    brandVoice?: StringFilter<"SemanticAnalysis"> | string
    targetAudience?: JsonFilter<"SemanticAnalysis">
    contentGaps?: JsonFilter<"SemanticAnalysis">
    tokenUsage?: IntNullableFilter<"SemanticAnalysis"> | number | null
    createdAt?: DateTimeFilter<"SemanticAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"SemanticAnalysis"> | Date | string
  }

  export type KeywordAnalysisUpsertWithWhereUniqueWithoutDomainInput = {
    where: KeywordAnalysisWhereUniqueInput
    update: XOR<KeywordAnalysisUpdateWithoutDomainInput, KeywordAnalysisUncheckedUpdateWithoutDomainInput>
    create: XOR<KeywordAnalysisCreateWithoutDomainInput, KeywordAnalysisUncheckedCreateWithoutDomainInput>
  }

  export type KeywordAnalysisUpdateWithWhereUniqueWithoutDomainInput = {
    where: KeywordAnalysisWhereUniqueInput
    data: XOR<KeywordAnalysisUpdateWithoutDomainInput, KeywordAnalysisUncheckedUpdateWithoutDomainInput>
  }

  export type KeywordAnalysisUpdateManyWithWhereWithoutDomainInput = {
    where: KeywordAnalysisScalarWhereInput
    data: XOR<KeywordAnalysisUpdateManyMutationInput, KeywordAnalysisUncheckedUpdateManyWithoutDomainInput>
  }

  export type KeywordAnalysisScalarWhereInput = {
    AND?: KeywordAnalysisScalarWhereInput | KeywordAnalysisScalarWhereInput[]
    OR?: KeywordAnalysisScalarWhereInput[]
    NOT?: KeywordAnalysisScalarWhereInput | KeywordAnalysisScalarWhereInput[]
    id?: IntFilter<"KeywordAnalysis"> | number
    domainId?: IntNullableFilter<"KeywordAnalysis"> | number | null
    keywords?: JsonFilter<"KeywordAnalysis">
    searchVolumeData?: JsonFilter<"KeywordAnalysis">
    intentClassification?: JsonFilter<"KeywordAnalysis">
    competitiveAnalysis?: JsonFilter<"KeywordAnalysis">
    tokenUsage?: IntNullableFilter<"KeywordAnalysis"> | number | null
    createdAt?: DateTimeFilter<"KeywordAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"KeywordAnalysis"> | Date | string
  }

  export type SearchVolumeClassificationUpsertWithWhereUniqueWithoutDomainInput = {
    where: SearchVolumeClassificationWhereUniqueInput
    update: XOR<SearchVolumeClassificationUpdateWithoutDomainInput, SearchVolumeClassificationUncheckedUpdateWithoutDomainInput>
    create: XOR<SearchVolumeClassificationCreateWithoutDomainInput, SearchVolumeClassificationUncheckedCreateWithoutDomainInput>
  }

  export type SearchVolumeClassificationUpdateWithWhereUniqueWithoutDomainInput = {
    where: SearchVolumeClassificationWhereUniqueInput
    data: XOR<SearchVolumeClassificationUpdateWithoutDomainInput, SearchVolumeClassificationUncheckedUpdateWithoutDomainInput>
  }

  export type SearchVolumeClassificationUpdateManyWithWhereWithoutDomainInput = {
    where: SearchVolumeClassificationScalarWhereInput
    data: XOR<SearchVolumeClassificationUpdateManyMutationInput, SearchVolumeClassificationUncheckedUpdateManyWithoutDomainInput>
  }

  export type SearchVolumeClassificationScalarWhereInput = {
    AND?: SearchVolumeClassificationScalarWhereInput | SearchVolumeClassificationScalarWhereInput[]
    OR?: SearchVolumeClassificationScalarWhereInput[]
    NOT?: SearchVolumeClassificationScalarWhereInput | SearchVolumeClassificationScalarWhereInput[]
    id?: IntFilter<"SearchVolumeClassification"> | number
    domainId?: IntNullableFilter<"SearchVolumeClassification"> | number | null
    highVolumeKeywords?: JsonFilter<"SearchVolumeClassification">
    mediumVolumeKeywords?: JsonFilter<"SearchVolumeClassification">
    lowVolumeKeywords?: JsonFilter<"SearchVolumeClassification">
    volumeTrends?: JsonFilter<"SearchVolumeClassification">
    seasonalPatterns?: JsonFilter<"SearchVolumeClassification">
    tokenUsage?: IntNullableFilter<"SearchVolumeClassification"> | number | null
    createdAt?: DateTimeFilter<"SearchVolumeClassification"> | Date | string
    updatedAt?: DateTimeFilter<"SearchVolumeClassification"> | Date | string
  }

  export type IntentClassificationUpsertWithWhereUniqueWithoutDomainInput = {
    where: IntentClassificationWhereUniqueInput
    update: XOR<IntentClassificationUpdateWithoutDomainInput, IntentClassificationUncheckedUpdateWithoutDomainInput>
    create: XOR<IntentClassificationCreateWithoutDomainInput, IntentClassificationUncheckedCreateWithoutDomainInput>
  }

  export type IntentClassificationUpdateWithWhereUniqueWithoutDomainInput = {
    where: IntentClassificationWhereUniqueInput
    data: XOR<IntentClassificationUpdateWithoutDomainInput, IntentClassificationUncheckedUpdateWithoutDomainInput>
  }

  export type IntentClassificationUpdateManyWithWhereWithoutDomainInput = {
    where: IntentClassificationScalarWhereInput
    data: XOR<IntentClassificationUpdateManyMutationInput, IntentClassificationUncheckedUpdateManyWithoutDomainInput>
  }

  export type IntentClassificationScalarWhereInput = {
    AND?: IntentClassificationScalarWhereInput | IntentClassificationScalarWhereInput[]
    OR?: IntentClassificationScalarWhereInput[]
    NOT?: IntentClassificationScalarWhereInput | IntentClassificationScalarWhereInput[]
    id?: IntFilter<"IntentClassification"> | number
    domainId?: IntNullableFilter<"IntentClassification"> | number | null
    informationalKeywords?: JsonFilter<"IntentClassification">
    navigationalKeywords?: JsonFilter<"IntentClassification">
    transactionalKeywords?: JsonFilter<"IntentClassification">
    commercialKeywords?: JsonFilter<"IntentClassification">
    intentDistribution?: JsonFilter<"IntentClassification">
    tokenUsage?: IntNullableFilter<"IntentClassification"> | number | null
    createdAt?: DateTimeFilter<"IntentClassification"> | Date | string
    updatedAt?: DateTimeFilter<"IntentClassification"> | Date | string
  }

  export type CommunityInsightUpsertWithWhereUniqueWithoutDomainInput = {
    where: CommunityInsightWhereUniqueInput
    update: XOR<CommunityInsightUpdateWithoutDomainInput, CommunityInsightUncheckedUpdateWithoutDomainInput>
    create: XOR<CommunityInsightCreateWithoutDomainInput, CommunityInsightUncheckedCreateWithoutDomainInput>
  }

  export type CommunityInsightUpdateWithWhereUniqueWithoutDomainInput = {
    where: CommunityInsightWhereUniqueInput
    data: XOR<CommunityInsightUpdateWithoutDomainInput, CommunityInsightUncheckedUpdateWithoutDomainInput>
  }

  export type CommunityInsightUpdateManyWithWhereWithoutDomainInput = {
    where: CommunityInsightScalarWhereInput
    data: XOR<CommunityInsightUpdateManyMutationInput, CommunityInsightUncheckedUpdateManyWithoutDomainInput>
  }

  export type CommunityInsightScalarWhereInput = {
    AND?: CommunityInsightScalarWhereInput | CommunityInsightScalarWhereInput[]
    OR?: CommunityInsightScalarWhereInput[]
    NOT?: CommunityInsightScalarWhereInput | CommunityInsightScalarWhereInput[]
    id?: IntFilter<"CommunityInsight"> | number
    domainId?: IntNullableFilter<"CommunityInsight"> | number | null
    keywordId?: IntNullableFilter<"CommunityInsight"> | number | null
    sources?: JsonFilter<"CommunityInsight">
    summary?: StringFilter<"CommunityInsight"> | string
    tokenUsage?: IntNullableFilter<"CommunityInsight"> | number | null
    createdAt?: DateTimeFilter<"CommunityInsight"> | Date | string
  }

  export type SearchPatternUpsertWithWhereUniqueWithoutDomainInput = {
    where: SearchPatternWhereUniqueInput
    update: XOR<SearchPatternUpdateWithoutDomainInput, SearchPatternUncheckedUpdateWithoutDomainInput>
    create: XOR<SearchPatternCreateWithoutDomainInput, SearchPatternUncheckedCreateWithoutDomainInput>
  }

  export type SearchPatternUpdateWithWhereUniqueWithoutDomainInput = {
    where: SearchPatternWhereUniqueInput
    data: XOR<SearchPatternUpdateWithoutDomainInput, SearchPatternUncheckedUpdateWithoutDomainInput>
  }

  export type SearchPatternUpdateManyWithWhereWithoutDomainInput = {
    where: SearchPatternScalarWhereInput
    data: XOR<SearchPatternUpdateManyMutationInput, SearchPatternUncheckedUpdateManyWithoutDomainInput>
  }

  export type SearchPatternScalarWhereInput = {
    AND?: SearchPatternScalarWhereInput | SearchPatternScalarWhereInput[]
    OR?: SearchPatternScalarWhereInput[]
    NOT?: SearchPatternScalarWhereInput | SearchPatternScalarWhereInput[]
    id?: IntFilter<"SearchPattern"> | number
    domainId?: IntNullableFilter<"SearchPattern"> | number | null
    keywordId?: IntNullableFilter<"SearchPattern"> | number | null
    patterns?: JsonFilter<"SearchPattern">
    summary?: StringFilter<"SearchPattern"> | string
    tokenUsage?: IntNullableFilter<"SearchPattern"> | number | null
    createdAt?: DateTimeFilter<"SearchPattern"> | Date | string
  }

  export type IntentPhraseGenerationUpsertWithWhereUniqueWithoutDomainInput = {
    where: IntentPhraseGenerationWhereUniqueInput
    update: XOR<IntentPhraseGenerationUpdateWithoutDomainInput, IntentPhraseGenerationUncheckedUpdateWithoutDomainInput>
    create: XOR<IntentPhraseGenerationCreateWithoutDomainInput, IntentPhraseGenerationUncheckedCreateWithoutDomainInput>
  }

  export type IntentPhraseGenerationUpdateWithWhereUniqueWithoutDomainInput = {
    where: IntentPhraseGenerationWhereUniqueInput
    data: XOR<IntentPhraseGenerationUpdateWithoutDomainInput, IntentPhraseGenerationUncheckedUpdateWithoutDomainInput>
  }

  export type IntentPhraseGenerationUpdateManyWithWhereWithoutDomainInput = {
    where: IntentPhraseGenerationScalarWhereInput
    data: XOR<IntentPhraseGenerationUpdateManyMutationInput, IntentPhraseGenerationUncheckedUpdateManyWithoutDomainInput>
  }

  export type IntentPhraseGenerationScalarWhereInput = {
    AND?: IntentPhraseGenerationScalarWhereInput | IntentPhraseGenerationScalarWhereInput[]
    OR?: IntentPhraseGenerationScalarWhereInput[]
    NOT?: IntentPhraseGenerationScalarWhereInput | IntentPhraseGenerationScalarWhereInput[]
    id?: IntFilter<"IntentPhraseGeneration"> | number
    domainId?: IntFilter<"IntentPhraseGeneration"> | number
    status?: StringFilter<"IntentPhraseGeneration"> | string
    phase?: StringFilter<"IntentPhraseGeneration"> | string
    progress?: IntFilter<"IntentPhraseGeneration"> | number
    startTime?: DateTimeFilter<"IntentPhraseGeneration"> | Date | string
    endTime?: DateTimeNullableFilter<"IntentPhraseGeneration"> | Date | string | null
    result?: JsonNullableFilter<"IntentPhraseGeneration">
    error?: StringNullableFilter<"IntentPhraseGeneration"> | string | null
    tokenUsage?: IntNullableFilter<"IntentPhraseGeneration"> | number | null
    createdAt?: DateTimeFilter<"IntentPhraseGeneration"> | Date | string
    updatedAt?: DateTimeFilter<"IntentPhraseGeneration"> | Date | string
  }

  export type CommunityMiningResultUpsertWithWhereUniqueWithoutDomainInput = {
    where: CommunityMiningResultWhereUniqueInput
    update: XOR<CommunityMiningResultUpdateWithoutDomainInput, CommunityMiningResultUncheckedUpdateWithoutDomainInput>
    create: XOR<CommunityMiningResultCreateWithoutDomainInput, CommunityMiningResultUncheckedCreateWithoutDomainInput>
  }

  export type CommunityMiningResultUpdateWithWhereUniqueWithoutDomainInput = {
    where: CommunityMiningResultWhereUniqueInput
    data: XOR<CommunityMiningResultUpdateWithoutDomainInput, CommunityMiningResultUncheckedUpdateWithoutDomainInput>
  }

  export type CommunityMiningResultUpdateManyWithWhereWithoutDomainInput = {
    where: CommunityMiningResultScalarWhereInput
    data: XOR<CommunityMiningResultUpdateManyMutationInput, CommunityMiningResultUncheckedUpdateManyWithoutDomainInput>
  }

  export type CommunityMiningResultScalarWhereInput = {
    AND?: CommunityMiningResultScalarWhereInput | CommunityMiningResultScalarWhereInput[]
    OR?: CommunityMiningResultScalarWhereInput[]
    NOT?: CommunityMiningResultScalarWhereInput | CommunityMiningResultScalarWhereInput[]
    id?: IntFilter<"CommunityMiningResult"> | number
    domainId?: IntFilter<"CommunityMiningResult"> | number
    keywordId?: IntNullableFilter<"CommunityMiningResult"> | number | null
    platform?: StringFilter<"CommunityMiningResult"> | string
    insights?: JsonFilter<"CommunityMiningResult">
    sentiment?: StringNullableFilter<"CommunityMiningResult"> | string | null
    frequency?: IntNullableFilter<"CommunityMiningResult"> | number | null
    tokenUsage?: IntNullableFilter<"CommunityMiningResult"> | number | null
    createdAt?: DateTimeFilter<"CommunityMiningResult"> | Date | string
  }

  export type SearchPatternResultUpsertWithWhereUniqueWithoutDomainInput = {
    where: SearchPatternResultWhereUniqueInput
    update: XOR<SearchPatternResultUpdateWithoutDomainInput, SearchPatternResultUncheckedUpdateWithoutDomainInput>
    create: XOR<SearchPatternResultCreateWithoutDomainInput, SearchPatternResultUncheckedCreateWithoutDomainInput>
  }

  export type SearchPatternResultUpdateWithWhereUniqueWithoutDomainInput = {
    where: SearchPatternResultWhereUniqueInput
    data: XOR<SearchPatternResultUpdateWithoutDomainInput, SearchPatternResultUncheckedUpdateWithoutDomainInput>
  }

  export type SearchPatternResultUpdateManyWithWhereWithoutDomainInput = {
    where: SearchPatternResultScalarWhereInput
    data: XOR<SearchPatternResultUpdateManyMutationInput, SearchPatternResultUncheckedUpdateManyWithoutDomainInput>
  }

  export type SearchPatternResultScalarWhereInput = {
    AND?: SearchPatternResultScalarWhereInput | SearchPatternResultScalarWhereInput[]
    OR?: SearchPatternResultScalarWhereInput[]
    NOT?: SearchPatternResultScalarWhereInput | SearchPatternResultScalarWhereInput[]
    id?: IntFilter<"SearchPatternResult"> | number
    domainId?: IntFilter<"SearchPatternResult"> | number
    keywordId?: IntNullableFilter<"SearchPatternResult"> | number | null
    patterns?: JsonFilter<"SearchPatternResult">
    volume?: IntNullableFilter<"SearchPatternResult"> | number | null
    seasonality?: JsonNullableFilter<"SearchPatternResult">
    trends?: JsonNullableFilter<"SearchPatternResult">
    tokenUsage?: IntNullableFilter<"SearchPatternResult"> | number | null
    createdAt?: DateTimeFilter<"SearchPatternResult"> | Date | string
  }

  export type IntentClassificationResultUpsertWithWhereUniqueWithoutDomainInput = {
    where: IntentClassificationResultWhereUniqueInput
    update: XOR<IntentClassificationResultUpdateWithoutDomainInput, IntentClassificationResultUncheckedUpdateWithoutDomainInput>
    create: XOR<IntentClassificationResultCreateWithoutDomainInput, IntentClassificationResultUncheckedCreateWithoutDomainInput>
  }

  export type IntentClassificationResultUpdateWithWhereUniqueWithoutDomainInput = {
    where: IntentClassificationResultWhereUniqueInput
    data: XOR<IntentClassificationResultUpdateWithoutDomainInput, IntentClassificationResultUncheckedUpdateWithoutDomainInput>
  }

  export type IntentClassificationResultUpdateManyWithWhereWithoutDomainInput = {
    where: IntentClassificationResultScalarWhereInput
    data: XOR<IntentClassificationResultUpdateManyMutationInput, IntentClassificationResultUncheckedUpdateManyWithoutDomainInput>
  }

  export type IntentClassificationResultScalarWhereInput = {
    AND?: IntentClassificationResultScalarWhereInput | IntentClassificationResultScalarWhereInput[]
    OR?: IntentClassificationResultScalarWhereInput[]
    NOT?: IntentClassificationResultScalarWhereInput | IntentClassificationResultScalarWhereInput[]
    id?: IntFilter<"IntentClassificationResult"> | number
    domainId?: IntFilter<"IntentClassificationResult"> | number
    keywordId?: IntNullableFilter<"IntentClassificationResult"> | number | null
    intent?: StringFilter<"IntentClassificationResult"> | string
    confidence?: IntNullableFilter<"IntentClassificationResult"> | number | null
    patterns?: JsonNullableFilter<"IntentClassificationResult">
    tokenUsage?: IntNullableFilter<"IntentClassificationResult"> | number | null
    createdAt?: DateTimeFilter<"IntentClassificationResult"> | Date | string
  }

  export type GeneratedIntentPhraseUpsertWithWhereUniqueWithoutDomainInput = {
    where: GeneratedIntentPhraseWhereUniqueInput
    update: XOR<GeneratedIntentPhraseUpdateWithoutDomainInput, GeneratedIntentPhraseUncheckedUpdateWithoutDomainInput>
    create: XOR<GeneratedIntentPhraseCreateWithoutDomainInput, GeneratedIntentPhraseUncheckedCreateWithoutDomainInput>
  }

  export type GeneratedIntentPhraseUpdateWithWhereUniqueWithoutDomainInput = {
    where: GeneratedIntentPhraseWhereUniqueInput
    data: XOR<GeneratedIntentPhraseUpdateWithoutDomainInput, GeneratedIntentPhraseUncheckedUpdateWithoutDomainInput>
  }

  export type GeneratedIntentPhraseUpdateManyWithWhereWithoutDomainInput = {
    where: GeneratedIntentPhraseScalarWhereInput
    data: XOR<GeneratedIntentPhraseUpdateManyMutationInput, GeneratedIntentPhraseUncheckedUpdateManyWithoutDomainInput>
  }

  export type GeneratedIntentPhraseScalarWhereInput = {
    AND?: GeneratedIntentPhraseScalarWhereInput | GeneratedIntentPhraseScalarWhereInput[]
    OR?: GeneratedIntentPhraseScalarWhereInput[]
    NOT?: GeneratedIntentPhraseScalarWhereInput | GeneratedIntentPhraseScalarWhereInput[]
    id?: IntFilter<"GeneratedIntentPhrase"> | number
    domainId?: IntFilter<"GeneratedIntentPhrase"> | number
    keywordId?: IntNullableFilter<"GeneratedIntentPhrase"> | number | null
    phrase?: StringFilter<"GeneratedIntentPhrase"> | string
    relevanceScore?: IntNullableFilter<"GeneratedIntentPhrase"> | number | null
    intent?: StringNullableFilter<"GeneratedIntentPhrase"> | string | null
    intentConfidence?: IntNullableFilter<"GeneratedIntentPhrase"> | number | null
    sources?: JsonNullableFilter<"GeneratedIntentPhrase">
    trend?: StringNullableFilter<"GeneratedIntentPhrase"> | string | null
    communityInsights?: JsonNullableFilter<"GeneratedIntentPhrase">
    searchPatterns?: JsonNullableFilter<"GeneratedIntentPhrase">
    isSelected?: BoolFilter<"GeneratedIntentPhrase"> | boolean
    tokenUsage?: IntNullableFilter<"GeneratedIntentPhrase"> | number | null
    createdAt?: DateTimeFilter<"GeneratedIntentPhrase"> | Date | string
    updatedAt?: DateTimeFilter<"GeneratedIntentPhrase"> | Date | string
  }

  export type RelevanceScoreResultUpsertWithWhereUniqueWithoutDomainInput = {
    where: RelevanceScoreResultWhereUniqueInput
    update: XOR<RelevanceScoreResultUpdateWithoutDomainInput, RelevanceScoreResultUncheckedUpdateWithoutDomainInput>
    create: XOR<RelevanceScoreResultCreateWithoutDomainInput, RelevanceScoreResultUncheckedCreateWithoutDomainInput>
  }

  export type RelevanceScoreResultUpdateWithWhereUniqueWithoutDomainInput = {
    where: RelevanceScoreResultWhereUniqueInput
    data: XOR<RelevanceScoreResultUpdateWithoutDomainInput, RelevanceScoreResultUncheckedUpdateWithoutDomainInput>
  }

  export type RelevanceScoreResultUpdateManyWithWhereWithoutDomainInput = {
    where: RelevanceScoreResultScalarWhereInput
    data: XOR<RelevanceScoreResultUpdateManyMutationInput, RelevanceScoreResultUncheckedUpdateManyWithoutDomainInput>
  }

  export type RelevanceScoreResultScalarWhereInput = {
    AND?: RelevanceScoreResultScalarWhereInput | RelevanceScoreResultScalarWhereInput[]
    OR?: RelevanceScoreResultScalarWhereInput[]
    NOT?: RelevanceScoreResultScalarWhereInput | RelevanceScoreResultScalarWhereInput[]
    id?: IntFilter<"RelevanceScoreResult"> | number
    domainId?: IntFilter<"RelevanceScoreResult"> | number
    phraseId?: IntNullableFilter<"RelevanceScoreResult"> | number | null
    score?: IntFilter<"RelevanceScoreResult"> | number
    breakdown?: JsonNullableFilter<"RelevanceScoreResult">
    factors?: JsonNullableFilter<"RelevanceScoreResult">
    tokenUsage?: IntNullableFilter<"RelevanceScoreResult"> | number | null
    createdAt?: DateTimeFilter<"RelevanceScoreResult"> | Date | string
  }

  export type DomainCreateWithoutCrawlResultsInput = {
    url: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    user?: UserCreateNestedOneWithoutDomainsInput
    keywords?: KeywordCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultCreateNestedManyWithoutDomainInput
  }

  export type DomainUncheckedCreateWithoutCrawlResultsInput = {
    id?: number
    url: string
    context?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    keywords?: KeywordUncheckedCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisUncheckedCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisUncheckedCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseUncheckedCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisUncheckedCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisUncheckedCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationUncheckedCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedCreateNestedManyWithoutDomainInput
  }

  export type DomainCreateOrConnectWithoutCrawlResultsInput = {
    where: DomainWhereUniqueInput
    create: XOR<DomainCreateWithoutCrawlResultsInput, DomainUncheckedCreateWithoutCrawlResultsInput>
  }

  export type DomainUpsertWithoutCrawlResultsInput = {
    update: XOR<DomainUpdateWithoutCrawlResultsInput, DomainUncheckedUpdateWithoutCrawlResultsInput>
    create: XOR<DomainCreateWithoutCrawlResultsInput, DomainUncheckedCreateWithoutCrawlResultsInput>
    where?: DomainWhereInput
  }

  export type DomainUpdateToOneWithWhereWithoutCrawlResultsInput = {
    where?: DomainWhereInput
    data: XOR<DomainUpdateWithoutCrawlResultsInput, DomainUncheckedUpdateWithoutCrawlResultsInput>
  }

  export type DomainUpdateWithoutCrawlResultsInput = {
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutDomainsNestedInput
    keywords?: KeywordUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUpdateManyWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateWithoutCrawlResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: KeywordUncheckedUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUncheckedUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUncheckedUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type DomainCreateWithoutKeywordsInput = {
    url: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    user?: UserCreateNestedOneWithoutDomainsInput
    crawlResults?: CrawlResultCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultCreateNestedManyWithoutDomainInput
  }

  export type DomainUncheckedCreateWithoutKeywordsInput = {
    id?: number
    url: string
    context?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    crawlResults?: CrawlResultUncheckedCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisUncheckedCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisUncheckedCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseUncheckedCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisUncheckedCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisUncheckedCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationUncheckedCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedCreateNestedManyWithoutDomainInput
  }

  export type DomainCreateOrConnectWithoutKeywordsInput = {
    where: DomainWhereUniqueInput
    create: XOR<DomainCreateWithoutKeywordsInput, DomainUncheckedCreateWithoutKeywordsInput>
  }

  export type PhraseCreateWithoutKeywordInput = {
    text: string
    relevanceScore?: number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: string | null
    intent?: string | null
    confidence?: number | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    phraseIntentClassifications?: PhraseIntentClassificationCreateNestedManyWithoutPhraseInput
    phraseScores?: PhraseScoreCreateNestedManyWithoutPhraseInput
  }

  export type PhraseUncheckedCreateWithoutKeywordInput = {
    id?: number
    text: string
    relevanceScore?: number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: string | null
    intent?: string | null
    confidence?: number | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    phraseIntentClassifications?: PhraseIntentClassificationUncheckedCreateNestedManyWithoutPhraseInput
    phraseScores?: PhraseScoreUncheckedCreateNestedManyWithoutPhraseInput
  }

  export type PhraseCreateOrConnectWithoutKeywordInput = {
    where: PhraseWhereUniqueInput
    create: XOR<PhraseCreateWithoutKeywordInput, PhraseUncheckedCreateWithoutKeywordInput>
  }

  export type PhraseCreateManyKeywordInputEnvelope = {
    data: PhraseCreateManyKeywordInput | PhraseCreateManyKeywordInput[]
    skipDuplicates?: boolean
  }

  export type CommunityInsightCreateWithoutKeywordInput = {
    sources: JsonNullValueInput | InputJsonValue
    summary: string
    tokenUsage?: number | null
    createdAt?: Date | string
    domain?: DomainCreateNestedOneWithoutCommunityInsightsInput
  }

  export type CommunityInsightUncheckedCreateWithoutKeywordInput = {
    id?: number
    domainId?: number | null
    sources: JsonNullValueInput | InputJsonValue
    summary: string
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type CommunityInsightCreateOrConnectWithoutKeywordInput = {
    where: CommunityInsightWhereUniqueInput
    create: XOR<CommunityInsightCreateWithoutKeywordInput, CommunityInsightUncheckedCreateWithoutKeywordInput>
  }

  export type CommunityInsightCreateManyKeywordInputEnvelope = {
    data: CommunityInsightCreateManyKeywordInput | CommunityInsightCreateManyKeywordInput[]
    skipDuplicates?: boolean
  }

  export type SearchPatternCreateWithoutKeywordInput = {
    patterns: JsonNullValueInput | InputJsonValue
    summary: string
    tokenUsage?: number | null
    createdAt?: Date | string
    domain?: DomainCreateNestedOneWithoutSearchPatternsInput
  }

  export type SearchPatternUncheckedCreateWithoutKeywordInput = {
    id?: number
    domainId?: number | null
    patterns: JsonNullValueInput | InputJsonValue
    summary: string
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type SearchPatternCreateOrConnectWithoutKeywordInput = {
    where: SearchPatternWhereUniqueInput
    create: XOR<SearchPatternCreateWithoutKeywordInput, SearchPatternUncheckedCreateWithoutKeywordInput>
  }

  export type SearchPatternCreateManyKeywordInputEnvelope = {
    data: SearchPatternCreateManyKeywordInput | SearchPatternCreateManyKeywordInput[]
    skipDuplicates?: boolean
  }

  export type CommunityMiningResultCreateWithoutKeywordInput = {
    platform: string
    insights: JsonNullValueInput | InputJsonValue
    sentiment?: string | null
    frequency?: number | null
    tokenUsage?: number | null
    createdAt?: Date | string
    domain?: DomainCreateNestedOneWithoutCommunityMiningResultsInput
  }

  export type CommunityMiningResultUncheckedCreateWithoutKeywordInput = {
    id?: number
    domainId: number
    platform: string
    insights: JsonNullValueInput | InputJsonValue
    sentiment?: string | null
    frequency?: number | null
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type CommunityMiningResultCreateOrConnectWithoutKeywordInput = {
    where: CommunityMiningResultWhereUniqueInput
    create: XOR<CommunityMiningResultCreateWithoutKeywordInput, CommunityMiningResultUncheckedCreateWithoutKeywordInput>
  }

  export type CommunityMiningResultCreateManyKeywordInputEnvelope = {
    data: CommunityMiningResultCreateManyKeywordInput | CommunityMiningResultCreateManyKeywordInput[]
    skipDuplicates?: boolean
  }

  export type SearchPatternResultCreateWithoutKeywordInput = {
    patterns: JsonNullValueInput | InputJsonValue
    volume?: number | null
    seasonality?: NullableJsonNullValueInput | InputJsonValue
    trends?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    domain?: DomainCreateNestedOneWithoutSearchPatternResultsInput
  }

  export type SearchPatternResultUncheckedCreateWithoutKeywordInput = {
    id?: number
    domainId: number
    patterns: JsonNullValueInput | InputJsonValue
    volume?: number | null
    seasonality?: NullableJsonNullValueInput | InputJsonValue
    trends?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type SearchPatternResultCreateOrConnectWithoutKeywordInput = {
    where: SearchPatternResultWhereUniqueInput
    create: XOR<SearchPatternResultCreateWithoutKeywordInput, SearchPatternResultUncheckedCreateWithoutKeywordInput>
  }

  export type SearchPatternResultCreateManyKeywordInputEnvelope = {
    data: SearchPatternResultCreateManyKeywordInput | SearchPatternResultCreateManyKeywordInput[]
    skipDuplicates?: boolean
  }

  export type IntentClassificationResultCreateWithoutKeywordInput = {
    intent: string
    confidence?: number | null
    patterns?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    domain?: DomainCreateNestedOneWithoutIntentClassificationResultsInput
  }

  export type IntentClassificationResultUncheckedCreateWithoutKeywordInput = {
    id?: number
    domainId: number
    intent: string
    confidence?: number | null
    patterns?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type IntentClassificationResultCreateOrConnectWithoutKeywordInput = {
    where: IntentClassificationResultWhereUniqueInput
    create: XOR<IntentClassificationResultCreateWithoutKeywordInput, IntentClassificationResultUncheckedCreateWithoutKeywordInput>
  }

  export type IntentClassificationResultCreateManyKeywordInputEnvelope = {
    data: IntentClassificationResultCreateManyKeywordInput | IntentClassificationResultCreateManyKeywordInput[]
    skipDuplicates?: boolean
  }

  export type GeneratedIntentPhraseCreateWithoutKeywordInput = {
    phrase: string
    relevanceScore?: number | null
    intent?: string | null
    intentConfidence?: number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: boolean
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    domain?: DomainCreateNestedOneWithoutGeneratedIntentPhrasesInput
    relevanceScoreResults?: RelevanceScoreResultCreateNestedManyWithoutPhraseInput
    aiQueryResults?: AIQueryResultCreateNestedManyWithoutPhraseInput
  }

  export type GeneratedIntentPhraseUncheckedCreateWithoutKeywordInput = {
    id?: number
    domainId: number
    phrase: string
    relevanceScore?: number | null
    intent?: string | null
    intentConfidence?: number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: boolean
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    relevanceScoreResults?: RelevanceScoreResultUncheckedCreateNestedManyWithoutPhraseInput
    aiQueryResults?: AIQueryResultUncheckedCreateNestedManyWithoutPhraseInput
  }

  export type GeneratedIntentPhraseCreateOrConnectWithoutKeywordInput = {
    where: GeneratedIntentPhraseWhereUniqueInput
    create: XOR<GeneratedIntentPhraseCreateWithoutKeywordInput, GeneratedIntentPhraseUncheckedCreateWithoutKeywordInput>
  }

  export type GeneratedIntentPhraseCreateManyKeywordInputEnvelope = {
    data: GeneratedIntentPhraseCreateManyKeywordInput | GeneratedIntentPhraseCreateManyKeywordInput[]
    skipDuplicates?: boolean
  }

  export type DomainUpsertWithoutKeywordsInput = {
    update: XOR<DomainUpdateWithoutKeywordsInput, DomainUncheckedUpdateWithoutKeywordsInput>
    create: XOR<DomainCreateWithoutKeywordsInput, DomainUncheckedCreateWithoutKeywordsInput>
    where?: DomainWhereInput
  }

  export type DomainUpdateToOneWithWhereWithoutKeywordsInput = {
    where?: DomainWhereInput
    data: XOR<DomainUpdateWithoutKeywordsInput, DomainUncheckedUpdateWithoutKeywordsInput>
  }

  export type DomainUpdateWithoutKeywordsInput = {
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutDomainsNestedInput
    crawlResults?: CrawlResultUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUpdateManyWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateWithoutKeywordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    crawlResults?: CrawlResultUncheckedUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUncheckedUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUncheckedUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type PhraseUpsertWithWhereUniqueWithoutKeywordInput = {
    where: PhraseWhereUniqueInput
    update: XOR<PhraseUpdateWithoutKeywordInput, PhraseUncheckedUpdateWithoutKeywordInput>
    create: XOR<PhraseCreateWithoutKeywordInput, PhraseUncheckedCreateWithoutKeywordInput>
  }

  export type PhraseUpdateWithWhereUniqueWithoutKeywordInput = {
    where: PhraseWhereUniqueInput
    data: XOR<PhraseUpdateWithoutKeywordInput, PhraseUncheckedUpdateWithoutKeywordInput>
  }

  export type PhraseUpdateManyWithWhereWithoutKeywordInput = {
    where: PhraseScalarWhereInput
    data: XOR<PhraseUpdateManyMutationInput, PhraseUncheckedUpdateManyWithoutKeywordInput>
  }

  export type PhraseScalarWhereInput = {
    AND?: PhraseScalarWhereInput | PhraseScalarWhereInput[]
    OR?: PhraseScalarWhereInput[]
    NOT?: PhraseScalarWhereInput | PhraseScalarWhereInput[]
    id?: IntFilter<"Phrase"> | number
    text?: StringFilter<"Phrase"> | string
    keywordId?: IntFilter<"Phrase"> | number
    relevanceScore?: IntNullableFilter<"Phrase"> | number | null
    sources?: JsonNullableFilter<"Phrase">
    trend?: StringNullableFilter<"Phrase"> | string | null
    intent?: StringNullableFilter<"Phrase"> | string | null
    confidence?: IntNullableFilter<"Phrase"> | number | null
    isSelected?: BoolFilter<"Phrase"> | boolean
    createdAt?: DateTimeFilter<"Phrase"> | Date | string
    updatedAt?: DateTimeFilter<"Phrase"> | Date | string
  }

  export type CommunityInsightUpsertWithWhereUniqueWithoutKeywordInput = {
    where: CommunityInsightWhereUniqueInput
    update: XOR<CommunityInsightUpdateWithoutKeywordInput, CommunityInsightUncheckedUpdateWithoutKeywordInput>
    create: XOR<CommunityInsightCreateWithoutKeywordInput, CommunityInsightUncheckedCreateWithoutKeywordInput>
  }

  export type CommunityInsightUpdateWithWhereUniqueWithoutKeywordInput = {
    where: CommunityInsightWhereUniqueInput
    data: XOR<CommunityInsightUpdateWithoutKeywordInput, CommunityInsightUncheckedUpdateWithoutKeywordInput>
  }

  export type CommunityInsightUpdateManyWithWhereWithoutKeywordInput = {
    where: CommunityInsightScalarWhereInput
    data: XOR<CommunityInsightUpdateManyMutationInput, CommunityInsightUncheckedUpdateManyWithoutKeywordInput>
  }

  export type SearchPatternUpsertWithWhereUniqueWithoutKeywordInput = {
    where: SearchPatternWhereUniqueInput
    update: XOR<SearchPatternUpdateWithoutKeywordInput, SearchPatternUncheckedUpdateWithoutKeywordInput>
    create: XOR<SearchPatternCreateWithoutKeywordInput, SearchPatternUncheckedCreateWithoutKeywordInput>
  }

  export type SearchPatternUpdateWithWhereUniqueWithoutKeywordInput = {
    where: SearchPatternWhereUniqueInput
    data: XOR<SearchPatternUpdateWithoutKeywordInput, SearchPatternUncheckedUpdateWithoutKeywordInput>
  }

  export type SearchPatternUpdateManyWithWhereWithoutKeywordInput = {
    where: SearchPatternScalarWhereInput
    data: XOR<SearchPatternUpdateManyMutationInput, SearchPatternUncheckedUpdateManyWithoutKeywordInput>
  }

  export type CommunityMiningResultUpsertWithWhereUniqueWithoutKeywordInput = {
    where: CommunityMiningResultWhereUniqueInput
    update: XOR<CommunityMiningResultUpdateWithoutKeywordInput, CommunityMiningResultUncheckedUpdateWithoutKeywordInput>
    create: XOR<CommunityMiningResultCreateWithoutKeywordInput, CommunityMiningResultUncheckedCreateWithoutKeywordInput>
  }

  export type CommunityMiningResultUpdateWithWhereUniqueWithoutKeywordInput = {
    where: CommunityMiningResultWhereUniqueInput
    data: XOR<CommunityMiningResultUpdateWithoutKeywordInput, CommunityMiningResultUncheckedUpdateWithoutKeywordInput>
  }

  export type CommunityMiningResultUpdateManyWithWhereWithoutKeywordInput = {
    where: CommunityMiningResultScalarWhereInput
    data: XOR<CommunityMiningResultUpdateManyMutationInput, CommunityMiningResultUncheckedUpdateManyWithoutKeywordInput>
  }

  export type SearchPatternResultUpsertWithWhereUniqueWithoutKeywordInput = {
    where: SearchPatternResultWhereUniqueInput
    update: XOR<SearchPatternResultUpdateWithoutKeywordInput, SearchPatternResultUncheckedUpdateWithoutKeywordInput>
    create: XOR<SearchPatternResultCreateWithoutKeywordInput, SearchPatternResultUncheckedCreateWithoutKeywordInput>
  }

  export type SearchPatternResultUpdateWithWhereUniqueWithoutKeywordInput = {
    where: SearchPatternResultWhereUniqueInput
    data: XOR<SearchPatternResultUpdateWithoutKeywordInput, SearchPatternResultUncheckedUpdateWithoutKeywordInput>
  }

  export type SearchPatternResultUpdateManyWithWhereWithoutKeywordInput = {
    where: SearchPatternResultScalarWhereInput
    data: XOR<SearchPatternResultUpdateManyMutationInput, SearchPatternResultUncheckedUpdateManyWithoutKeywordInput>
  }

  export type IntentClassificationResultUpsertWithWhereUniqueWithoutKeywordInput = {
    where: IntentClassificationResultWhereUniqueInput
    update: XOR<IntentClassificationResultUpdateWithoutKeywordInput, IntentClassificationResultUncheckedUpdateWithoutKeywordInput>
    create: XOR<IntentClassificationResultCreateWithoutKeywordInput, IntentClassificationResultUncheckedCreateWithoutKeywordInput>
  }

  export type IntentClassificationResultUpdateWithWhereUniqueWithoutKeywordInput = {
    where: IntentClassificationResultWhereUniqueInput
    data: XOR<IntentClassificationResultUpdateWithoutKeywordInput, IntentClassificationResultUncheckedUpdateWithoutKeywordInput>
  }

  export type IntentClassificationResultUpdateManyWithWhereWithoutKeywordInput = {
    where: IntentClassificationResultScalarWhereInput
    data: XOR<IntentClassificationResultUpdateManyMutationInput, IntentClassificationResultUncheckedUpdateManyWithoutKeywordInput>
  }

  export type GeneratedIntentPhraseUpsertWithWhereUniqueWithoutKeywordInput = {
    where: GeneratedIntentPhraseWhereUniqueInput
    update: XOR<GeneratedIntentPhraseUpdateWithoutKeywordInput, GeneratedIntentPhraseUncheckedUpdateWithoutKeywordInput>
    create: XOR<GeneratedIntentPhraseCreateWithoutKeywordInput, GeneratedIntentPhraseUncheckedCreateWithoutKeywordInput>
  }

  export type GeneratedIntentPhraseUpdateWithWhereUniqueWithoutKeywordInput = {
    where: GeneratedIntentPhraseWhereUniqueInput
    data: XOR<GeneratedIntentPhraseUpdateWithoutKeywordInput, GeneratedIntentPhraseUncheckedUpdateWithoutKeywordInput>
  }

  export type GeneratedIntentPhraseUpdateManyWithWhereWithoutKeywordInput = {
    where: GeneratedIntentPhraseScalarWhereInput
    data: XOR<GeneratedIntentPhraseUpdateManyMutationInput, GeneratedIntentPhraseUncheckedUpdateManyWithoutKeywordInput>
  }

  export type KeywordCreateWithoutPhrasesInput = {
    term: string
    volume: number
    difficulty: string
    cpc: number
    intent?: string | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    domain?: DomainCreateNestedOneWithoutKeywordsInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutKeywordInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutKeywordInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutKeywordInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutKeywordInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutKeywordInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutKeywordInput
  }

  export type KeywordUncheckedCreateWithoutPhrasesInput = {
    id?: number
    term: string
    volume: number
    difficulty: string
    cpc: number
    intent?: string | null
    domainId?: number | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutKeywordInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutKeywordInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutKeywordInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutKeywordInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutKeywordInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutKeywordInput
  }

  export type KeywordCreateOrConnectWithoutPhrasesInput = {
    where: KeywordWhereUniqueInput
    create: XOR<KeywordCreateWithoutPhrasesInput, KeywordUncheckedCreateWithoutPhrasesInput>
  }

  export type PhraseIntentClassificationCreateWithoutPhraseInput = {
    intent: string
    confidence?: number | null
    createdAt?: Date | string
  }

  export type PhraseIntentClassificationUncheckedCreateWithoutPhraseInput = {
    id?: number
    intent: string
    confidence?: number | null
    createdAt?: Date | string
  }

  export type PhraseIntentClassificationCreateOrConnectWithoutPhraseInput = {
    where: PhraseIntentClassificationWhereUniqueInput
    create: XOR<PhraseIntentClassificationCreateWithoutPhraseInput, PhraseIntentClassificationUncheckedCreateWithoutPhraseInput>
  }

  export type PhraseIntentClassificationCreateManyPhraseInputEnvelope = {
    data: PhraseIntentClassificationCreateManyPhraseInput | PhraseIntentClassificationCreateManyPhraseInput[]
    skipDuplicates?: boolean
  }

  export type PhraseScoreCreateWithoutPhraseInput = {
    score: number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PhraseScoreUncheckedCreateWithoutPhraseInput = {
    id?: number
    score: number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PhraseScoreCreateOrConnectWithoutPhraseInput = {
    where: PhraseScoreWhereUniqueInput
    create: XOR<PhraseScoreCreateWithoutPhraseInput, PhraseScoreUncheckedCreateWithoutPhraseInput>
  }

  export type PhraseScoreCreateManyPhraseInputEnvelope = {
    data: PhraseScoreCreateManyPhraseInput | PhraseScoreCreateManyPhraseInput[]
    skipDuplicates?: boolean
  }

  export type KeywordUpsertWithoutPhrasesInput = {
    update: XOR<KeywordUpdateWithoutPhrasesInput, KeywordUncheckedUpdateWithoutPhrasesInput>
    create: XOR<KeywordCreateWithoutPhrasesInput, KeywordUncheckedCreateWithoutPhrasesInput>
    where?: KeywordWhereInput
  }

  export type KeywordUpdateToOneWithWhereWithoutPhrasesInput = {
    where?: KeywordWhereInput
    data: XOR<KeywordUpdateWithoutPhrasesInput, KeywordUncheckedUpdateWithoutPhrasesInput>
  }

  export type KeywordUpdateWithoutPhrasesInput = {
    term?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    cpc?: FloatFieldUpdateOperationsInput | number
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutKeywordsNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutKeywordNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutKeywordNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutKeywordNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutKeywordNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutKeywordNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutKeywordNestedInput
  }

  export type KeywordUncheckedUpdateWithoutPhrasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    term?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    cpc?: FloatFieldUpdateOperationsInput | number
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutKeywordNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutKeywordNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutKeywordNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutKeywordNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutKeywordNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutKeywordNestedInput
  }

  export type PhraseIntentClassificationUpsertWithWhereUniqueWithoutPhraseInput = {
    where: PhraseIntentClassificationWhereUniqueInput
    update: XOR<PhraseIntentClassificationUpdateWithoutPhraseInput, PhraseIntentClassificationUncheckedUpdateWithoutPhraseInput>
    create: XOR<PhraseIntentClassificationCreateWithoutPhraseInput, PhraseIntentClassificationUncheckedCreateWithoutPhraseInput>
  }

  export type PhraseIntentClassificationUpdateWithWhereUniqueWithoutPhraseInput = {
    where: PhraseIntentClassificationWhereUniqueInput
    data: XOR<PhraseIntentClassificationUpdateWithoutPhraseInput, PhraseIntentClassificationUncheckedUpdateWithoutPhraseInput>
  }

  export type PhraseIntentClassificationUpdateManyWithWhereWithoutPhraseInput = {
    where: PhraseIntentClassificationScalarWhereInput
    data: XOR<PhraseIntentClassificationUpdateManyMutationInput, PhraseIntentClassificationUncheckedUpdateManyWithoutPhraseInput>
  }

  export type PhraseIntentClassificationScalarWhereInput = {
    AND?: PhraseIntentClassificationScalarWhereInput | PhraseIntentClassificationScalarWhereInput[]
    OR?: PhraseIntentClassificationScalarWhereInput[]
    NOT?: PhraseIntentClassificationScalarWhereInput | PhraseIntentClassificationScalarWhereInput[]
    id?: IntFilter<"PhraseIntentClassification"> | number
    phraseId?: IntFilter<"PhraseIntentClassification"> | number
    intent?: StringFilter<"PhraseIntentClassification"> | string
    confidence?: IntNullableFilter<"PhraseIntentClassification"> | number | null
    createdAt?: DateTimeFilter<"PhraseIntentClassification"> | Date | string
  }

  export type PhraseScoreUpsertWithWhereUniqueWithoutPhraseInput = {
    where: PhraseScoreWhereUniqueInput
    update: XOR<PhraseScoreUpdateWithoutPhraseInput, PhraseScoreUncheckedUpdateWithoutPhraseInput>
    create: XOR<PhraseScoreCreateWithoutPhraseInput, PhraseScoreUncheckedCreateWithoutPhraseInput>
  }

  export type PhraseScoreUpdateWithWhereUniqueWithoutPhraseInput = {
    where: PhraseScoreWhereUniqueInput
    data: XOR<PhraseScoreUpdateWithoutPhraseInput, PhraseScoreUncheckedUpdateWithoutPhraseInput>
  }

  export type PhraseScoreUpdateManyWithWhereWithoutPhraseInput = {
    where: PhraseScoreScalarWhereInput
    data: XOR<PhraseScoreUpdateManyMutationInput, PhraseScoreUncheckedUpdateManyWithoutPhraseInput>
  }

  export type PhraseScoreScalarWhereInput = {
    AND?: PhraseScoreScalarWhereInput | PhraseScoreScalarWhereInput[]
    OR?: PhraseScoreScalarWhereInput[]
    NOT?: PhraseScoreScalarWhereInput | PhraseScoreScalarWhereInput[]
    id?: IntFilter<"PhraseScore"> | number
    phraseId?: IntFilter<"PhraseScore"> | number
    score?: IntFilter<"PhraseScore"> | number
    breakdown?: JsonNullableFilter<"PhraseScore">
    createdAt?: DateTimeFilter<"PhraseScore"> | Date | string
  }

  export type GeneratedIntentPhraseCreateWithoutAiQueryResultsInput = {
    phrase: string
    relevanceScore?: number | null
    intent?: string | null
    intentConfidence?: number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: boolean
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    domain?: DomainCreateNestedOneWithoutGeneratedIntentPhrasesInput
    keyword?: KeywordCreateNestedOneWithoutGeneratedIntentPhrasesInput
    relevanceScoreResults?: RelevanceScoreResultCreateNestedManyWithoutPhraseInput
  }

  export type GeneratedIntentPhraseUncheckedCreateWithoutAiQueryResultsInput = {
    id?: number
    domainId: number
    keywordId?: number | null
    phrase: string
    relevanceScore?: number | null
    intent?: string | null
    intentConfidence?: number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: boolean
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    relevanceScoreResults?: RelevanceScoreResultUncheckedCreateNestedManyWithoutPhraseInput
  }

  export type GeneratedIntentPhraseCreateOrConnectWithoutAiQueryResultsInput = {
    where: GeneratedIntentPhraseWhereUniqueInput
    create: XOR<GeneratedIntentPhraseCreateWithoutAiQueryResultsInput, GeneratedIntentPhraseUncheckedCreateWithoutAiQueryResultsInput>
  }

  export type GeneratedIntentPhraseUpsertWithoutAiQueryResultsInput = {
    update: XOR<GeneratedIntentPhraseUpdateWithoutAiQueryResultsInput, GeneratedIntentPhraseUncheckedUpdateWithoutAiQueryResultsInput>
    create: XOR<GeneratedIntentPhraseCreateWithoutAiQueryResultsInput, GeneratedIntentPhraseUncheckedCreateWithoutAiQueryResultsInput>
    where?: GeneratedIntentPhraseWhereInput
  }

  export type GeneratedIntentPhraseUpdateToOneWithWhereWithoutAiQueryResultsInput = {
    where?: GeneratedIntentPhraseWhereInput
    data: XOR<GeneratedIntentPhraseUpdateWithoutAiQueryResultsInput, GeneratedIntentPhraseUncheckedUpdateWithoutAiQueryResultsInput>
  }

  export type GeneratedIntentPhraseUpdateWithoutAiQueryResultsInput = {
    phrase?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    intentConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: NullableStringFieldUpdateOperationsInput | string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutGeneratedIntentPhrasesNestedInput
    keyword?: KeywordUpdateOneWithoutGeneratedIntentPhrasesNestedInput
    relevanceScoreResults?: RelevanceScoreResultUpdateManyWithoutPhraseNestedInput
  }

  export type GeneratedIntentPhraseUncheckedUpdateWithoutAiQueryResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    phrase?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    intentConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: NullableStringFieldUpdateOperationsInput | string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relevanceScoreResults?: RelevanceScoreResultUncheckedUpdateManyWithoutPhraseNestedInput
  }

  export type DomainCreateWithoutDashboardAnalysesInput = {
    url: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    user?: UserCreateNestedOneWithoutDomainsInput
    crawlResults?: CrawlResultCreateNestedManyWithoutDomainInput
    keywords?: KeywordCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultCreateNestedManyWithoutDomainInput
  }

  export type DomainUncheckedCreateWithoutDashboardAnalysesInput = {
    id?: number
    url: string
    context?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    crawlResults?: CrawlResultUncheckedCreateNestedManyWithoutDomainInput
    keywords?: KeywordUncheckedCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisUncheckedCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseUncheckedCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisUncheckedCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisUncheckedCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationUncheckedCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedCreateNestedManyWithoutDomainInput
  }

  export type DomainCreateOrConnectWithoutDashboardAnalysesInput = {
    where: DomainWhereUniqueInput
    create: XOR<DomainCreateWithoutDashboardAnalysesInput, DomainUncheckedCreateWithoutDashboardAnalysesInput>
  }

  export type DomainUpsertWithoutDashboardAnalysesInput = {
    update: XOR<DomainUpdateWithoutDashboardAnalysesInput, DomainUncheckedUpdateWithoutDashboardAnalysesInput>
    create: XOR<DomainCreateWithoutDashboardAnalysesInput, DomainUncheckedCreateWithoutDashboardAnalysesInput>
    where?: DomainWhereInput
  }

  export type DomainUpdateToOneWithWhereWithoutDashboardAnalysesInput = {
    where?: DomainWhereInput
    data: XOR<DomainUpdateWithoutDashboardAnalysesInput, DomainUncheckedUpdateWithoutDashboardAnalysesInput>
  }

  export type DomainUpdateWithoutDashboardAnalysesInput = {
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutDomainsNestedInput
    crawlResults?: CrawlResultUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUpdateManyWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateWithoutDashboardAnalysesInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    crawlResults?: CrawlResultUncheckedUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUncheckedUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUncheckedUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUncheckedUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type DomainCreateWithoutCompetitorAnalysesInput = {
    url: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    user?: UserCreateNestedOneWithoutDomainsInput
    crawlResults?: CrawlResultCreateNestedManyWithoutDomainInput
    keywords?: KeywordCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultCreateNestedManyWithoutDomainInput
  }

  export type DomainUncheckedCreateWithoutCompetitorAnalysesInput = {
    id?: number
    url: string
    context?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    crawlResults?: CrawlResultUncheckedCreateNestedManyWithoutDomainInput
    keywords?: KeywordUncheckedCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisUncheckedCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseUncheckedCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisUncheckedCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisUncheckedCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationUncheckedCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedCreateNestedManyWithoutDomainInput
  }

  export type DomainCreateOrConnectWithoutCompetitorAnalysesInput = {
    where: DomainWhereUniqueInput
    create: XOR<DomainCreateWithoutCompetitorAnalysesInput, DomainUncheckedCreateWithoutCompetitorAnalysesInput>
  }

  export type DomainUpsertWithoutCompetitorAnalysesInput = {
    update: XOR<DomainUpdateWithoutCompetitorAnalysesInput, DomainUncheckedUpdateWithoutCompetitorAnalysesInput>
    create: XOR<DomainCreateWithoutCompetitorAnalysesInput, DomainUncheckedCreateWithoutCompetitorAnalysesInput>
    where?: DomainWhereInput
  }

  export type DomainUpdateToOneWithWhereWithoutCompetitorAnalysesInput = {
    where?: DomainWhereInput
    data: XOR<DomainUpdateWithoutCompetitorAnalysesInput, DomainUncheckedUpdateWithoutCompetitorAnalysesInput>
  }

  export type DomainUpdateWithoutCompetitorAnalysesInput = {
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutDomainsNestedInput
    crawlResults?: CrawlResultUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUpdateManyWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateWithoutCompetitorAnalysesInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    crawlResults?: CrawlResultUncheckedUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUncheckedUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUncheckedUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUncheckedUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type DomainCreateWithoutSuggestedCompetitorsInput = {
    url: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    user?: UserCreateNestedOneWithoutDomainsInput
    crawlResults?: CrawlResultCreateNestedManyWithoutDomainInput
    keywords?: KeywordCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultCreateNestedManyWithoutDomainInput
  }

  export type DomainUncheckedCreateWithoutSuggestedCompetitorsInput = {
    id?: number
    url: string
    context?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    crawlResults?: CrawlResultUncheckedCreateNestedManyWithoutDomainInput
    keywords?: KeywordUncheckedCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisUncheckedCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisUncheckedCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseUncheckedCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisUncheckedCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisUncheckedCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationUncheckedCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedCreateNestedManyWithoutDomainInput
  }

  export type DomainCreateOrConnectWithoutSuggestedCompetitorsInput = {
    where: DomainWhereUniqueInput
    create: XOR<DomainCreateWithoutSuggestedCompetitorsInput, DomainUncheckedCreateWithoutSuggestedCompetitorsInput>
  }

  export type DomainUpsertWithoutSuggestedCompetitorsInput = {
    update: XOR<DomainUpdateWithoutSuggestedCompetitorsInput, DomainUncheckedUpdateWithoutSuggestedCompetitorsInput>
    create: XOR<DomainCreateWithoutSuggestedCompetitorsInput, DomainUncheckedCreateWithoutSuggestedCompetitorsInput>
    where?: DomainWhereInput
  }

  export type DomainUpdateToOneWithWhereWithoutSuggestedCompetitorsInput = {
    where?: DomainWhereInput
    data: XOR<DomainUpdateWithoutSuggestedCompetitorsInput, DomainUncheckedUpdateWithoutSuggestedCompetitorsInput>
  }

  export type DomainUpdateWithoutSuggestedCompetitorsInput = {
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutDomainsNestedInput
    crawlResults?: CrawlResultUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUpdateManyWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateWithoutSuggestedCompetitorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    crawlResults?: CrawlResultUncheckedUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUncheckedUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUncheckedUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUncheckedUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type DomainCreateWithoutAnalysisPhasesInput = {
    url: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    user?: UserCreateNestedOneWithoutDomainsInput
    crawlResults?: CrawlResultCreateNestedManyWithoutDomainInput
    keywords?: KeywordCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultCreateNestedManyWithoutDomainInput
  }

  export type DomainUncheckedCreateWithoutAnalysisPhasesInput = {
    id?: number
    url: string
    context?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    crawlResults?: CrawlResultUncheckedCreateNestedManyWithoutDomainInput
    keywords?: KeywordUncheckedCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisUncheckedCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisUncheckedCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisUncheckedCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisUncheckedCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationUncheckedCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedCreateNestedManyWithoutDomainInput
  }

  export type DomainCreateOrConnectWithoutAnalysisPhasesInput = {
    where: DomainWhereUniqueInput
    create: XOR<DomainCreateWithoutAnalysisPhasesInput, DomainUncheckedCreateWithoutAnalysisPhasesInput>
  }

  export type DomainUpsertWithoutAnalysisPhasesInput = {
    update: XOR<DomainUpdateWithoutAnalysisPhasesInput, DomainUncheckedUpdateWithoutAnalysisPhasesInput>
    create: XOR<DomainCreateWithoutAnalysisPhasesInput, DomainUncheckedCreateWithoutAnalysisPhasesInput>
    where?: DomainWhereInput
  }

  export type DomainUpdateToOneWithWhereWithoutAnalysisPhasesInput = {
    where?: DomainWhereInput
    data: XOR<DomainUpdateWithoutAnalysisPhasesInput, DomainUncheckedUpdateWithoutAnalysisPhasesInput>
  }

  export type DomainUpdateWithoutAnalysisPhasesInput = {
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutDomainsNestedInput
    crawlResults?: CrawlResultUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUpdateManyWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateWithoutAnalysisPhasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    crawlResults?: CrawlResultUncheckedUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUncheckedUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUncheckedUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type DomainCreateWithoutSemanticAnalysesInput = {
    url: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    user?: UserCreateNestedOneWithoutDomainsInput
    crawlResults?: CrawlResultCreateNestedManyWithoutDomainInput
    keywords?: KeywordCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultCreateNestedManyWithoutDomainInput
  }

  export type DomainUncheckedCreateWithoutSemanticAnalysesInput = {
    id?: number
    url: string
    context?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    crawlResults?: CrawlResultUncheckedCreateNestedManyWithoutDomainInput
    keywords?: KeywordUncheckedCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisUncheckedCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisUncheckedCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseUncheckedCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisUncheckedCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationUncheckedCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedCreateNestedManyWithoutDomainInput
  }

  export type DomainCreateOrConnectWithoutSemanticAnalysesInput = {
    where: DomainWhereUniqueInput
    create: XOR<DomainCreateWithoutSemanticAnalysesInput, DomainUncheckedCreateWithoutSemanticAnalysesInput>
  }

  export type DomainUpsertWithoutSemanticAnalysesInput = {
    update: XOR<DomainUpdateWithoutSemanticAnalysesInput, DomainUncheckedUpdateWithoutSemanticAnalysesInput>
    create: XOR<DomainCreateWithoutSemanticAnalysesInput, DomainUncheckedCreateWithoutSemanticAnalysesInput>
    where?: DomainWhereInput
  }

  export type DomainUpdateToOneWithWhereWithoutSemanticAnalysesInput = {
    where?: DomainWhereInput
    data: XOR<DomainUpdateWithoutSemanticAnalysesInput, DomainUncheckedUpdateWithoutSemanticAnalysesInput>
  }

  export type DomainUpdateWithoutSemanticAnalysesInput = {
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutDomainsNestedInput
    crawlResults?: CrawlResultUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUpdateManyWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateWithoutSemanticAnalysesInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    crawlResults?: CrawlResultUncheckedUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUncheckedUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUncheckedUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUncheckedUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type DomainCreateWithoutKeywordAnalysesInput = {
    url: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    user?: UserCreateNestedOneWithoutDomainsInput
    crawlResults?: CrawlResultCreateNestedManyWithoutDomainInput
    keywords?: KeywordCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultCreateNestedManyWithoutDomainInput
  }

  export type DomainUncheckedCreateWithoutKeywordAnalysesInput = {
    id?: number
    url: string
    context?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    crawlResults?: CrawlResultUncheckedCreateNestedManyWithoutDomainInput
    keywords?: KeywordUncheckedCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisUncheckedCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisUncheckedCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseUncheckedCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisUncheckedCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationUncheckedCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedCreateNestedManyWithoutDomainInput
  }

  export type DomainCreateOrConnectWithoutKeywordAnalysesInput = {
    where: DomainWhereUniqueInput
    create: XOR<DomainCreateWithoutKeywordAnalysesInput, DomainUncheckedCreateWithoutKeywordAnalysesInput>
  }

  export type DomainUpsertWithoutKeywordAnalysesInput = {
    update: XOR<DomainUpdateWithoutKeywordAnalysesInput, DomainUncheckedUpdateWithoutKeywordAnalysesInput>
    create: XOR<DomainCreateWithoutKeywordAnalysesInput, DomainUncheckedCreateWithoutKeywordAnalysesInput>
    where?: DomainWhereInput
  }

  export type DomainUpdateToOneWithWhereWithoutKeywordAnalysesInput = {
    where?: DomainWhereInput
    data: XOR<DomainUpdateWithoutKeywordAnalysesInput, DomainUncheckedUpdateWithoutKeywordAnalysesInput>
  }

  export type DomainUpdateWithoutKeywordAnalysesInput = {
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutDomainsNestedInput
    crawlResults?: CrawlResultUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUpdateManyWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateWithoutKeywordAnalysesInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    crawlResults?: CrawlResultUncheckedUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUncheckedUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUncheckedUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUncheckedUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type DomainCreateWithoutSearchVolumeClassificationsInput = {
    url: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    user?: UserCreateNestedOneWithoutDomainsInput
    crawlResults?: CrawlResultCreateNestedManyWithoutDomainInput
    keywords?: KeywordCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultCreateNestedManyWithoutDomainInput
  }

  export type DomainUncheckedCreateWithoutSearchVolumeClassificationsInput = {
    id?: number
    url: string
    context?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    crawlResults?: CrawlResultUncheckedCreateNestedManyWithoutDomainInput
    keywords?: KeywordUncheckedCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisUncheckedCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisUncheckedCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseUncheckedCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisUncheckedCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisUncheckedCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationUncheckedCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedCreateNestedManyWithoutDomainInput
  }

  export type DomainCreateOrConnectWithoutSearchVolumeClassificationsInput = {
    where: DomainWhereUniqueInput
    create: XOR<DomainCreateWithoutSearchVolumeClassificationsInput, DomainUncheckedCreateWithoutSearchVolumeClassificationsInput>
  }

  export type DomainUpsertWithoutSearchVolumeClassificationsInput = {
    update: XOR<DomainUpdateWithoutSearchVolumeClassificationsInput, DomainUncheckedUpdateWithoutSearchVolumeClassificationsInput>
    create: XOR<DomainCreateWithoutSearchVolumeClassificationsInput, DomainUncheckedCreateWithoutSearchVolumeClassificationsInput>
    where?: DomainWhereInput
  }

  export type DomainUpdateToOneWithWhereWithoutSearchVolumeClassificationsInput = {
    where?: DomainWhereInput
    data: XOR<DomainUpdateWithoutSearchVolumeClassificationsInput, DomainUncheckedUpdateWithoutSearchVolumeClassificationsInput>
  }

  export type DomainUpdateWithoutSearchVolumeClassificationsInput = {
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutDomainsNestedInput
    crawlResults?: CrawlResultUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUpdateManyWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateWithoutSearchVolumeClassificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    crawlResults?: CrawlResultUncheckedUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUncheckedUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUncheckedUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUncheckedUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type DomainCreateWithoutIntentClassificationsInput = {
    url: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    user?: UserCreateNestedOneWithoutDomainsInput
    crawlResults?: CrawlResultCreateNestedManyWithoutDomainInput
    keywords?: KeywordCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultCreateNestedManyWithoutDomainInput
  }

  export type DomainUncheckedCreateWithoutIntentClassificationsInput = {
    id?: number
    url: string
    context?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    crawlResults?: CrawlResultUncheckedCreateNestedManyWithoutDomainInput
    keywords?: KeywordUncheckedCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisUncheckedCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisUncheckedCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseUncheckedCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisUncheckedCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisUncheckedCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedCreateNestedManyWithoutDomainInput
  }

  export type DomainCreateOrConnectWithoutIntentClassificationsInput = {
    where: DomainWhereUniqueInput
    create: XOR<DomainCreateWithoutIntentClassificationsInput, DomainUncheckedCreateWithoutIntentClassificationsInput>
  }

  export type DomainUpsertWithoutIntentClassificationsInput = {
    update: XOR<DomainUpdateWithoutIntentClassificationsInput, DomainUncheckedUpdateWithoutIntentClassificationsInput>
    create: XOR<DomainCreateWithoutIntentClassificationsInput, DomainUncheckedCreateWithoutIntentClassificationsInput>
    where?: DomainWhereInput
  }

  export type DomainUpdateToOneWithWhereWithoutIntentClassificationsInput = {
    where?: DomainWhereInput
    data: XOR<DomainUpdateWithoutIntentClassificationsInput, DomainUncheckedUpdateWithoutIntentClassificationsInput>
  }

  export type DomainUpdateWithoutIntentClassificationsInput = {
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutDomainsNestedInput
    crawlResults?: CrawlResultUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUpdateManyWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateWithoutIntentClassificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    crawlResults?: CrawlResultUncheckedUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUncheckedUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUncheckedUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type DomainCreateWithoutCommunityInsightsInput = {
    url: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    user?: UserCreateNestedOneWithoutDomainsInput
    crawlResults?: CrawlResultCreateNestedManyWithoutDomainInput
    keywords?: KeywordCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultCreateNestedManyWithoutDomainInput
  }

  export type DomainUncheckedCreateWithoutCommunityInsightsInput = {
    id?: number
    url: string
    context?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    crawlResults?: CrawlResultUncheckedCreateNestedManyWithoutDomainInput
    keywords?: KeywordUncheckedCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisUncheckedCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisUncheckedCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseUncheckedCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisUncheckedCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisUncheckedCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationUncheckedCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedCreateNestedManyWithoutDomainInput
  }

  export type DomainCreateOrConnectWithoutCommunityInsightsInput = {
    where: DomainWhereUniqueInput
    create: XOR<DomainCreateWithoutCommunityInsightsInput, DomainUncheckedCreateWithoutCommunityInsightsInput>
  }

  export type KeywordCreateWithoutCommunityInsightsInput = {
    term: string
    volume: number
    difficulty: string
    cpc: number
    intent?: string | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    domain?: DomainCreateNestedOneWithoutKeywordsInput
    phrases?: PhraseCreateNestedManyWithoutKeywordInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutKeywordInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutKeywordInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutKeywordInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutKeywordInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutKeywordInput
  }

  export type KeywordUncheckedCreateWithoutCommunityInsightsInput = {
    id?: number
    term: string
    volume: number
    difficulty: string
    cpc: number
    intent?: string | null
    domainId?: number | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    phrases?: PhraseUncheckedCreateNestedManyWithoutKeywordInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutKeywordInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutKeywordInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutKeywordInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutKeywordInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutKeywordInput
  }

  export type KeywordCreateOrConnectWithoutCommunityInsightsInput = {
    where: KeywordWhereUniqueInput
    create: XOR<KeywordCreateWithoutCommunityInsightsInput, KeywordUncheckedCreateWithoutCommunityInsightsInput>
  }

  export type DomainUpsertWithoutCommunityInsightsInput = {
    update: XOR<DomainUpdateWithoutCommunityInsightsInput, DomainUncheckedUpdateWithoutCommunityInsightsInput>
    create: XOR<DomainCreateWithoutCommunityInsightsInput, DomainUncheckedCreateWithoutCommunityInsightsInput>
    where?: DomainWhereInput
  }

  export type DomainUpdateToOneWithWhereWithoutCommunityInsightsInput = {
    where?: DomainWhereInput
    data: XOR<DomainUpdateWithoutCommunityInsightsInput, DomainUncheckedUpdateWithoutCommunityInsightsInput>
  }

  export type DomainUpdateWithoutCommunityInsightsInput = {
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutDomainsNestedInput
    crawlResults?: CrawlResultUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUpdateManyWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateWithoutCommunityInsightsInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    crawlResults?: CrawlResultUncheckedUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUncheckedUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUncheckedUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUncheckedUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type KeywordUpsertWithoutCommunityInsightsInput = {
    update: XOR<KeywordUpdateWithoutCommunityInsightsInput, KeywordUncheckedUpdateWithoutCommunityInsightsInput>
    create: XOR<KeywordCreateWithoutCommunityInsightsInput, KeywordUncheckedCreateWithoutCommunityInsightsInput>
    where?: KeywordWhereInput
  }

  export type KeywordUpdateToOneWithWhereWithoutCommunityInsightsInput = {
    where?: KeywordWhereInput
    data: XOR<KeywordUpdateWithoutCommunityInsightsInput, KeywordUncheckedUpdateWithoutCommunityInsightsInput>
  }

  export type KeywordUpdateWithoutCommunityInsightsInput = {
    term?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    cpc?: FloatFieldUpdateOperationsInput | number
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutKeywordsNestedInput
    phrases?: PhraseUpdateManyWithoutKeywordNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutKeywordNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutKeywordNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutKeywordNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutKeywordNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutKeywordNestedInput
  }

  export type KeywordUncheckedUpdateWithoutCommunityInsightsInput = {
    id?: IntFieldUpdateOperationsInput | number
    term?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    cpc?: FloatFieldUpdateOperationsInput | number
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phrases?: PhraseUncheckedUpdateManyWithoutKeywordNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutKeywordNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutKeywordNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutKeywordNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutKeywordNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutKeywordNestedInput
  }

  export type DomainCreateWithoutSearchPatternsInput = {
    url: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    user?: UserCreateNestedOneWithoutDomainsInput
    crawlResults?: CrawlResultCreateNestedManyWithoutDomainInput
    keywords?: KeywordCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultCreateNestedManyWithoutDomainInput
  }

  export type DomainUncheckedCreateWithoutSearchPatternsInput = {
    id?: number
    url: string
    context?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    crawlResults?: CrawlResultUncheckedCreateNestedManyWithoutDomainInput
    keywords?: KeywordUncheckedCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisUncheckedCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisUncheckedCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseUncheckedCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisUncheckedCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisUncheckedCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationUncheckedCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedCreateNestedManyWithoutDomainInput
  }

  export type DomainCreateOrConnectWithoutSearchPatternsInput = {
    where: DomainWhereUniqueInput
    create: XOR<DomainCreateWithoutSearchPatternsInput, DomainUncheckedCreateWithoutSearchPatternsInput>
  }

  export type KeywordCreateWithoutSearchPatternsInput = {
    term: string
    volume: number
    difficulty: string
    cpc: number
    intent?: string | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    domain?: DomainCreateNestedOneWithoutKeywordsInput
    phrases?: PhraseCreateNestedManyWithoutKeywordInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutKeywordInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutKeywordInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutKeywordInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutKeywordInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutKeywordInput
  }

  export type KeywordUncheckedCreateWithoutSearchPatternsInput = {
    id?: number
    term: string
    volume: number
    difficulty: string
    cpc: number
    intent?: string | null
    domainId?: number | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    phrases?: PhraseUncheckedCreateNestedManyWithoutKeywordInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutKeywordInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutKeywordInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutKeywordInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutKeywordInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutKeywordInput
  }

  export type KeywordCreateOrConnectWithoutSearchPatternsInput = {
    where: KeywordWhereUniqueInput
    create: XOR<KeywordCreateWithoutSearchPatternsInput, KeywordUncheckedCreateWithoutSearchPatternsInput>
  }

  export type DomainUpsertWithoutSearchPatternsInput = {
    update: XOR<DomainUpdateWithoutSearchPatternsInput, DomainUncheckedUpdateWithoutSearchPatternsInput>
    create: XOR<DomainCreateWithoutSearchPatternsInput, DomainUncheckedCreateWithoutSearchPatternsInput>
    where?: DomainWhereInput
  }

  export type DomainUpdateToOneWithWhereWithoutSearchPatternsInput = {
    where?: DomainWhereInput
    data: XOR<DomainUpdateWithoutSearchPatternsInput, DomainUncheckedUpdateWithoutSearchPatternsInput>
  }

  export type DomainUpdateWithoutSearchPatternsInput = {
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutDomainsNestedInput
    crawlResults?: CrawlResultUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUpdateManyWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateWithoutSearchPatternsInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    crawlResults?: CrawlResultUncheckedUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUncheckedUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUncheckedUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUncheckedUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type KeywordUpsertWithoutSearchPatternsInput = {
    update: XOR<KeywordUpdateWithoutSearchPatternsInput, KeywordUncheckedUpdateWithoutSearchPatternsInput>
    create: XOR<KeywordCreateWithoutSearchPatternsInput, KeywordUncheckedCreateWithoutSearchPatternsInput>
    where?: KeywordWhereInput
  }

  export type KeywordUpdateToOneWithWhereWithoutSearchPatternsInput = {
    where?: KeywordWhereInput
    data: XOR<KeywordUpdateWithoutSearchPatternsInput, KeywordUncheckedUpdateWithoutSearchPatternsInput>
  }

  export type KeywordUpdateWithoutSearchPatternsInput = {
    term?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    cpc?: FloatFieldUpdateOperationsInput | number
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutKeywordsNestedInput
    phrases?: PhraseUpdateManyWithoutKeywordNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutKeywordNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutKeywordNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutKeywordNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutKeywordNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutKeywordNestedInput
  }

  export type KeywordUncheckedUpdateWithoutSearchPatternsInput = {
    id?: IntFieldUpdateOperationsInput | number
    term?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    cpc?: FloatFieldUpdateOperationsInput | number
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phrases?: PhraseUncheckedUpdateManyWithoutKeywordNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutKeywordNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutKeywordNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutKeywordNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutKeywordNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutKeywordNestedInput
  }

  export type PhraseCreateWithoutPhraseIntentClassificationsInput = {
    text: string
    relevanceScore?: number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: string | null
    intent?: string | null
    confidence?: number | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    keyword: KeywordCreateNestedOneWithoutPhrasesInput
    phraseScores?: PhraseScoreCreateNestedManyWithoutPhraseInput
  }

  export type PhraseUncheckedCreateWithoutPhraseIntentClassificationsInput = {
    id?: number
    text: string
    keywordId: number
    relevanceScore?: number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: string | null
    intent?: string | null
    confidence?: number | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    phraseScores?: PhraseScoreUncheckedCreateNestedManyWithoutPhraseInput
  }

  export type PhraseCreateOrConnectWithoutPhraseIntentClassificationsInput = {
    where: PhraseWhereUniqueInput
    create: XOR<PhraseCreateWithoutPhraseIntentClassificationsInput, PhraseUncheckedCreateWithoutPhraseIntentClassificationsInput>
  }

  export type PhraseUpsertWithoutPhraseIntentClassificationsInput = {
    update: XOR<PhraseUpdateWithoutPhraseIntentClassificationsInput, PhraseUncheckedUpdateWithoutPhraseIntentClassificationsInput>
    create: XOR<PhraseCreateWithoutPhraseIntentClassificationsInput, PhraseUncheckedCreateWithoutPhraseIntentClassificationsInput>
    where?: PhraseWhereInput
  }

  export type PhraseUpdateToOneWithWhereWithoutPhraseIntentClassificationsInput = {
    where?: PhraseWhereInput
    data: XOR<PhraseUpdateWithoutPhraseIntentClassificationsInput, PhraseUncheckedUpdateWithoutPhraseIntentClassificationsInput>
  }

  export type PhraseUpdateWithoutPhraseIntentClassificationsInput = {
    text?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: NullableStringFieldUpdateOperationsInput | string | null
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keyword?: KeywordUpdateOneRequiredWithoutPhrasesNestedInput
    phraseScores?: PhraseScoreUpdateManyWithoutPhraseNestedInput
  }

  export type PhraseUncheckedUpdateWithoutPhraseIntentClassificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    keywordId?: IntFieldUpdateOperationsInput | number
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: NullableStringFieldUpdateOperationsInput | string | null
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phraseScores?: PhraseScoreUncheckedUpdateManyWithoutPhraseNestedInput
  }

  export type PhraseCreateWithoutPhraseScoresInput = {
    text: string
    relevanceScore?: number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: string | null
    intent?: string | null
    confidence?: number | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    keyword: KeywordCreateNestedOneWithoutPhrasesInput
    phraseIntentClassifications?: PhraseIntentClassificationCreateNestedManyWithoutPhraseInput
  }

  export type PhraseUncheckedCreateWithoutPhraseScoresInput = {
    id?: number
    text: string
    keywordId: number
    relevanceScore?: number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: string | null
    intent?: string | null
    confidence?: number | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    phraseIntentClassifications?: PhraseIntentClassificationUncheckedCreateNestedManyWithoutPhraseInput
  }

  export type PhraseCreateOrConnectWithoutPhraseScoresInput = {
    where: PhraseWhereUniqueInput
    create: XOR<PhraseCreateWithoutPhraseScoresInput, PhraseUncheckedCreateWithoutPhraseScoresInput>
  }

  export type PhraseUpsertWithoutPhraseScoresInput = {
    update: XOR<PhraseUpdateWithoutPhraseScoresInput, PhraseUncheckedUpdateWithoutPhraseScoresInput>
    create: XOR<PhraseCreateWithoutPhraseScoresInput, PhraseUncheckedCreateWithoutPhraseScoresInput>
    where?: PhraseWhereInput
  }

  export type PhraseUpdateToOneWithWhereWithoutPhraseScoresInput = {
    where?: PhraseWhereInput
    data: XOR<PhraseUpdateWithoutPhraseScoresInput, PhraseUncheckedUpdateWithoutPhraseScoresInput>
  }

  export type PhraseUpdateWithoutPhraseScoresInput = {
    text?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: NullableStringFieldUpdateOperationsInput | string | null
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keyword?: KeywordUpdateOneRequiredWithoutPhrasesNestedInput
    phraseIntentClassifications?: PhraseIntentClassificationUpdateManyWithoutPhraseNestedInput
  }

  export type PhraseUncheckedUpdateWithoutPhraseScoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    keywordId?: IntFieldUpdateOperationsInput | number
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: NullableStringFieldUpdateOperationsInput | string | null
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phraseIntentClassifications?: PhraseIntentClassificationUncheckedUpdateManyWithoutPhraseNestedInput
  }

  export type DomainCreateWithoutIntentPhraseGenerationsInput = {
    url: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    user?: UserCreateNestedOneWithoutDomainsInput
    crawlResults?: CrawlResultCreateNestedManyWithoutDomainInput
    keywords?: KeywordCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultCreateNestedManyWithoutDomainInput
  }

  export type DomainUncheckedCreateWithoutIntentPhraseGenerationsInput = {
    id?: number
    url: string
    context?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    crawlResults?: CrawlResultUncheckedCreateNestedManyWithoutDomainInput
    keywords?: KeywordUncheckedCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisUncheckedCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisUncheckedCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseUncheckedCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisUncheckedCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisUncheckedCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationUncheckedCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedCreateNestedManyWithoutDomainInput
  }

  export type DomainCreateOrConnectWithoutIntentPhraseGenerationsInput = {
    where: DomainWhereUniqueInput
    create: XOR<DomainCreateWithoutIntentPhraseGenerationsInput, DomainUncheckedCreateWithoutIntentPhraseGenerationsInput>
  }

  export type DomainUpsertWithoutIntentPhraseGenerationsInput = {
    update: XOR<DomainUpdateWithoutIntentPhraseGenerationsInput, DomainUncheckedUpdateWithoutIntentPhraseGenerationsInput>
    create: XOR<DomainCreateWithoutIntentPhraseGenerationsInput, DomainUncheckedCreateWithoutIntentPhraseGenerationsInput>
    where?: DomainWhereInput
  }

  export type DomainUpdateToOneWithWhereWithoutIntentPhraseGenerationsInput = {
    where?: DomainWhereInput
    data: XOR<DomainUpdateWithoutIntentPhraseGenerationsInput, DomainUncheckedUpdateWithoutIntentPhraseGenerationsInput>
  }

  export type DomainUpdateWithoutIntentPhraseGenerationsInput = {
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutDomainsNestedInput
    crawlResults?: CrawlResultUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUpdateManyWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateWithoutIntentPhraseGenerationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    crawlResults?: CrawlResultUncheckedUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUncheckedUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUncheckedUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUncheckedUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type DomainCreateWithoutCommunityMiningResultsInput = {
    url: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    user?: UserCreateNestedOneWithoutDomainsInput
    crawlResults?: CrawlResultCreateNestedManyWithoutDomainInput
    keywords?: KeywordCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultCreateNestedManyWithoutDomainInput
  }

  export type DomainUncheckedCreateWithoutCommunityMiningResultsInput = {
    id?: number
    url: string
    context?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    crawlResults?: CrawlResultUncheckedCreateNestedManyWithoutDomainInput
    keywords?: KeywordUncheckedCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisUncheckedCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisUncheckedCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseUncheckedCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisUncheckedCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisUncheckedCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationUncheckedCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedCreateNestedManyWithoutDomainInput
  }

  export type DomainCreateOrConnectWithoutCommunityMiningResultsInput = {
    where: DomainWhereUniqueInput
    create: XOR<DomainCreateWithoutCommunityMiningResultsInput, DomainUncheckedCreateWithoutCommunityMiningResultsInput>
  }

  export type KeywordCreateWithoutCommunityMiningResultsInput = {
    term: string
    volume: number
    difficulty: string
    cpc: number
    intent?: string | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    domain?: DomainCreateNestedOneWithoutKeywordsInput
    phrases?: PhraseCreateNestedManyWithoutKeywordInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutKeywordInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutKeywordInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutKeywordInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutKeywordInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutKeywordInput
  }

  export type KeywordUncheckedCreateWithoutCommunityMiningResultsInput = {
    id?: number
    term: string
    volume: number
    difficulty: string
    cpc: number
    intent?: string | null
    domainId?: number | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    phrases?: PhraseUncheckedCreateNestedManyWithoutKeywordInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutKeywordInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutKeywordInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutKeywordInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutKeywordInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutKeywordInput
  }

  export type KeywordCreateOrConnectWithoutCommunityMiningResultsInput = {
    where: KeywordWhereUniqueInput
    create: XOR<KeywordCreateWithoutCommunityMiningResultsInput, KeywordUncheckedCreateWithoutCommunityMiningResultsInput>
  }

  export type DomainUpsertWithoutCommunityMiningResultsInput = {
    update: XOR<DomainUpdateWithoutCommunityMiningResultsInput, DomainUncheckedUpdateWithoutCommunityMiningResultsInput>
    create: XOR<DomainCreateWithoutCommunityMiningResultsInput, DomainUncheckedCreateWithoutCommunityMiningResultsInput>
    where?: DomainWhereInput
  }

  export type DomainUpdateToOneWithWhereWithoutCommunityMiningResultsInput = {
    where?: DomainWhereInput
    data: XOR<DomainUpdateWithoutCommunityMiningResultsInput, DomainUncheckedUpdateWithoutCommunityMiningResultsInput>
  }

  export type DomainUpdateWithoutCommunityMiningResultsInput = {
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutDomainsNestedInput
    crawlResults?: CrawlResultUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUpdateManyWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateWithoutCommunityMiningResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    crawlResults?: CrawlResultUncheckedUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUncheckedUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUncheckedUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUncheckedUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type KeywordUpsertWithoutCommunityMiningResultsInput = {
    update: XOR<KeywordUpdateWithoutCommunityMiningResultsInput, KeywordUncheckedUpdateWithoutCommunityMiningResultsInput>
    create: XOR<KeywordCreateWithoutCommunityMiningResultsInput, KeywordUncheckedCreateWithoutCommunityMiningResultsInput>
    where?: KeywordWhereInput
  }

  export type KeywordUpdateToOneWithWhereWithoutCommunityMiningResultsInput = {
    where?: KeywordWhereInput
    data: XOR<KeywordUpdateWithoutCommunityMiningResultsInput, KeywordUncheckedUpdateWithoutCommunityMiningResultsInput>
  }

  export type KeywordUpdateWithoutCommunityMiningResultsInput = {
    term?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    cpc?: FloatFieldUpdateOperationsInput | number
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutKeywordsNestedInput
    phrases?: PhraseUpdateManyWithoutKeywordNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutKeywordNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutKeywordNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutKeywordNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutKeywordNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutKeywordNestedInput
  }

  export type KeywordUncheckedUpdateWithoutCommunityMiningResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    term?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    cpc?: FloatFieldUpdateOperationsInput | number
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phrases?: PhraseUncheckedUpdateManyWithoutKeywordNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutKeywordNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutKeywordNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutKeywordNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutKeywordNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutKeywordNestedInput
  }

  export type DomainCreateWithoutSearchPatternResultsInput = {
    url: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    user?: UserCreateNestedOneWithoutDomainsInput
    crawlResults?: CrawlResultCreateNestedManyWithoutDomainInput
    keywords?: KeywordCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultCreateNestedManyWithoutDomainInput
  }

  export type DomainUncheckedCreateWithoutSearchPatternResultsInput = {
    id?: number
    url: string
    context?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    crawlResults?: CrawlResultUncheckedCreateNestedManyWithoutDomainInput
    keywords?: KeywordUncheckedCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisUncheckedCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisUncheckedCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseUncheckedCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisUncheckedCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisUncheckedCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationUncheckedCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedCreateNestedManyWithoutDomainInput
  }

  export type DomainCreateOrConnectWithoutSearchPatternResultsInput = {
    where: DomainWhereUniqueInput
    create: XOR<DomainCreateWithoutSearchPatternResultsInput, DomainUncheckedCreateWithoutSearchPatternResultsInput>
  }

  export type KeywordCreateWithoutSearchPatternResultsInput = {
    term: string
    volume: number
    difficulty: string
    cpc: number
    intent?: string | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    domain?: DomainCreateNestedOneWithoutKeywordsInput
    phrases?: PhraseCreateNestedManyWithoutKeywordInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutKeywordInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutKeywordInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutKeywordInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutKeywordInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutKeywordInput
  }

  export type KeywordUncheckedCreateWithoutSearchPatternResultsInput = {
    id?: number
    term: string
    volume: number
    difficulty: string
    cpc: number
    intent?: string | null
    domainId?: number | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    phrases?: PhraseUncheckedCreateNestedManyWithoutKeywordInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutKeywordInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutKeywordInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutKeywordInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutKeywordInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutKeywordInput
  }

  export type KeywordCreateOrConnectWithoutSearchPatternResultsInput = {
    where: KeywordWhereUniqueInput
    create: XOR<KeywordCreateWithoutSearchPatternResultsInput, KeywordUncheckedCreateWithoutSearchPatternResultsInput>
  }

  export type DomainUpsertWithoutSearchPatternResultsInput = {
    update: XOR<DomainUpdateWithoutSearchPatternResultsInput, DomainUncheckedUpdateWithoutSearchPatternResultsInput>
    create: XOR<DomainCreateWithoutSearchPatternResultsInput, DomainUncheckedCreateWithoutSearchPatternResultsInput>
    where?: DomainWhereInput
  }

  export type DomainUpdateToOneWithWhereWithoutSearchPatternResultsInput = {
    where?: DomainWhereInput
    data: XOR<DomainUpdateWithoutSearchPatternResultsInput, DomainUncheckedUpdateWithoutSearchPatternResultsInput>
  }

  export type DomainUpdateWithoutSearchPatternResultsInput = {
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutDomainsNestedInput
    crawlResults?: CrawlResultUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUpdateManyWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateWithoutSearchPatternResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    crawlResults?: CrawlResultUncheckedUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUncheckedUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUncheckedUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUncheckedUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type KeywordUpsertWithoutSearchPatternResultsInput = {
    update: XOR<KeywordUpdateWithoutSearchPatternResultsInput, KeywordUncheckedUpdateWithoutSearchPatternResultsInput>
    create: XOR<KeywordCreateWithoutSearchPatternResultsInput, KeywordUncheckedCreateWithoutSearchPatternResultsInput>
    where?: KeywordWhereInput
  }

  export type KeywordUpdateToOneWithWhereWithoutSearchPatternResultsInput = {
    where?: KeywordWhereInput
    data: XOR<KeywordUpdateWithoutSearchPatternResultsInput, KeywordUncheckedUpdateWithoutSearchPatternResultsInput>
  }

  export type KeywordUpdateWithoutSearchPatternResultsInput = {
    term?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    cpc?: FloatFieldUpdateOperationsInput | number
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutKeywordsNestedInput
    phrases?: PhraseUpdateManyWithoutKeywordNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutKeywordNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutKeywordNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutKeywordNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutKeywordNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutKeywordNestedInput
  }

  export type KeywordUncheckedUpdateWithoutSearchPatternResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    term?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    cpc?: FloatFieldUpdateOperationsInput | number
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phrases?: PhraseUncheckedUpdateManyWithoutKeywordNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutKeywordNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutKeywordNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutKeywordNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutKeywordNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutKeywordNestedInput
  }

  export type DomainCreateWithoutIntentClassificationResultsInput = {
    url: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    user?: UserCreateNestedOneWithoutDomainsInput
    crawlResults?: CrawlResultCreateNestedManyWithoutDomainInput
    keywords?: KeywordCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultCreateNestedManyWithoutDomainInput
  }

  export type DomainUncheckedCreateWithoutIntentClassificationResultsInput = {
    id?: number
    url: string
    context?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    crawlResults?: CrawlResultUncheckedCreateNestedManyWithoutDomainInput
    keywords?: KeywordUncheckedCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisUncheckedCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisUncheckedCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseUncheckedCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisUncheckedCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisUncheckedCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationUncheckedCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedCreateNestedManyWithoutDomainInput
  }

  export type DomainCreateOrConnectWithoutIntentClassificationResultsInput = {
    where: DomainWhereUniqueInput
    create: XOR<DomainCreateWithoutIntentClassificationResultsInput, DomainUncheckedCreateWithoutIntentClassificationResultsInput>
  }

  export type KeywordCreateWithoutIntentClassificationResultsInput = {
    term: string
    volume: number
    difficulty: string
    cpc: number
    intent?: string | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    domain?: DomainCreateNestedOneWithoutKeywordsInput
    phrases?: PhraseCreateNestedManyWithoutKeywordInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutKeywordInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutKeywordInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutKeywordInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutKeywordInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutKeywordInput
  }

  export type KeywordUncheckedCreateWithoutIntentClassificationResultsInput = {
    id?: number
    term: string
    volume: number
    difficulty: string
    cpc: number
    intent?: string | null
    domainId?: number | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    phrases?: PhraseUncheckedCreateNestedManyWithoutKeywordInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutKeywordInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutKeywordInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutKeywordInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutKeywordInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutKeywordInput
  }

  export type KeywordCreateOrConnectWithoutIntentClassificationResultsInput = {
    where: KeywordWhereUniqueInput
    create: XOR<KeywordCreateWithoutIntentClassificationResultsInput, KeywordUncheckedCreateWithoutIntentClassificationResultsInput>
  }

  export type DomainUpsertWithoutIntentClassificationResultsInput = {
    update: XOR<DomainUpdateWithoutIntentClassificationResultsInput, DomainUncheckedUpdateWithoutIntentClassificationResultsInput>
    create: XOR<DomainCreateWithoutIntentClassificationResultsInput, DomainUncheckedCreateWithoutIntentClassificationResultsInput>
    where?: DomainWhereInput
  }

  export type DomainUpdateToOneWithWhereWithoutIntentClassificationResultsInput = {
    where?: DomainWhereInput
    data: XOR<DomainUpdateWithoutIntentClassificationResultsInput, DomainUncheckedUpdateWithoutIntentClassificationResultsInput>
  }

  export type DomainUpdateWithoutIntentClassificationResultsInput = {
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutDomainsNestedInput
    crawlResults?: CrawlResultUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUpdateManyWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateWithoutIntentClassificationResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    crawlResults?: CrawlResultUncheckedUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUncheckedUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUncheckedUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUncheckedUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type KeywordUpsertWithoutIntentClassificationResultsInput = {
    update: XOR<KeywordUpdateWithoutIntentClassificationResultsInput, KeywordUncheckedUpdateWithoutIntentClassificationResultsInput>
    create: XOR<KeywordCreateWithoutIntentClassificationResultsInput, KeywordUncheckedCreateWithoutIntentClassificationResultsInput>
    where?: KeywordWhereInput
  }

  export type KeywordUpdateToOneWithWhereWithoutIntentClassificationResultsInput = {
    where?: KeywordWhereInput
    data: XOR<KeywordUpdateWithoutIntentClassificationResultsInput, KeywordUncheckedUpdateWithoutIntentClassificationResultsInput>
  }

  export type KeywordUpdateWithoutIntentClassificationResultsInput = {
    term?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    cpc?: FloatFieldUpdateOperationsInput | number
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutKeywordsNestedInput
    phrases?: PhraseUpdateManyWithoutKeywordNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutKeywordNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutKeywordNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutKeywordNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutKeywordNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutKeywordNestedInput
  }

  export type KeywordUncheckedUpdateWithoutIntentClassificationResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    term?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    cpc?: FloatFieldUpdateOperationsInput | number
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phrases?: PhraseUncheckedUpdateManyWithoutKeywordNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutKeywordNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutKeywordNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutKeywordNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutKeywordNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutKeywordNestedInput
  }

  export type DomainCreateWithoutGeneratedIntentPhrasesInput = {
    url: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    user?: UserCreateNestedOneWithoutDomainsInput
    crawlResults?: CrawlResultCreateNestedManyWithoutDomainInput
    keywords?: KeywordCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultCreateNestedManyWithoutDomainInput
  }

  export type DomainUncheckedCreateWithoutGeneratedIntentPhrasesInput = {
    id?: number
    url: string
    context?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    crawlResults?: CrawlResultUncheckedCreateNestedManyWithoutDomainInput
    keywords?: KeywordUncheckedCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisUncheckedCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisUncheckedCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseUncheckedCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisUncheckedCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisUncheckedCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationUncheckedCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutDomainInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedCreateNestedManyWithoutDomainInput
  }

  export type DomainCreateOrConnectWithoutGeneratedIntentPhrasesInput = {
    where: DomainWhereUniqueInput
    create: XOR<DomainCreateWithoutGeneratedIntentPhrasesInput, DomainUncheckedCreateWithoutGeneratedIntentPhrasesInput>
  }

  export type KeywordCreateWithoutGeneratedIntentPhrasesInput = {
    term: string
    volume: number
    difficulty: string
    cpc: number
    intent?: string | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    domain?: DomainCreateNestedOneWithoutKeywordsInput
    phrases?: PhraseCreateNestedManyWithoutKeywordInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutKeywordInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutKeywordInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutKeywordInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutKeywordInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutKeywordInput
  }

  export type KeywordUncheckedCreateWithoutGeneratedIntentPhrasesInput = {
    id?: number
    term: string
    volume: number
    difficulty: string
    cpc: number
    intent?: string | null
    domainId?: number | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    phrases?: PhraseUncheckedCreateNestedManyWithoutKeywordInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutKeywordInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutKeywordInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutKeywordInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutKeywordInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutKeywordInput
  }

  export type KeywordCreateOrConnectWithoutGeneratedIntentPhrasesInput = {
    where: KeywordWhereUniqueInput
    create: XOR<KeywordCreateWithoutGeneratedIntentPhrasesInput, KeywordUncheckedCreateWithoutGeneratedIntentPhrasesInput>
  }

  export type RelevanceScoreResultCreateWithoutPhraseInput = {
    score: number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    factors?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    domain?: DomainCreateNestedOneWithoutRelevanceScoreResultsInput
  }

  export type RelevanceScoreResultUncheckedCreateWithoutPhraseInput = {
    id?: number
    domainId: number
    score: number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    factors?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type RelevanceScoreResultCreateOrConnectWithoutPhraseInput = {
    where: RelevanceScoreResultWhereUniqueInput
    create: XOR<RelevanceScoreResultCreateWithoutPhraseInput, RelevanceScoreResultUncheckedCreateWithoutPhraseInput>
  }

  export type RelevanceScoreResultCreateManyPhraseInputEnvelope = {
    data: RelevanceScoreResultCreateManyPhraseInput | RelevanceScoreResultCreateManyPhraseInput[]
    skipDuplicates?: boolean
  }

  export type AIQueryResultCreateWithoutPhraseInput = {
    model: string
    response: string
    latency: number
    cost: number
    presence: number
    relevance: number
    accuracy: number
    sentiment: number
    overall: number
    createdAt?: Date | string
  }

  export type AIQueryResultUncheckedCreateWithoutPhraseInput = {
    id?: number
    model: string
    response: string
    latency: number
    cost: number
    presence: number
    relevance: number
    accuracy: number
    sentiment: number
    overall: number
    createdAt?: Date | string
  }

  export type AIQueryResultCreateOrConnectWithoutPhraseInput = {
    where: AIQueryResultWhereUniqueInput
    create: XOR<AIQueryResultCreateWithoutPhraseInput, AIQueryResultUncheckedCreateWithoutPhraseInput>
  }

  export type AIQueryResultCreateManyPhraseInputEnvelope = {
    data: AIQueryResultCreateManyPhraseInput | AIQueryResultCreateManyPhraseInput[]
    skipDuplicates?: boolean
  }

  export type DomainUpsertWithoutGeneratedIntentPhrasesInput = {
    update: XOR<DomainUpdateWithoutGeneratedIntentPhrasesInput, DomainUncheckedUpdateWithoutGeneratedIntentPhrasesInput>
    create: XOR<DomainCreateWithoutGeneratedIntentPhrasesInput, DomainUncheckedCreateWithoutGeneratedIntentPhrasesInput>
    where?: DomainWhereInput
  }

  export type DomainUpdateToOneWithWhereWithoutGeneratedIntentPhrasesInput = {
    where?: DomainWhereInput
    data: XOR<DomainUpdateWithoutGeneratedIntentPhrasesInput, DomainUncheckedUpdateWithoutGeneratedIntentPhrasesInput>
  }

  export type DomainUpdateWithoutGeneratedIntentPhrasesInput = {
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutDomainsNestedInput
    crawlResults?: CrawlResultUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUpdateManyWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateWithoutGeneratedIntentPhrasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    crawlResults?: CrawlResultUncheckedUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUncheckedUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUncheckedUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUncheckedUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type KeywordUpsertWithoutGeneratedIntentPhrasesInput = {
    update: XOR<KeywordUpdateWithoutGeneratedIntentPhrasesInput, KeywordUncheckedUpdateWithoutGeneratedIntentPhrasesInput>
    create: XOR<KeywordCreateWithoutGeneratedIntentPhrasesInput, KeywordUncheckedCreateWithoutGeneratedIntentPhrasesInput>
    where?: KeywordWhereInput
  }

  export type KeywordUpdateToOneWithWhereWithoutGeneratedIntentPhrasesInput = {
    where?: KeywordWhereInput
    data: XOR<KeywordUpdateWithoutGeneratedIntentPhrasesInput, KeywordUncheckedUpdateWithoutGeneratedIntentPhrasesInput>
  }

  export type KeywordUpdateWithoutGeneratedIntentPhrasesInput = {
    term?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    cpc?: FloatFieldUpdateOperationsInput | number
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutKeywordsNestedInput
    phrases?: PhraseUpdateManyWithoutKeywordNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutKeywordNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutKeywordNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutKeywordNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutKeywordNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutKeywordNestedInput
  }

  export type KeywordUncheckedUpdateWithoutGeneratedIntentPhrasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    term?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    cpc?: FloatFieldUpdateOperationsInput | number
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phrases?: PhraseUncheckedUpdateManyWithoutKeywordNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutKeywordNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutKeywordNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutKeywordNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutKeywordNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutKeywordNestedInput
  }

  export type RelevanceScoreResultUpsertWithWhereUniqueWithoutPhraseInput = {
    where: RelevanceScoreResultWhereUniqueInput
    update: XOR<RelevanceScoreResultUpdateWithoutPhraseInput, RelevanceScoreResultUncheckedUpdateWithoutPhraseInput>
    create: XOR<RelevanceScoreResultCreateWithoutPhraseInput, RelevanceScoreResultUncheckedCreateWithoutPhraseInput>
  }

  export type RelevanceScoreResultUpdateWithWhereUniqueWithoutPhraseInput = {
    where: RelevanceScoreResultWhereUniqueInput
    data: XOR<RelevanceScoreResultUpdateWithoutPhraseInput, RelevanceScoreResultUncheckedUpdateWithoutPhraseInput>
  }

  export type RelevanceScoreResultUpdateManyWithWhereWithoutPhraseInput = {
    where: RelevanceScoreResultScalarWhereInput
    data: XOR<RelevanceScoreResultUpdateManyMutationInput, RelevanceScoreResultUncheckedUpdateManyWithoutPhraseInput>
  }

  export type AIQueryResultUpsertWithWhereUniqueWithoutPhraseInput = {
    where: AIQueryResultWhereUniqueInput
    update: XOR<AIQueryResultUpdateWithoutPhraseInput, AIQueryResultUncheckedUpdateWithoutPhraseInput>
    create: XOR<AIQueryResultCreateWithoutPhraseInput, AIQueryResultUncheckedCreateWithoutPhraseInput>
  }

  export type AIQueryResultUpdateWithWhereUniqueWithoutPhraseInput = {
    where: AIQueryResultWhereUniqueInput
    data: XOR<AIQueryResultUpdateWithoutPhraseInput, AIQueryResultUncheckedUpdateWithoutPhraseInput>
  }

  export type AIQueryResultUpdateManyWithWhereWithoutPhraseInput = {
    where: AIQueryResultScalarWhereInput
    data: XOR<AIQueryResultUpdateManyMutationInput, AIQueryResultUncheckedUpdateManyWithoutPhraseInput>
  }

  export type AIQueryResultScalarWhereInput = {
    AND?: AIQueryResultScalarWhereInput | AIQueryResultScalarWhereInput[]
    OR?: AIQueryResultScalarWhereInput[]
    NOT?: AIQueryResultScalarWhereInput | AIQueryResultScalarWhereInput[]
    id?: IntFilter<"AIQueryResult"> | number
    phraseId?: IntFilter<"AIQueryResult"> | number
    model?: StringFilter<"AIQueryResult"> | string
    response?: StringFilter<"AIQueryResult"> | string
    latency?: FloatFilter<"AIQueryResult"> | number
    cost?: FloatFilter<"AIQueryResult"> | number
    presence?: IntFilter<"AIQueryResult"> | number
    relevance?: IntFilter<"AIQueryResult"> | number
    accuracy?: IntFilter<"AIQueryResult"> | number
    sentiment?: IntFilter<"AIQueryResult"> | number
    overall?: FloatFilter<"AIQueryResult"> | number
    createdAt?: DateTimeFilter<"AIQueryResult"> | Date | string
  }

  export type DomainCreateWithoutRelevanceScoreResultsInput = {
    url: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    user?: UserCreateNestedOneWithoutDomainsInput
    crawlResults?: CrawlResultCreateNestedManyWithoutDomainInput
    keywords?: KeywordCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseCreateNestedManyWithoutDomainInput
  }

  export type DomainUncheckedCreateWithoutRelevanceScoreResultsInput = {
    id?: number
    url: string
    context?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
    crawlResults?: CrawlResultUncheckedCreateNestedManyWithoutDomainInput
    keywords?: KeywordUncheckedCreateNestedManyWithoutDomainInput
    dashboardAnalyses?: DashboardAnalysisUncheckedCreateNestedManyWithoutDomainInput
    competitorAnalyses?: CompetitorAnalysisUncheckedCreateNestedManyWithoutDomainInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedCreateNestedManyWithoutDomainInput
    analysisPhases?: AnalysisPhaseUncheckedCreateNestedManyWithoutDomainInput
    semanticAnalyses?: SemanticAnalysisUncheckedCreateNestedManyWithoutDomainInput
    keywordAnalyses?: KeywordAnalysisUncheckedCreateNestedManyWithoutDomainInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedCreateNestedManyWithoutDomainInput
    intentClassifications?: IntentClassificationUncheckedCreateNestedManyWithoutDomainInput
    communityInsights?: CommunityInsightUncheckedCreateNestedManyWithoutDomainInput
    searchPatterns?: SearchPatternUncheckedCreateNestedManyWithoutDomainInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedCreateNestedManyWithoutDomainInput
    communityMiningResults?: CommunityMiningResultUncheckedCreateNestedManyWithoutDomainInput
    searchPatternResults?: SearchPatternResultUncheckedCreateNestedManyWithoutDomainInput
    intentClassificationResults?: IntentClassificationResultUncheckedCreateNestedManyWithoutDomainInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedCreateNestedManyWithoutDomainInput
  }

  export type DomainCreateOrConnectWithoutRelevanceScoreResultsInput = {
    where: DomainWhereUniqueInput
    create: XOR<DomainCreateWithoutRelevanceScoreResultsInput, DomainUncheckedCreateWithoutRelevanceScoreResultsInput>
  }

  export type GeneratedIntentPhraseCreateWithoutRelevanceScoreResultsInput = {
    phrase: string
    relevanceScore?: number | null
    intent?: string | null
    intentConfidence?: number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: boolean
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    domain?: DomainCreateNestedOneWithoutGeneratedIntentPhrasesInput
    keyword?: KeywordCreateNestedOneWithoutGeneratedIntentPhrasesInput
    aiQueryResults?: AIQueryResultCreateNestedManyWithoutPhraseInput
  }

  export type GeneratedIntentPhraseUncheckedCreateWithoutRelevanceScoreResultsInput = {
    id?: number
    domainId: number
    keywordId?: number | null
    phrase: string
    relevanceScore?: number | null
    intent?: string | null
    intentConfidence?: number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: boolean
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiQueryResults?: AIQueryResultUncheckedCreateNestedManyWithoutPhraseInput
  }

  export type GeneratedIntentPhraseCreateOrConnectWithoutRelevanceScoreResultsInput = {
    where: GeneratedIntentPhraseWhereUniqueInput
    create: XOR<GeneratedIntentPhraseCreateWithoutRelevanceScoreResultsInput, GeneratedIntentPhraseUncheckedCreateWithoutRelevanceScoreResultsInput>
  }

  export type DomainUpsertWithoutRelevanceScoreResultsInput = {
    update: XOR<DomainUpdateWithoutRelevanceScoreResultsInput, DomainUncheckedUpdateWithoutRelevanceScoreResultsInput>
    create: XOR<DomainCreateWithoutRelevanceScoreResultsInput, DomainUncheckedCreateWithoutRelevanceScoreResultsInput>
    where?: DomainWhereInput
  }

  export type DomainUpdateToOneWithWhereWithoutRelevanceScoreResultsInput = {
    where?: DomainWhereInput
    data: XOR<DomainUpdateWithoutRelevanceScoreResultsInput, DomainUncheckedUpdateWithoutRelevanceScoreResultsInput>
  }

  export type DomainUpdateWithoutRelevanceScoreResultsInput = {
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutDomainsNestedInput
    crawlResults?: CrawlResultUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateWithoutRelevanceScoreResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    crawlResults?: CrawlResultUncheckedUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUncheckedUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUncheckedUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUncheckedUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type GeneratedIntentPhraseUpsertWithoutRelevanceScoreResultsInput = {
    update: XOR<GeneratedIntentPhraseUpdateWithoutRelevanceScoreResultsInput, GeneratedIntentPhraseUncheckedUpdateWithoutRelevanceScoreResultsInput>
    create: XOR<GeneratedIntentPhraseCreateWithoutRelevanceScoreResultsInput, GeneratedIntentPhraseUncheckedCreateWithoutRelevanceScoreResultsInput>
    where?: GeneratedIntentPhraseWhereInput
  }

  export type GeneratedIntentPhraseUpdateToOneWithWhereWithoutRelevanceScoreResultsInput = {
    where?: GeneratedIntentPhraseWhereInput
    data: XOR<GeneratedIntentPhraseUpdateWithoutRelevanceScoreResultsInput, GeneratedIntentPhraseUncheckedUpdateWithoutRelevanceScoreResultsInput>
  }

  export type GeneratedIntentPhraseUpdateWithoutRelevanceScoreResultsInput = {
    phrase?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    intentConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: NullableStringFieldUpdateOperationsInput | string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutGeneratedIntentPhrasesNestedInput
    keyword?: KeywordUpdateOneWithoutGeneratedIntentPhrasesNestedInput
    aiQueryResults?: AIQueryResultUpdateManyWithoutPhraseNestedInput
  }

  export type GeneratedIntentPhraseUncheckedUpdateWithoutRelevanceScoreResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    phrase?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    intentConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: NullableStringFieldUpdateOperationsInput | string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiQueryResults?: AIQueryResultUncheckedUpdateManyWithoutPhraseNestedInput
  }

  export type DomainCreateManyUserInput = {
    id?: number
    url: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: string | null
    customKeywords?: string | null
    intentPhrases?: string | null
    chatModel?: string | null
    runAllModels?: boolean
    locationContext?: string | null
  }

  export type DomainUpdateWithoutUserInput = {
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    crawlResults?: CrawlResultUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUpdateManyWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
    crawlResults?: CrawlResultUncheckedUpdateManyWithoutDomainNestedInput
    keywords?: KeywordUncheckedUpdateManyWithoutDomainNestedInput
    dashboardAnalyses?: DashboardAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    competitorAnalyses?: CompetitorAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    suggestedCompetitors?: SuggestedCompetitorUncheckedUpdateManyWithoutDomainNestedInput
    analysisPhases?: AnalysisPhaseUncheckedUpdateManyWithoutDomainNestedInput
    semanticAnalyses?: SemanticAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    keywordAnalyses?: KeywordAnalysisUncheckedUpdateManyWithoutDomainNestedInput
    searchVolumeClassifications?: SearchVolumeClassificationUncheckedUpdateManyWithoutDomainNestedInput
    intentClassifications?: IntentClassificationUncheckedUpdateManyWithoutDomainNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutDomainNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutDomainNestedInput
    intentPhraseGenerations?: IntentPhraseGenerationUncheckedUpdateManyWithoutDomainNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutDomainNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutDomainNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutDomainNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutDomainNestedInput
    relevanceScoreResults?: RelevanceScoreResultUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    customKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    intentPhrases?: NullableStringFieldUpdateOperationsInput | string | null
    chatModel?: NullableStringFieldUpdateOperationsInput | string | null
    runAllModels?: BoolFieldUpdateOperationsInput | boolean
    locationContext?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CrawlResultCreateManyDomainInput = {
    id?: number
    pagesScanned: number
    analyzedUrls: string
    extractedContext: string
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type KeywordCreateManyDomainInput = {
    id?: number
    term: string
    volume: number
    difficulty: string
    cpc: number
    intent?: string | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardAnalysisCreateManyDomainInput = {
    id?: number
    metrics: JsonNullValueInput | InputJsonValue
    insights: JsonNullValueInput | InputJsonValue
    industryAnalysis: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompetitorAnalysisCreateManyDomainInput = {
    id?: number
    competitors: JsonNullValueInput | InputJsonValue
    marketInsights: JsonNullValueInput | InputJsonValue
    strategicRecommendations: JsonNullValueInput | InputJsonValue
    competitiveAnalysis: JsonNullValueInput | InputJsonValue
    competitorList: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuggestedCompetitorCreateManyDomainInput = {
    id?: number
    name: string
    competitorDomain: string
    reason: string
    type: string
    createdAt?: Date | string
  }

  export type AnalysisPhaseCreateManyDomainInput = {
    id?: number
    phase: string
    status: string
    progress?: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SemanticAnalysisCreateManyDomainInput = {
    id?: number
    contentSummary: string
    keyThemes: JsonNullValueInput | InputJsonValue
    brandVoice: string
    targetAudience: JsonNullValueInput | InputJsonValue
    contentGaps: JsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeywordAnalysisCreateManyDomainInput = {
    id?: number
    keywords: JsonNullValueInput | InputJsonValue
    searchVolumeData: JsonNullValueInput | InputJsonValue
    intentClassification: JsonNullValueInput | InputJsonValue
    competitiveAnalysis: JsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SearchVolumeClassificationCreateManyDomainInput = {
    id?: number
    highVolumeKeywords: JsonNullValueInput | InputJsonValue
    mediumVolumeKeywords: JsonNullValueInput | InputJsonValue
    lowVolumeKeywords: JsonNullValueInput | InputJsonValue
    volumeTrends: JsonNullValueInput | InputJsonValue
    seasonalPatterns: JsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntentClassificationCreateManyDomainInput = {
    id?: number
    informationalKeywords: JsonNullValueInput | InputJsonValue
    navigationalKeywords: JsonNullValueInput | InputJsonValue
    transactionalKeywords: JsonNullValueInput | InputJsonValue
    commercialKeywords: JsonNullValueInput | InputJsonValue
    intentDistribution: JsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityInsightCreateManyDomainInput = {
    id?: number
    keywordId?: number | null
    sources: JsonNullValueInput | InputJsonValue
    summary: string
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type SearchPatternCreateManyDomainInput = {
    id?: number
    keywordId?: number | null
    patterns: JsonNullValueInput | InputJsonValue
    summary: string
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type IntentPhraseGenerationCreateManyDomainInput = {
    id?: number
    status?: string
    phase: string
    progress?: number
    startTime?: Date | string
    endTime?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityMiningResultCreateManyDomainInput = {
    id?: number
    keywordId?: number | null
    platform: string
    insights: JsonNullValueInput | InputJsonValue
    sentiment?: string | null
    frequency?: number | null
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type SearchPatternResultCreateManyDomainInput = {
    id?: number
    keywordId?: number | null
    patterns: JsonNullValueInput | InputJsonValue
    volume?: number | null
    seasonality?: NullableJsonNullValueInput | InputJsonValue
    trends?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type IntentClassificationResultCreateManyDomainInput = {
    id?: number
    keywordId?: number | null
    intent: string
    confidence?: number | null
    patterns?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type GeneratedIntentPhraseCreateManyDomainInput = {
    id?: number
    keywordId?: number | null
    phrase: string
    relevanceScore?: number | null
    intent?: string | null
    intentConfidence?: number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: boolean
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RelevanceScoreResultCreateManyDomainInput = {
    id?: number
    phraseId?: number | null
    score: number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    factors?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type CrawlResultUpdateWithoutDomainInput = {
    pagesScanned?: IntFieldUpdateOperationsInput | number
    analyzedUrls?: StringFieldUpdateOperationsInput | string
    extractedContext?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrawlResultUncheckedUpdateWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    pagesScanned?: IntFieldUpdateOperationsInput | number
    analyzedUrls?: StringFieldUpdateOperationsInput | string
    extractedContext?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrawlResultUncheckedUpdateManyWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    pagesScanned?: IntFieldUpdateOperationsInput | number
    analyzedUrls?: StringFieldUpdateOperationsInput | string
    extractedContext?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeywordUpdateWithoutDomainInput = {
    term?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    cpc?: FloatFieldUpdateOperationsInput | number
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phrases?: PhraseUpdateManyWithoutKeywordNestedInput
    communityInsights?: CommunityInsightUpdateManyWithoutKeywordNestedInput
    searchPatterns?: SearchPatternUpdateManyWithoutKeywordNestedInput
    communityMiningResults?: CommunityMiningResultUpdateManyWithoutKeywordNestedInput
    searchPatternResults?: SearchPatternResultUpdateManyWithoutKeywordNestedInput
    intentClassificationResults?: IntentClassificationResultUpdateManyWithoutKeywordNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUpdateManyWithoutKeywordNestedInput
  }

  export type KeywordUncheckedUpdateWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    term?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    cpc?: FloatFieldUpdateOperationsInput | number
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phrases?: PhraseUncheckedUpdateManyWithoutKeywordNestedInput
    communityInsights?: CommunityInsightUncheckedUpdateManyWithoutKeywordNestedInput
    searchPatterns?: SearchPatternUncheckedUpdateManyWithoutKeywordNestedInput
    communityMiningResults?: CommunityMiningResultUncheckedUpdateManyWithoutKeywordNestedInput
    searchPatternResults?: SearchPatternResultUncheckedUpdateManyWithoutKeywordNestedInput
    intentClassificationResults?: IntentClassificationResultUncheckedUpdateManyWithoutKeywordNestedInput
    generatedIntentPhrases?: GeneratedIntentPhraseUncheckedUpdateManyWithoutKeywordNestedInput
  }

  export type KeywordUncheckedUpdateManyWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    term?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    cpc?: FloatFieldUpdateOperationsInput | number
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardAnalysisUpdateWithoutDomainInput = {
    metrics?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    industryAnalysis?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardAnalysisUncheckedUpdateWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    metrics?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    industryAnalysis?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardAnalysisUncheckedUpdateManyWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    metrics?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    industryAnalysis?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetitorAnalysisUpdateWithoutDomainInput = {
    competitors?: JsonNullValueInput | InputJsonValue
    marketInsights?: JsonNullValueInput | InputJsonValue
    strategicRecommendations?: JsonNullValueInput | InputJsonValue
    competitiveAnalysis?: JsonNullValueInput | InputJsonValue
    competitorList?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetitorAnalysisUncheckedUpdateWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    competitors?: JsonNullValueInput | InputJsonValue
    marketInsights?: JsonNullValueInput | InputJsonValue
    strategicRecommendations?: JsonNullValueInput | InputJsonValue
    competitiveAnalysis?: JsonNullValueInput | InputJsonValue
    competitorList?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetitorAnalysisUncheckedUpdateManyWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    competitors?: JsonNullValueInput | InputJsonValue
    marketInsights?: JsonNullValueInput | InputJsonValue
    strategicRecommendations?: JsonNullValueInput | InputJsonValue
    competitiveAnalysis?: JsonNullValueInput | InputJsonValue
    competitorList?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuggestedCompetitorUpdateWithoutDomainInput = {
    name?: StringFieldUpdateOperationsInput | string
    competitorDomain?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuggestedCompetitorUncheckedUpdateWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    competitorDomain?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuggestedCompetitorUncheckedUpdateManyWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    competitorDomain?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisPhaseUpdateWithoutDomainInput = {
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisPhaseUncheckedUpdateWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisPhaseUncheckedUpdateManyWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SemanticAnalysisUpdateWithoutDomainInput = {
    contentSummary?: StringFieldUpdateOperationsInput | string
    keyThemes?: JsonNullValueInput | InputJsonValue
    brandVoice?: StringFieldUpdateOperationsInput | string
    targetAudience?: JsonNullValueInput | InputJsonValue
    contentGaps?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SemanticAnalysisUncheckedUpdateWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    contentSummary?: StringFieldUpdateOperationsInput | string
    keyThemes?: JsonNullValueInput | InputJsonValue
    brandVoice?: StringFieldUpdateOperationsInput | string
    targetAudience?: JsonNullValueInput | InputJsonValue
    contentGaps?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SemanticAnalysisUncheckedUpdateManyWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    contentSummary?: StringFieldUpdateOperationsInput | string
    keyThemes?: JsonNullValueInput | InputJsonValue
    brandVoice?: StringFieldUpdateOperationsInput | string
    targetAudience?: JsonNullValueInput | InputJsonValue
    contentGaps?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeywordAnalysisUpdateWithoutDomainInput = {
    keywords?: JsonNullValueInput | InputJsonValue
    searchVolumeData?: JsonNullValueInput | InputJsonValue
    intentClassification?: JsonNullValueInput | InputJsonValue
    competitiveAnalysis?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeywordAnalysisUncheckedUpdateWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywords?: JsonNullValueInput | InputJsonValue
    searchVolumeData?: JsonNullValueInput | InputJsonValue
    intentClassification?: JsonNullValueInput | InputJsonValue
    competitiveAnalysis?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeywordAnalysisUncheckedUpdateManyWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywords?: JsonNullValueInput | InputJsonValue
    searchVolumeData?: JsonNullValueInput | InputJsonValue
    intentClassification?: JsonNullValueInput | InputJsonValue
    competitiveAnalysis?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchVolumeClassificationUpdateWithoutDomainInput = {
    highVolumeKeywords?: JsonNullValueInput | InputJsonValue
    mediumVolumeKeywords?: JsonNullValueInput | InputJsonValue
    lowVolumeKeywords?: JsonNullValueInput | InputJsonValue
    volumeTrends?: JsonNullValueInput | InputJsonValue
    seasonalPatterns?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchVolumeClassificationUncheckedUpdateWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    highVolumeKeywords?: JsonNullValueInput | InputJsonValue
    mediumVolumeKeywords?: JsonNullValueInput | InputJsonValue
    lowVolumeKeywords?: JsonNullValueInput | InputJsonValue
    volumeTrends?: JsonNullValueInput | InputJsonValue
    seasonalPatterns?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchVolumeClassificationUncheckedUpdateManyWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    highVolumeKeywords?: JsonNullValueInput | InputJsonValue
    mediumVolumeKeywords?: JsonNullValueInput | InputJsonValue
    lowVolumeKeywords?: JsonNullValueInput | InputJsonValue
    volumeTrends?: JsonNullValueInput | InputJsonValue
    seasonalPatterns?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentClassificationUpdateWithoutDomainInput = {
    informationalKeywords?: JsonNullValueInput | InputJsonValue
    navigationalKeywords?: JsonNullValueInput | InputJsonValue
    transactionalKeywords?: JsonNullValueInput | InputJsonValue
    commercialKeywords?: JsonNullValueInput | InputJsonValue
    intentDistribution?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentClassificationUncheckedUpdateWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    informationalKeywords?: JsonNullValueInput | InputJsonValue
    navigationalKeywords?: JsonNullValueInput | InputJsonValue
    transactionalKeywords?: JsonNullValueInput | InputJsonValue
    commercialKeywords?: JsonNullValueInput | InputJsonValue
    intentDistribution?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentClassificationUncheckedUpdateManyWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    informationalKeywords?: JsonNullValueInput | InputJsonValue
    navigationalKeywords?: JsonNullValueInput | InputJsonValue
    transactionalKeywords?: JsonNullValueInput | InputJsonValue
    commercialKeywords?: JsonNullValueInput | InputJsonValue
    intentDistribution?: JsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityInsightUpdateWithoutDomainInput = {
    sources?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keyword?: KeywordUpdateOneWithoutCommunityInsightsNestedInput
  }

  export type CommunityInsightUncheckedUpdateWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityInsightUncheckedUpdateManyWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchPatternUpdateWithoutDomainInput = {
    patterns?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keyword?: KeywordUpdateOneWithoutSearchPatternsNestedInput
  }

  export type SearchPatternUncheckedUpdateWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    patterns?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchPatternUncheckedUpdateManyWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    patterns?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentPhraseGenerationUpdateWithoutDomainInput = {
    status?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentPhraseGenerationUncheckedUpdateWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentPhraseGenerationUncheckedUpdateManyWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityMiningResultUpdateWithoutDomainInput = {
    platform?: StringFieldUpdateOperationsInput | string
    insights?: JsonNullValueInput | InputJsonValue
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keyword?: KeywordUpdateOneWithoutCommunityMiningResultsNestedInput
  }

  export type CommunityMiningResultUncheckedUpdateWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    platform?: StringFieldUpdateOperationsInput | string
    insights?: JsonNullValueInput | InputJsonValue
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityMiningResultUncheckedUpdateManyWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    platform?: StringFieldUpdateOperationsInput | string
    insights?: JsonNullValueInput | InputJsonValue
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchPatternResultUpdateWithoutDomainInput = {
    patterns?: JsonNullValueInput | InputJsonValue
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    seasonality?: NullableJsonNullValueInput | InputJsonValue
    trends?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keyword?: KeywordUpdateOneWithoutSearchPatternResultsNestedInput
  }

  export type SearchPatternResultUncheckedUpdateWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    patterns?: JsonNullValueInput | InputJsonValue
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    seasonality?: NullableJsonNullValueInput | InputJsonValue
    trends?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchPatternResultUncheckedUpdateManyWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    patterns?: JsonNullValueInput | InputJsonValue
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    seasonality?: NullableJsonNullValueInput | InputJsonValue
    trends?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentClassificationResultUpdateWithoutDomainInput = {
    intent?: StringFieldUpdateOperationsInput | string
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    patterns?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keyword?: KeywordUpdateOneWithoutIntentClassificationResultsNestedInput
  }

  export type IntentClassificationResultUncheckedUpdateWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    intent?: StringFieldUpdateOperationsInput | string
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    patterns?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentClassificationResultUncheckedUpdateManyWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    intent?: StringFieldUpdateOperationsInput | string
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    patterns?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedIntentPhraseUpdateWithoutDomainInput = {
    phrase?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    intentConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: NullableStringFieldUpdateOperationsInput | string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keyword?: KeywordUpdateOneWithoutGeneratedIntentPhrasesNestedInput
    relevanceScoreResults?: RelevanceScoreResultUpdateManyWithoutPhraseNestedInput
    aiQueryResults?: AIQueryResultUpdateManyWithoutPhraseNestedInput
  }

  export type GeneratedIntentPhraseUncheckedUpdateWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    phrase?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    intentConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: NullableStringFieldUpdateOperationsInput | string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relevanceScoreResults?: RelevanceScoreResultUncheckedUpdateManyWithoutPhraseNestedInput
    aiQueryResults?: AIQueryResultUncheckedUpdateManyWithoutPhraseNestedInput
  }

  export type GeneratedIntentPhraseUncheckedUpdateManyWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywordId?: NullableIntFieldUpdateOperationsInput | number | null
    phrase?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    intentConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: NullableStringFieldUpdateOperationsInput | string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelevanceScoreResultUpdateWithoutDomainInput = {
    score?: IntFieldUpdateOperationsInput | number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    factors?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phrase?: GeneratedIntentPhraseUpdateOneWithoutRelevanceScoreResultsNestedInput
  }

  export type RelevanceScoreResultUncheckedUpdateWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    phraseId?: NullableIntFieldUpdateOperationsInput | number | null
    score?: IntFieldUpdateOperationsInput | number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    factors?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelevanceScoreResultUncheckedUpdateManyWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    phraseId?: NullableIntFieldUpdateOperationsInput | number | null
    score?: IntFieldUpdateOperationsInput | number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    factors?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhraseCreateManyKeywordInput = {
    id?: number
    text: string
    relevanceScore?: number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: string | null
    intent?: string | null
    confidence?: number | null
    isSelected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityInsightCreateManyKeywordInput = {
    id?: number
    domainId?: number | null
    sources: JsonNullValueInput | InputJsonValue
    summary: string
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type SearchPatternCreateManyKeywordInput = {
    id?: number
    domainId?: number | null
    patterns: JsonNullValueInput | InputJsonValue
    summary: string
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type CommunityMiningResultCreateManyKeywordInput = {
    id?: number
    domainId: number
    platform: string
    insights: JsonNullValueInput | InputJsonValue
    sentiment?: string | null
    frequency?: number | null
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type SearchPatternResultCreateManyKeywordInput = {
    id?: number
    domainId: number
    patterns: JsonNullValueInput | InputJsonValue
    volume?: number | null
    seasonality?: NullableJsonNullValueInput | InputJsonValue
    trends?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type IntentClassificationResultCreateManyKeywordInput = {
    id?: number
    domainId: number
    intent: string
    confidence?: number | null
    patterns?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type GeneratedIntentPhraseCreateManyKeywordInput = {
    id?: number
    domainId: number
    phrase: string
    relevanceScore?: number | null
    intent?: string | null
    intentConfidence?: number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: boolean
    tokenUsage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhraseUpdateWithoutKeywordInput = {
    text?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: NullableStringFieldUpdateOperationsInput | string | null
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phraseIntentClassifications?: PhraseIntentClassificationUpdateManyWithoutPhraseNestedInput
    phraseScores?: PhraseScoreUpdateManyWithoutPhraseNestedInput
  }

  export type PhraseUncheckedUpdateWithoutKeywordInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: NullableStringFieldUpdateOperationsInput | string | null
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phraseIntentClassifications?: PhraseIntentClassificationUncheckedUpdateManyWithoutPhraseNestedInput
    phraseScores?: PhraseScoreUncheckedUpdateManyWithoutPhraseNestedInput
  }

  export type PhraseUncheckedUpdateManyWithoutKeywordInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: NullableStringFieldUpdateOperationsInput | string | null
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityInsightUpdateWithoutKeywordInput = {
    sources?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutCommunityInsightsNestedInput
  }

  export type CommunityInsightUncheckedUpdateWithoutKeywordInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityInsightUncheckedUpdateManyWithoutKeywordInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchPatternUpdateWithoutKeywordInput = {
    patterns?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutSearchPatternsNestedInput
  }

  export type SearchPatternUncheckedUpdateWithoutKeywordInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    patterns?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchPatternUncheckedUpdateManyWithoutKeywordInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: NullableIntFieldUpdateOperationsInput | number | null
    patterns?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityMiningResultUpdateWithoutKeywordInput = {
    platform?: StringFieldUpdateOperationsInput | string
    insights?: JsonNullValueInput | InputJsonValue
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutCommunityMiningResultsNestedInput
  }

  export type CommunityMiningResultUncheckedUpdateWithoutKeywordInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    platform?: StringFieldUpdateOperationsInput | string
    insights?: JsonNullValueInput | InputJsonValue
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityMiningResultUncheckedUpdateManyWithoutKeywordInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    platform?: StringFieldUpdateOperationsInput | string
    insights?: JsonNullValueInput | InputJsonValue
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchPatternResultUpdateWithoutKeywordInput = {
    patterns?: JsonNullValueInput | InputJsonValue
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    seasonality?: NullableJsonNullValueInput | InputJsonValue
    trends?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutSearchPatternResultsNestedInput
  }

  export type SearchPatternResultUncheckedUpdateWithoutKeywordInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    patterns?: JsonNullValueInput | InputJsonValue
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    seasonality?: NullableJsonNullValueInput | InputJsonValue
    trends?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchPatternResultUncheckedUpdateManyWithoutKeywordInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    patterns?: JsonNullValueInput | InputJsonValue
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    seasonality?: NullableJsonNullValueInput | InputJsonValue
    trends?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentClassificationResultUpdateWithoutKeywordInput = {
    intent?: StringFieldUpdateOperationsInput | string
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    patterns?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutIntentClassificationResultsNestedInput
  }

  export type IntentClassificationResultUncheckedUpdateWithoutKeywordInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    intent?: StringFieldUpdateOperationsInput | string
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    patterns?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentClassificationResultUncheckedUpdateManyWithoutKeywordInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    intent?: StringFieldUpdateOperationsInput | string
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    patterns?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedIntentPhraseUpdateWithoutKeywordInput = {
    phrase?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    intentConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: NullableStringFieldUpdateOperationsInput | string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutGeneratedIntentPhrasesNestedInput
    relevanceScoreResults?: RelevanceScoreResultUpdateManyWithoutPhraseNestedInput
    aiQueryResults?: AIQueryResultUpdateManyWithoutPhraseNestedInput
  }

  export type GeneratedIntentPhraseUncheckedUpdateWithoutKeywordInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    phrase?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    intentConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: NullableStringFieldUpdateOperationsInput | string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relevanceScoreResults?: RelevanceScoreResultUncheckedUpdateManyWithoutPhraseNestedInput
    aiQueryResults?: AIQueryResultUncheckedUpdateManyWithoutPhraseNestedInput
  }

  export type GeneratedIntentPhraseUncheckedUpdateManyWithoutKeywordInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    phrase?: StringFieldUpdateOperationsInput | string
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    intentConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableJsonNullValueInput | InputJsonValue
    trend?: NullableStringFieldUpdateOperationsInput | string | null
    communityInsights?: NullableJsonNullValueInput | InputJsonValue
    searchPatterns?: NullableJsonNullValueInput | InputJsonValue
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhraseIntentClassificationCreateManyPhraseInput = {
    id?: number
    intent: string
    confidence?: number | null
    createdAt?: Date | string
  }

  export type PhraseScoreCreateManyPhraseInput = {
    id?: number
    score: number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PhraseIntentClassificationUpdateWithoutPhraseInput = {
    intent?: StringFieldUpdateOperationsInput | string
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhraseIntentClassificationUncheckedUpdateWithoutPhraseInput = {
    id?: IntFieldUpdateOperationsInput | number
    intent?: StringFieldUpdateOperationsInput | string
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhraseIntentClassificationUncheckedUpdateManyWithoutPhraseInput = {
    id?: IntFieldUpdateOperationsInput | number
    intent?: StringFieldUpdateOperationsInput | string
    confidence?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhraseScoreUpdateWithoutPhraseInput = {
    score?: IntFieldUpdateOperationsInput | number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhraseScoreUncheckedUpdateWithoutPhraseInput = {
    id?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhraseScoreUncheckedUpdateManyWithoutPhraseInput = {
    id?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelevanceScoreResultCreateManyPhraseInput = {
    id?: number
    domainId: number
    score: number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    factors?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: number | null
    createdAt?: Date | string
  }

  export type AIQueryResultCreateManyPhraseInput = {
    id?: number
    model: string
    response: string
    latency: number
    cost: number
    presence: number
    relevance: number
    accuracy: number
    sentiment: number
    overall: number
    createdAt?: Date | string
  }

  export type RelevanceScoreResultUpdateWithoutPhraseInput = {
    score?: IntFieldUpdateOperationsInput | number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    factors?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneWithoutRelevanceScoreResultsNestedInput
  }

  export type RelevanceScoreResultUncheckedUpdateWithoutPhraseInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    factors?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelevanceScoreResultUncheckedUpdateManyWithoutPhraseInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    breakdown?: NullableJsonNullValueInput | InputJsonValue
    factors?: NullableJsonNullValueInput | InputJsonValue
    tokenUsage?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIQueryResultUpdateWithoutPhraseInput = {
    model?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    latency?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    presence?: IntFieldUpdateOperationsInput | number
    relevance?: IntFieldUpdateOperationsInput | number
    accuracy?: IntFieldUpdateOperationsInput | number
    sentiment?: IntFieldUpdateOperationsInput | number
    overall?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIQueryResultUncheckedUpdateWithoutPhraseInput = {
    id?: IntFieldUpdateOperationsInput | number
    model?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    latency?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    presence?: IntFieldUpdateOperationsInput | number
    relevance?: IntFieldUpdateOperationsInput | number
    accuracy?: IntFieldUpdateOperationsInput | number
    sentiment?: IntFieldUpdateOperationsInput | number
    overall?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIQueryResultUncheckedUpdateManyWithoutPhraseInput = {
    id?: IntFieldUpdateOperationsInput | number
    model?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    latency?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    presence?: IntFieldUpdateOperationsInput | number
    relevance?: IntFieldUpdateOperationsInput | number
    accuracy?: IntFieldUpdateOperationsInput | number
    sentiment?: IntFieldUpdateOperationsInput | number
    overall?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}